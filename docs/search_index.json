[
["index.html", "데이터과학: R로 배우는 중등 수학 1 시작하기에 앞서 지은이 소개 이 책의 구성", " 데이터과학: R로 배우는 중등 수학 1 글: seongcho, 표지 그림: milktea3 2021-05-18 시작하기에 앞서 지은이 소개 이 책(https://seongcho1.github.io/rmath01)은 seongcho가 쓰고, milktea3가 표지 그림을 디자인했습니다. seongcho는 우연히 중학교 \\(1\\)학년 수학 교과서를 보게 되고 중등 수학 개념들을 R로 구현해보면 어떨까 하는 생각에서 이 책을 시작하게 되었습니다. 그리고, 시작을 하였으니 끝까지 쓰게 되었습니다. seongcho seongcho는 최근 몇 년간 데이터 처리, 분석, 시각화에 주로 R을 이용해 왔으며, R의 다양한 패키지들을 통하여 다양한 분야로 관심을 확장하고 있습니다. 현재는 데이터 사이언스에 푹 빠져있으며 C 언어를 비롯한 다양한 프로그래밍 언어들을 더 깊게 배우는 중입니다. 팟캐스트 듣기, 걷기, 카푸치노 마시기, 킨들로 책읽기를 좋아합니다. milktea3 milktea3는 애플 펜슬로 라인 스티커 (https://rebrand.ly/line_milktea3)와 네이버 OGQ 마켓 스티커 (https://rebrand.ly/naver_milktea)를 디자인하고, 캔버스나 예쁜 돌 위에 그림 그리기를 좋아합니다. 클라리넷 주자로 오케스트라 활동을 \\(3\\)년 째 하고 있으며, 친구들과 농구하기, 노래 부르고 춤추기를 좋아합니다. 프리코드캠프 (https://freecodecamp.org/milktea13)에서 html, css, javascript도 꾸준히 공부하고 있습니다. 하지만, 넷플릭스와 유튜브에 한번 빠지면 시간 가는 줄 모릅니다. 이 책의 구성 이 책은 중등 수학 1의 개념들을 R에서 어떻게 다룰 수 있을까? 라는 의문에서 출발했기 때문에, 제목과는 다르게 이 책에서 다루는 내용은 ’중등 수학 1로 배우는 R’에 더 가깝습니다. 중등 수학 1 교과서의 차례를 따라가며 R을 활용하는 방법을 다룹니다. 1장 R 시작하기에서는 R의 핵심적인 데이터 객체인 벡터와 데이터 프레임에 대해서 알아보고 기본적인 소스코드 작성법에 대하여 익혀봅니다. 2장 수와 연산에서는 벡터, 리스트, 데이터 프레임 등의 데이터 객체와 반복문, 조건문, 연산자, 함수 등을 활용하여 원하는 로직을 소스코드로 구현하는 방법을 알아보고, 중요 패키지인 dplyr와 ggplot2의 사용법을 익혀봅니다. 3장 문자와 식에서는 자연수의 소인수분해, 최대공약수와 최소공배수 구하기, 정수와 유리수의 대소관계 및 절대값, 정수와 유리수의 연산를 다루면서 벡터, 리스트, 데이터 프레임 등의 데이터 객체들을 알아보고, 반복문, 조건문, 연산자, 함수 등을 활용하여 원하는 로직을 구현하는 방법을 익혀봅니다. 4장 좌표평면과 그래프에서는 좌표를 이용하여 두 변수 간의 관계를 그래프로 그려보고, 두 변수들 간의 관계 식을 이용하여 정비례 관계에 있는지 반비례 관계에 있는지 알아봅니다. 두 변수의 관계를 측정, 기록, 표현, 시각화하는데 표, 수식 및 그래프를 사용하는 방법을 익혀봅니다. 5장 도형의 기초에서는 점, 선, 면과 이 들 간의 위치 관계를 알아봅니다. 각, 평행선, 삼각형의 성질을 이 들을 그림으로 그리는 방법을 익혀봅니다. 6장 도형의 성질에서는 다각형, 원, 부채꼴과 같은 평면도형과 다면체, 기둥, 뿔, 구와 같은 입체도형의 성질에 대해서 알아보고 도형들을 그리는 여러가지 방법들을 익혀봅니다. 7장 통계에서는 통계적 대푯값과 그림 상자, 도수분포표, 히스토그램, 상대도수 등의 통계 기본 개념을 알아보고 다양한 데이터 탐색 기법과 시각화 기법을 익혀봅니다. "],
["r-get-started.html", "1 R 시작하기 1.1 왜 R인가? 1.2 R과 RStudio 설치하기 1.3 R로 소스코드 작성하기", " 1 R 시작하기 이 책을 읽고 활용하기 위해서는 여러분은 두 가지 선행 조건을 만족시켜야 합니다. 첫째, 초등수학 교육 과정을 수료했어야 합니다. 중등 수학 \\(1\\)학년 과정을 다루기 때문에 초등학교 \\(6\\)학년 수준의 수학 내용을 이미 이해하고 있어야 합니다. 이 책은 중등 수학 \\(1\\)학년 과정의 입문서는 아니기 때문에 수학 개념 하나 하나에 대해서 친절히 설명하고 있지는 않습니다. 둘째, 사용할 컴퓨터에 R과 RStudio가 설치되어 있어야 합니다. 1.1 왜 R인가? 소프트웨어 개발을 위한 목적으로 만들어진 언어인 C, Java, Python과는 달리, R은 통계학자에 의해 만들어졌으며 데이터 분석을 위한 상호작용 환경 (interactive environment)을 제공하는 도구입니다. 상호작용 환경을 통하여 사용자는 데이터를 빠르고 쉽게 탐색해보고 분석할 수 있을 뿐 아니라, 작업 내용을 스크립트 형태로 저장했다가 나중에 분석 과정을 그대로 재현해 볼 수도 있습니다. R은 무료이고 오픈소스입니다. 여러 플랫폼에서 작동하며 여러 과학 분야 전문가들이 사용합니다. 여러 플랫폼 (Windows, Mac Os, UNIX/Linux)에서 작동하기 때문에, 플랫폼에 상관없이 스크립트와 데이터 객체들을 공유할 수 있습니다. 컴퓨터 공학, 통계학, 경제학, 생태학, 사회 과학, 지리학 등의 여러 분야 전문가가 활발히 활동하는 R 사용자 커뮤니티를 통해 배우고 질문할 수 있을 뿐 아니라 그들이 만든 다양한 R 팩키지를 통하여 새로운 분야의 데이터 과학 방법론을 쉽게 활용해 볼 수 있습니다. 1.2 R과 RStudio 설치하기 R을 다운로드 하기 위해서 사용할 컴퓨터에서 웹 브라우저를 열고 https://cran.rstudio.com/로 이동합니다. 윈도우즈, 리눅스, 맥용 설치 파일 링크 중 해당 링크를 선택하고 해당 설치 파일을 다운로드한 후 컴퓨터에 설치합니다. 새로운 버전의 R은 1년에 두세 번 정도 릴리즈 되기 때문에 정기적으로 버전 업데이트하는 것이 좋습니다. RStudio는 R 프로그래밍을 위한 통합 개발 환경 (integrated development environment, or IDE)을 제공합니다. https://www.rstudio.com/download에서 다운로드하여 설치할 수 있습니다. 무료 오픈소스 버전인 RStudio Desktop을 설치합니다. RStudio 또한 1년에 두세 번 정도 새로운 버전이 릴리즈 되므로 정기적으로 버전 업데이트하는 것이 좋습니다. RStudio를 설치한 후, 한글 데이터 처리 시 한글이 깨지는 문제를 막기 위해서 RStudio를 실행하여 아래와 같이 Global Option과 Project Option을 설정합니다. Global Option 설정하기 메뉴에서 Tools &gt;&gt; Global Options…를 클릭 Code &gt;&gt; Saving TAB에서 Default text encoding을 UTF-8로 설정 Project Option 설정 확인하기 메뉴에서 File &gt;&gt; New Project…를 클릭 New Directory &gt;&gt; New Project &gt;&gt; Directory Name을 rmath01로 설정 Create project as subdirectory of의 Browse…버튼을 클릭하여 원하는 폴더 설정 Create Project 버튼을 클릭하여 프로젝트 생성 메뉴에서 Tools &gt;&gt; Project Options…를 클릭 Code Editing &gt;&gt; Text encoding을 UTF-8로 설정되어 있는지 확인 메뉴에서 File &gt;&gt; Close Project를 클릭하여 프로젝트 닫기 메뉴에서 File &gt;&gt; Quit Session…을 클릭하여 RStudio 세션 종료 Project 열기 RStudio 실행 메뉴에서 File &gt;&gt; Open Project…를 클릭 위에서 프로젝트를 저장한 폴더를 찾아가서 rmath01.Rproj을 선택하고 Open 버튼 클릭 또는 파일탐색기나 파인더에서 프로젝트를 저장한 폴더를 찾아가서 rmath01.Rproj 파일을 더블 클릭 1.3 R로 소스코드 작성하기 RStudio를 실행하고 콘솔 (console) 창에 소스코드를 입력하고 엔터를 눌러서 실행할 수 있습니다. #으로 시작하는 라인은 주석문 (코멘트, comment)으로 코드, 함수, 결과 등에 대한 설명을 메모하여 소스코드를 더 잘 이해할 수 있게 도와줍니다. 6+1 ## [1] 7 위의 코드를 RStudio의 콘솔에 입력하고 엔터를 눌러서 실행하면 결과는 아래와 같이 나옵니다. &gt; 6+1 [1] 7 책에 나오는 소스코드에는 콘솔의 프롬프트 (&gt;, prompt)가 보이지 않지만, 여러분은 RStudio 콘솔의 프롬프트 (&gt;) 오른쪽 부분에 항상 코드를 입력하게 됩니다. 책에 나오는 코드에서 예상 결과를 보여줄 때는 ##&gt; [1] 7 과 같이 주석문으로 처리되어 있습니다. 책에 나오는 내용 중 코드와 관련된 숫자, 문자 (변수), 데이터 객체 (data object), 함수 (function)등은 1, a, x, mean()과 같이 다른 글씨체로 표현됩니다. 함수인 경우 ()가 포함되어있습니다. 함수는 어떤 입력값 (input arguments)을 받아서 정의된 계산을 수행한 다음에 결과값 (출력값, return value)을 반환합니다. 예를 들어, seq(1,5)라는 함수는 ()안에 1과 5 두 개의 숫자를 입력값으로 받아서 \\(1\\)부터 \\(5\\)까지 \\(1\\) 간격으로 증가하는 숫자 집합 1 2 3 4 5를 결과값으로 반환합니다. =, &lt;-를 이용하여 a와 같은 특정 문자 (변수)에 함수의 결과값 (반환된 숫자 또는 데이터 객체)을 저장할 수도 있습니다. a = seq(1,5) a ## [1] 1 2 3 4 5 a 라는 문자 (변수, variable)를 콘솔창에 입력하고 엔터를 눌러서 실행한 후에, 저장된 데이터 객체 값을 확인할 수도 있지만, print() 함수를 이용할 수도 있습니다. a = seq(1,5) print(a) ## [1] 1 2 3 4 5 특정 변수에 숫자 또는 데이터 객체를 할당할 때에 = 대신에 &lt;-를 주로 사용합니다. a = 3라는 식에서 ‘좌항과 우항의 값이 같다’라는 의미보다는’a 변수에 3을 할당한다 또는 저장한다’의 의미로 사용하기 때문입니다. a &lt;- seq(1,5) print(a) ## [1] 1 2 3 4 5 RStudio 메뉴에서 File &gt;&gt; New File &gt;&gt; R Script를 클릭한 후, R 스크립트 편집창에 위의 소스코드를 입력하고 마우스나 키보드를 이용하여 입력한 코드를 전부 선택한 다음에 스크립트창 상단에 위치한 Run 버튼을 클릭하면 선택된 소스코드의 모든 내용이 실행되고 그 결과가 콘솔창에 나타납니다 (그림 1.1). R 스크립트 편집창에 소스코드를 입력한 후, 소스코드를 선택하는 과정을 생략하고 Run 버튼을 클릭하면 현재 마우스 커서가 있는 해당 라인의 코드만 실행되고, 마우스 커서는 다음 라인으로 자동으로 이동합니다. 마우스 커서를 소스코드의 첫 라인에 두고 Run 버튼 클릭을 반복하면 코드를 한 줄 씩 실행시킬 수 있습니다. 마우스나 키보드를 이용하여 스크립트 편집창의 소스코드를 전부 선택한 상태에서 Ctrl+Enter를 눌러도 Run 버튼을 클릭한 것과 동일한 결과가 나타납니다. R 스크립트 편집창에서 소스코드를 전부 선택하는 과정 없이 Run 버튼에서 오른쪽으로 두 번째 위치에 있는 ‘Source the active document’ 버튼을 클릭하여도 현재 스크립트 편집창의 전체 소스코드를 실행해 볼 수 있습니다. 그림 1.1: RStudio의 소스코드 편집창과 콘솔창 이 책에 나와 있는 소스코드들은 RStudio의 콘솔창에 직접 실행시킬 수도 있고, Notepad, Notes, Sublime Text 등과 같은 문서 편집기 (text editor)나 RStudio의 R 스크립트 편집창에 소스코드를 일부 수정한 후에 코드 한 줄 씩, 코드 일부만, 혹은 코드 전체를 실행해 볼 수 있습니다. 1.3.1 벡터 (vector) 변수 a에 저장된 데이터 객체의 자료 형태를 R에서는 벡터 (vector)라고 부릅니다. 벡터는 동일한 자료형의 값이 여러 개 연속되어 있는 1차원 자료 형태입니다. 위의 예에서는 다섯 개의 자연수 \\(1\\), \\(2\\), \\(3\\), \\(4\\), \\(5\\)가 a 라는 이름의 변수에 벡터 형태로 저장되어 있습니다. 아래의 소스코드와 같이 c() 함수에 입력값들을 ,로 구분하여 넣어 주어도 벡터가 생성되며, 벡터에는 여러 개의 값이 저장되어 있기 때문에, length()함수를 이용하여 벡터에 저장된 값의 개수를 알아볼 수도 있고, []기호를 이용하여 벡터를 이루는 각각의 값 (원소, element)에 접근할 수도 있습니다. typeof()함수를 이용하여 어떤 자료 형태인지 확인해볼 수도 있고, is.vector()함수를 이용하여 변수 a가 벡터형이 맞는지 아닌지 확인해볼 수도 있습니다. a &lt;- c(1,2,3,4,5) print(a) ## [1] 1 2 3 4 5 print(length(a)) ## [1] 5 print(a[1]) ## [1] 1 print(a[5]) ## [1] 5 print(typeof(a)) ## [1] &quot;integer&quot; print(is.vector(a)) ## [1] TRUE a 라는 문자를 변수라고 부르는 이유는 그 이름에 저장된 데이터 객체 값이 변할 수 있기 때문입니다. 변수는 저장 창고 역할을 하고 그 안에 저장되는 물건 (데이터 객체)은 사용자가 임으로 변경할 수 있습니다. c() 함수에 1:5와 같은 형태의 입력값도 가능하며 이는 \\(1\\)부터 \\(5\\)까지 연속된 정수로 이루어진 벡터를 생성해 줍니다. 그 자체로 벡터이기 때문에 굳이 c()함수가 없어도 벡터를 생성할 수 있습니다. a &lt;- seq(1,3) print(a) ## [1] 1 2 3 a &lt;- c(1,2,3) print(a) ## [1] 1 2 3 a &lt;- c(1:5) print(a) ## [1] 1 2 3 4 5 a &lt;- 1:5 print(a) ## [1] 1 2 3 4 5 벡터 자료를 생성하는 방법은 다양합니다. 숫자 뿐만 아니라 문자, 문자열도 벡터에 저장될 수 있습니다. 벡터를 저장하는 변수의 이름을 정할 때에는 그 변수에 담길 데이터 객체를 잘 표현해주면 좋습니다. 변수의 이름은 주로 영문자로 시작합니다. 변수의 이름을 숫자로 시작하거나 중간에 띄어쓰기하는 것은 불가능합니다. 변수의 값이 문자인 경우 var1 &lt;- 'a', var1 &lt;- &quot;a&quot;, var2 &lt;- '안녕', var2 &lt;- &quot;1학년&quot;과 같이 문자값 (문자열값)의 시작과 끝을 '', &quot;&quot;로 감싸서 표현합니다. 문자값 (문자열값)을 입력할 때 ''로 표현했어도, print()로 화면 출력 될 때에는 &quot;&quot;로 표현됩니다. ''로 입력된 문자값이 R에 데이터 객체의 값으로 저장될 때에는 &quot;&quot;로 변경되어 저장되기 때문입니다. 문자값에 '이 포함될 경우 &quot;aaa'bbb'ccc&quot; 또는 'aaa\\'bbb\\'ccc'로 표현할 수 있습니다. 문자값에 &quot;가 포함될 경우에는 'aaa&quot;bbb&quot;ccc' 또는 &quot;aaa\\&quot;bbb\\&quot;ccc&quot;로 표현할 수 있습니다. a1 &lt;- seq(1,3) #숫자형 벡터 a2 &lt;- seq(4,5) #숫자형 벡터 myIntegers&lt;- c(a1,a2) #숫자형 벡터 두 개를 합친 숫자형 벡터 print(myIntegers) ## [1] 1 2 3 4 5 myCharacters &lt;- c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;) #문자형 벡터, 문자는 &#39;a&#39; 또는 &quot;a&quot;로 표현 print(myCharacters) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; myWords &lt;- c(&quot;hello&quot;,&quot;middle&quot;,&#39;school&#39;) #문자형 벡터 print(myWords) ## [1] &quot;hello&quot; &quot;middle&quot; &quot;school&quot; myKorCharacters &lt;- c(&#39;가&#39;,&#39;나&#39;,&#39;다&#39;) #문자형 벡터 myKorCharacters ## [1] &quot;가&quot; &quot;나&quot; &quot;다&quot; myKorWords &lt;- c(&#39;안녕&#39;,&#39;중학교&#39;,&#39;1학년&#39;) #문자형 벡터 myKorWords ## [1] &quot;안녕&quot; &quot;중학교&quot; &quot;1학년&quot; myFlags &lt;- c(TRUE,TRUE,FALSE,TRUE) #논리형 벡터 myFlags ## [1] TRUE TRUE FALSE TRUE 콘솔에서 ls()함수를 이용하여 현재 사용 중인 데이터 객체를 저장하고 있는 문자(변수)들을 확인해 볼 수 있습니다. ls() ## [1] &quot;a&quot; sum() 또는 mean() 함수를 이용하여 a 라는 문자(변수)에 저장된 숫자 집합의 합, 평균 등도 구해볼 수 있습니다. sum(a) ## [1] 15 mean(a) ## [1] 3 위에서 살펴본 소스코드를 모아보면 아래와 같습니다. a = seq(1,5) #1부터 5까지 연속된 숫자형 벡터를 변수 a에 할당 print(a) #변수 a에 저장되어 있는 값들을 화면에 출력 print(length(a)) #변수 a에 저장되어 있는 값들의 개수를 화면에 출력 print(a[1]) #변수 a에 저장되어 있는 숫자형 벡터의 첫째 번째 값을 화면에 출력 print(a[5]) #변수 a에 저장되어 있는 숫자형 벡터의 다섯번째 값을 화면에 출력 print(typeof(a)) #변수 a에 저장되어 있는 데이터 객체의 자료형태를 화면에 출력 print(is.vector(a)) #a가 벡터이면 TRUE, 아니면 FALSE를 출력 sum(a) #a에 저장되어 있는 값들의 합 계산 mean(a) #a에 저장되어 있는 값들의 평 계산 print(c(&#39;안녕&#39;,&#39;중학교&#39;,&#39;1학년&#39;)) #문자형 벡터의 값들을 출력 print(c(TRUE,TRUE,FALSE,TRUE)) #논리형 벡터의 값들을 출력 1.3.2 데이터 프레임 (data frame, df, data.frame) 벡터와 함께 자료를 탐색/처리/분석하는데 가장 많이 쓰이는 데이터 구조가 데이터 프레임 (data frame, df, data.frame)입니다. 데이터 프레임은 \\(2\\)차원 테이블 형태인데 행 (로우, row)과 열 (컬럼, column, col)로 구분할 수 있습니다. 데이터 프레임의 행과 열, 생성 방법을 설명하기 위해서 우리나라에서는 트럼프 카드(trump card)라는 별칭으로 불리기도 하는 플레잉 카드 (playing card) 한 묶음 (한 벌, one deck)을 가지고 설명해 보겠습니다. 지금 우리 눈앞에 플레잉 카드 한 벌이 있고, 그중에서 다섯 장만 무작위 (random)로 뽑았더니 그 결과가 표 1.1과 같았다고 생각해 봅시다. 표 1.1: 다섯장의 플레잉 카드 정보 card_num suit color value 첫 번째 spade 검은색 9 두 번째 heart 빨간색 5 세 번째 spade 검은색 3 네 번째 club 검은색 1 다섯번째 club 검은색 7 위의 표는 \\(5\\)개의 행과 \\(4\\)개의 열로 이루어진 데이터 프레임인 cards_df를 표로 표현한 것입니다. 데이터 프레임의 각 열 (컬럼)은 \\(4\\)개의 벡터로 부터 생성됩니다. 각 컬럼 벡터는 다섯 장 카드의 일부 정보를 가지게 됩니다. 예를 들어, card_num, suit, color, value벡터들은 각각 카드 순서, 모양, 색상, 숫자 정보를 가집니다. 데이터 프레임에 담긴 데이터는 다양한 함수들 (nrow, ncol, dim, str 등)을 이용하여 탐색할 수 있습니다. cards_df &lt;- data.frame( card_num = c(&#39;첫 번째&#39;, &#39;두 번째&#39;, &#39;세 번째&#39;, &#39;네 번째&#39;, &#39;다섯번째&#39;), suit = c(&#39;spade&#39;, &#39;heart&#39;, &#39;spade&#39;, &#39;club&#39;, &#39;club&#39;), color = c(&#39;검은색&#39;, &#39;빨간색&#39;, &#39;검은색&#39;, &#39;검은색&#39;, &#39;검은색&#39;), value = c(9, 5, 3, 1, 7), stringsAsFactors=FALSE) #문자형 벡터의 데이터 타입을 factor로 인코딩 하지 않기 print(ncol(cards_df)) #열(컬럼) 개수 ## [1] 4 print(nrow(cards_df)) #행 개수 ## [1] 5 dim(cards_df) #행렬 정보 ## [1] 5 4 str(cards_df) #데이터 프레임의 구조 (structure) ## &#39;data.frame&#39;: 5 obs. of 4 variables: ## $ card_num: chr &quot;첫 번째&quot; &quot;두 번째&quot; &quot;세 번째&quot; &quot;네 번째&quot; ... ## $ suit : chr &quot;spade&quot; &quot;heart&quot; &quot;spade&quot; &quot;club&quot; ... ## $ color : chr &quot;검은색&quot; &quot;빨간색&quot; &quot;검은색&quot; &quot;검은색&quot; ... ## $ value : num 9 5 3 1 7 head(cards_df, 3) #처음 3행 정보 ## card_num suit color value ## 1 첫 번째 spade 검은색 9 ## 2 두 번째 heart 빨간색 5 ## 3 세 번째 spade 검은색 3 tail(cards_df, 3) #마지막 3행 정보 ## card_num suit color value ## 3 세 번째 spade 검은색 3 ## 4 네 번째 club 검은색 1 ## 5 다섯번째 club 검은색 7 cards_df[1,2] #1행 2열 정보, 첫 번째 카드의 모양 정보 ## [1] &quot;spade&quot; cards_df[1, ] #1행 정보, 1행의 모든 열 (컬럼) 정보 ## card_num suit color value ## 1 첫 번째 spade 검은색 9 cards_df[2:4, ] #2행부터 4행까지의 모든 열 (컬럼) 정보 ## card_num suit color value ## 2 두 번째 heart 빨간색 5 ## 3 세 번째 spade 검은색 3 ## 4 네 번째 club 검은색 1 cards_df[ ,4] #전체행의 4번째 열 (컬럼) 정보 ## [1] 9 5 3 1 7 cards_df[ ,&#39;value&#39;] #전체행의 4번째 열 (컬럼) 정보 ## [1] 9 5 3 1 7 cards_df$value #전체행의 value 벡터 열 (컬럼) 정보 ## [1] 9 5 3 1 7 cards_df[ ,c(2, 4)] #전체행의 2번쨰 열과 4번째 열 (컬럼) 정보 ## suit value ## 1 spade 9 ## 2 heart 5 ## 3 spade 3 ## 4 club 1 ## 5 club 7 플레잉 카드 데크 전체 카드는 \\(13 \\times 4 = 52\\)장 입니다. 위에서 배운 것을 바탕으로 스페이드 \\(13\\)장, 하트 \\(13\\)장, 다이아몬드 \\(13\\)장, 클럽 (클로버) \\(13\\)장 순서로 \\(52\\)개의 행을 가진 deck_df 데이터 프레임을 만들어 보겠습니다. 아래 소스코드의 face 벡터와 value 벡터는 각각 \\(13\\)개의 값을 가지는 반면, suit벡터는 \\(4\\)개의 값 (스페이드, 하트, 다이아몬드, 클럽)을 가집니다. color, rank, shape벡터들은 suit벡터에 저장된 스페이드, 하트, 다이아몬드, 클럽의 색상, 등급, 모양 특성을 표현한 것으로 각각 \\(4\\)개의 값을 가집니다. faceVec0 &lt;- c(&#39;ace&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;, &#39;five&#39;, &#39;six&#39;, &#39;seven&#39;, &#39;eight&#39;, &#39;nine&#39;, &#39;ten&#39;, &#39;jack&#39;, &#39;queen&#39;, &#39;king&#39;) valueVec0 &lt;- c(1:13) suitVec0 &lt;- c(&#39;spade&#39;, &#39;heart&#39;, &#39;diamond&#39;, &#39;club&#39;) #스페이드, 하트, 다이아몬드, 클럽 colorVec0 &lt;- c(&#39;black&#39;, &#39;red&#39;, &#39;red&#39;, &#39;black&#39;) #카드의 모양별 색상 rankVec0 &lt;- c(&#39;major&#39;, &#39;major&#39;, &#39;minor&#39;, &#39;minor&#39;) #카드의 모양별 등급 정보 shapeVec0 &lt;- c(&#39;pointed&#39;, &#39;rounded&#39;, &#39;pointed&#39;, &#39;rounded&#39;) #카드의 모양별 특성 정보 위의 벡터들을 모두 \\(52\\)개의 값을 가지는 벡터로 변환한 다음에 데이터 프레임을 생성할 수 있습니다. 데이터 프레임의 컬럼 벡터가 되는 value벡터와 suit벡터를 중심으로 생각하면, 두 컬럼 벡터 모두 스페이드 \\(13\\)장, 하트 \\(13\\)장, 다이아몬드 \\(13\\)장, 클럽 \\(13\\)장 순서로 \\(52\\)개 값을 가진 벡터를 생성하게 됩니다. value벡터는 \\(1\\)부터 \\(13\\)까지 \\(13\\)장의 카드가 스페이드, 하트, 다이아몬드, 클럽 순으로 \\(4\\)번 반복하는 값을 가지기 위하여 \\(13\\)개의 값을 가지는 벡터를 \\(4\\)번 반복하여야 합니다. c()를 이용하여 \\(4\\)개의 벡터들을 연결하는 하나의 벡터를 생성할 수도 있고 ( c(1:13, 1:13, 1:13, 1:13)), rep()함수를 이용하여 특정 값 (벡터값)을 반복 (repeat)할 수도 있습니다 (rep(1:13, times = 4) 또는 rep(1:13, 4)). rep(x=1:13, times=4)와 같이 입력값 이름 = 입력값의 형식으로 함수의 입력값을 줄 수도 있고, 입력값이 순서대로 입력될 경우에는 rep(1:13, 4)와 같이 입력값의 이름이 생략될 수 있습니다. 입력값의 이름이 생략된 경우, 입력값의 순서가 달라 지면 (rep(4, 1:13)) 원하는 결과를 얻을 수 없습니다. suit벡터의 경우, 스페이드가 \\(13\\)개, 하트가 \\(§3\\)개, 다이아몬드가 \\(13\\)개, 클럽이 \\(13\\)개 이므로 스페이드, 하트, 다이아몬드, 클럽을 각 각 13번 씩 반복하거나 (c(rep('spade',13), rep('heart',13), rep('diamond',13), rep('club',13))), 스페이드, 하트, 다이아몬드, 클럽을 값으로 가지는 벡터를 생성하고 벡터값의 첫 번째 값부터 각 값을 (each) \\(13\\)번 씩 반복할 수 있습니다 (rep(c('spade','heart','diamond','club'),each=13)). 아래와 소스코드로 \\(6\\)개의 컬럼벡터가 모두 \\(52\\)개의 값을 가지도록 설정할 수 있습니다. faceVec &lt;- rep(faceVec0, times = 4) #ace부터 king까지 4번 반복 print(faceVec) ## [1] &quot;ace&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; &quot;six&quot; ## [7] &quot;seven&quot; &quot;eight&quot; &quot;nine&quot; &quot;ten&quot; &quot;jack&quot; &quot;queen&quot; ## [13] &quot;king&quot; &quot;ace&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; ## [19] &quot;six&quot; &quot;seven&quot; &quot;eight&quot; &quot;nine&quot; &quot;ten&quot; &quot;jack&quot; ## [25] &quot;queen&quot; &quot;king&quot; &quot;ace&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; ## [31] &quot;five&quot; &quot;six&quot; &quot;seven&quot; &quot;eight&quot; &quot;nine&quot; &quot;ten&quot; ## [37] &quot;jack&quot; &quot;queen&quot; &quot;king&quot; &quot;ace&quot; &quot;two&quot; &quot;three&quot; ## [43] &quot;four&quot; &quot;five&quot; &quot;six&quot; &quot;seven&quot; &quot;eight&quot; &quot;nine&quot; ## [49] &quot;ten&quot; &quot;jack&quot; &quot;queen&quot; &quot;king&quot; print(length(faceVec)) ## [1] 52 valueVec &lt;-rep(valueVec0, times = 4) #1부터 13까지 4번 반복 print(valueVec) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 ## [18] 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 ## [35] 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 ## [52] 13 print(length(valueVec)) ## [1] 52 suitVec &lt;- rep(suitVec0, each = 13) #스페이드 13번 반복, 그 다음 모양 13번 반복... print(suitVec) ## [1] &quot;spade&quot; &quot;spade&quot; &quot;spade&quot; &quot;spade&quot; &quot;spade&quot; ## [6] &quot;spade&quot; &quot;spade&quot; &quot;spade&quot; &quot;spade&quot; &quot;spade&quot; ## [11] &quot;spade&quot; &quot;spade&quot; &quot;spade&quot; &quot;heart&quot; &quot;heart&quot; ## [16] &quot;heart&quot; &quot;heart&quot; &quot;heart&quot; &quot;heart&quot; &quot;heart&quot; ## [21] &quot;heart&quot; &quot;heart&quot; &quot;heart&quot; &quot;heart&quot; &quot;heart&quot; ## [26] &quot;heart&quot; &quot;diamond&quot; &quot;diamond&quot; &quot;diamond&quot; &quot;diamond&quot; ## [31] &quot;diamond&quot; &quot;diamond&quot; &quot;diamond&quot; &quot;diamond&quot; &quot;diamond&quot; ## [36] &quot;diamond&quot; &quot;diamond&quot; &quot;diamond&quot; &quot;diamond&quot; &quot;club&quot; ## [41] &quot;club&quot; &quot;club&quot; &quot;club&quot; &quot;club&quot; &quot;club&quot; ## [46] &quot;club&quot; &quot;club&quot; &quot;club&quot; &quot;club&quot; &quot;club&quot; ## [51] &quot;club&quot; &quot;club&quot; print(length(suitVec)) ## [1] 52 colorVec &lt;- rep(colorVec0, each = 13) #스페이드 색상 13번 반복, 그 다음 색상 13번 반복... print(colorVec) ## [1] &quot;black&quot; &quot;black&quot; &quot;black&quot; &quot;black&quot; &quot;black&quot; &quot;black&quot; ## [7] &quot;black&quot; &quot;black&quot; &quot;black&quot; &quot;black&quot; &quot;black&quot; &quot;black&quot; ## [13] &quot;black&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; ## [19] &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; ## [25] &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; ## [31] &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; ## [37] &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;black&quot; &quot;black&quot; &quot;black&quot; ## [43] &quot;black&quot; &quot;black&quot; &quot;black&quot; &quot;black&quot; &quot;black&quot; &quot;black&quot; ## [49] &quot;black&quot; &quot;black&quot; &quot;black&quot; &quot;black&quot; print(length(colorVec)) ## [1] 52 rankVec &lt;- rep(rankVec0, each = 13) #스페이드 등급 13번 반복, 그 다음 등급 13번 반복... print(rankVec) ## [1] &quot;major&quot; &quot;major&quot; &quot;major&quot; &quot;major&quot; &quot;major&quot; &quot;major&quot; ## [7] &quot;major&quot; &quot;major&quot; &quot;major&quot; &quot;major&quot; &quot;major&quot; &quot;major&quot; ## [13] &quot;major&quot; &quot;major&quot; &quot;major&quot; &quot;major&quot; &quot;major&quot; &quot;major&quot; ## [19] &quot;major&quot; &quot;major&quot; &quot;major&quot; &quot;major&quot; &quot;major&quot; &quot;major&quot; ## [25] &quot;major&quot; &quot;major&quot; &quot;minor&quot; &quot;minor&quot; &quot;minor&quot; &quot;minor&quot; ## [31] &quot;minor&quot; &quot;minor&quot; &quot;minor&quot; &quot;minor&quot; &quot;minor&quot; &quot;minor&quot; ## [37] &quot;minor&quot; &quot;minor&quot; &quot;minor&quot; &quot;minor&quot; &quot;minor&quot; &quot;minor&quot; ## [43] &quot;minor&quot; &quot;minor&quot; &quot;minor&quot; &quot;minor&quot; &quot;minor&quot; &quot;minor&quot; ## [49] &quot;minor&quot; &quot;minor&quot; &quot;minor&quot; &quot;minor&quot; print(length(rankVec)) ## [1] 52 shapeVec &lt;- rep(shapeVec0, each = 13) #스페이드 모양특성 13번 반복, 그 다음 모양특성 13번 반복... print(shapeVec) ## [1] &quot;pointed&quot; &quot;pointed&quot; &quot;pointed&quot; &quot;pointed&quot; &quot;pointed&quot; ## [6] &quot;pointed&quot; &quot;pointed&quot; &quot;pointed&quot; &quot;pointed&quot; &quot;pointed&quot; ## [11] &quot;pointed&quot; &quot;pointed&quot; &quot;pointed&quot; &quot;rounded&quot; &quot;rounded&quot; ## [16] &quot;rounded&quot; &quot;rounded&quot; &quot;rounded&quot; &quot;rounded&quot; &quot;rounded&quot; ## [21] &quot;rounded&quot; &quot;rounded&quot; &quot;rounded&quot; &quot;rounded&quot; &quot;rounded&quot; ## [26] &quot;rounded&quot; &quot;pointed&quot; &quot;pointed&quot; &quot;pointed&quot; &quot;pointed&quot; ## [31] &quot;pointed&quot; &quot;pointed&quot; &quot;pointed&quot; &quot;pointed&quot; &quot;pointed&quot; ## [36] &quot;pointed&quot; &quot;pointed&quot; &quot;pointed&quot; &quot;pointed&quot; &quot;rounded&quot; ## [41] &quot;rounded&quot; &quot;rounded&quot; &quot;rounded&quot; &quot;rounded&quot; &quot;rounded&quot; ## [46] &quot;rounded&quot; &quot;rounded&quot; &quot;rounded&quot; &quot;rounded&quot; &quot;rounded&quot; ## [51] &quot;rounded&quot; &quot;rounded&quot; print(length(shapeVec)) ## [1] 52 이제 초기값 벡터 (Vec0)로 부터 6개의 벡터 (Vec)가 모두 \\(52\\)개의 값을 가지도록 설정되었습니다. 이 \\(6\\)개의 벡터들을 컬럼값으로 가지는 데이터 프레임 deck_df를 생성해 보겠습니다. 원래 플레잉 카드 데크에는 두 장의 조커 카드가 더 있지만 이번 예제에서는 조커 카드는 제외하도록 하겠습니다. deck_df &lt;- data.frame( face = faceVec, value = valueVec, suit = suitVec, color = colorVec, rank = rankVec, shape = shapeVec) 생성한 데이터 프레임 또는 다른 데이터 객체를 여러분 컴퓨터 작업 폴더에 파일로 저장하거나 읽어올 수 있습니다. getwd() #현재 작업 디렉토리 (working directory, wd) 확인 #setwd(&quot;/my/rmath01&quot;) #원하는 폴더를 작업 디렉토리로 설정하거나, #RStudio 메뉴에서 Tools &gt;&gt; Global Options… 클릭한 후, #Code &gt;&gt; Default working directory &gt;&gt; Browse… 원하는 폴더를 작업 디렉토리 (wd)로 설정 saveRDS(deck_df, file = &quot;deck_df.RDS&quot;) deck_df &lt;- readRDS(&quot;deck_df.RDS&quot;) 코드를 실행하기 전에 어떤 값이 출력 될지 미리 생각해보는 것이 중요합니다. 행과 열 정보가 무언인지 미리 생각해보고 아래의 소스코드를 실행해봅니다. dim(deck_df) nrow(deck_df) ncol(deck_df) 문자형 벡터 컬럼들의 속성 정보에 못 보던 factor, levels 같은 용어와 값들이 있습니다. 6개의 초기값 (Vec0) 벡터들이 가지는 값들 중 중복되는 값을 제거하고 유일하게 남는 (unique) 구별된 (distinct) 값의 개수를 생각해봅니다. color 컬럼의 경우 검은색 아니면 빨간색 2가지 값 중 하나를 가집니다 (\\(2\\) levels, black을 \\(1\\)로 표현, red를 \\(2\\)로 표현). 현재는 factor, levels에 대한 개념은 어렴풋이 알아도 충분합니다. str(deck_df) summary(deck_df) \\(52\\)장의 카드 중 위에 위치한 몇 장의 카드 정보와 밑에 위치한 카드 정보를 확인합니다. 52개의 벡터를 만들었을 때 모양 (suit) 순서를 생각해보면서 출력 될 값의 value 컬럼값과 suit 컬럼값을 미리 예상해보고 아래의 소스코드를 실행합니다. head(deck_df) tail(deck_df) 예상했던 값과 일치합니까? 일치하지 않았다면 예상한 값이 왜 틀렸는지 알았습니까? 미리 예상값 (기대값)을 가지고 데이터를 확인하는 과정은 정말 중요한 작업입니다. 데이터를 처리하면서 기대값 미리 예상하기 데이터값 확인하기 기대값과 데이터값이 불일치하는 경우 원인 파악하기 기대값 (예상값)이 잘못된 경우 기대값이 잘못된 이유 깨닫기 (두뇌 튜닝) 데이터값이 이상한 경우 데이터를 좀 더 탐색하고 분석 (데이터 탐색 분석)하여 오류 수정 또는 제거하기 데이터 자체가 잘못되었다고 판단될 경우 새로운 데이터 소스 파악하고 얻기 문제가 없는 경우에도 다른 소스의 데이터를 구할 수 있으면 다시 한번 비교 확인 (더블체크) 위의 \\(5\\)장의 카드 데이터 프레임 cards_df에서 시작해서 이제 \\(52\\)장 전부를 가진 플레잉 카드 데크 데이터 프레임 deck_df을 생성했습니다. 이제 \\(52\\)장의 카드 중 임의로 (무작위로, randomly) 카드 \\(7\\)장을 뽑아보겠습니다. 모집단 (관심의 대상이 되는 전체 그룹, population)에서 표본(분석을 위해 추출한 부분 집합, 샘플, sample)을 추출하는 과정입니다. nrow(deck_df) ## [1] 52 #랜덤으로 값을 가져오기 위한 시드(seed) 값을 1000으로 설정됨 (시드값을 설정하지 않으면 랜덤으로 자동 설정됨) set.seed(1000) rowNumOfCardSamples &lt;- sample(nrow(deck_df), 7) #데이터프레임에서 7개의 행번호를 랜덤으로 추출함 rowNumOfCardSamples ## [1] 48 4 43 22 24 29 35 cardSamples &lt;- deck_df[rowNumOfCardSamples, ] cardSamples ## face value suit color rank shape ## 48 nine 9 club black minor rounded ## 4 four 4 spade black major pointed ## 43 four 4 club black minor rounded ## 22 nine 9 heart red major rounded ## 24 jack 11 heart red major rounded ## 29 three 3 diamond red minor pointed ## 35 nine 9 diamond red minor pointed # -c(): 특정 값들만 제외, 이미 뽑은 카드 7장을 데크에서 제외 deck_df &lt;- deck_df[-c(rowNumOfCardSamples), ] nrow(deck_df) ## [1] 45 summary(deck_df) ## face value suit color ## ace : 4 Min. : 1 club :11 black:23 ## eight : 4 1st Qu.: 4 diamond:11 red :22 ## five : 4 Median : 7 heart :11 ## king : 4 Mean : 7 spade :12 ## queen : 4 3rd Qu.:10 ## seven : 4 Max. :13 ## (Other):21 ## rank shape ## major:23 pointed:23 ## minor:22 rounded:22 ## ## ## ## ## 이번 장에서는 아주 기본적인 R 소스코드 작성법을 배웠으며 중요한 개념인 벡터와 데이터 프레임에 대해서도 살펴보았습니다. 이제 앞으로 나아갈 시간입니다. 중학교 수학 \\(1\\)학년 교과 과정에 맞추어서 차근 차근 R을 활용해서 수학적 소양 (수학적 이해 능력, math literacy, numeracy)과 데이터 이해 능력 (데이터 활용 능력, data literacy)을 동시에 높여 나가봅시다. 교과 과정을 습득해 나가는 방법은 다양합니다. 효율적인 학습 방법을 추구할 수도 있고 창의적인 학습 방법을 추구할 수도 있습니다. 반복 적인 학습을 통해 깊이를 더 해 가는 방법도 있습니다. 이 책에서 시도하는 방법은 조금 엉뚱해 보일 수 있습니다. 하지만, 여러분의 머릿속에 저장되어 있는 수학적인 개념 (dots)과 새로운 데이터 개념 (new dots)을 연결해 가는 (connecting dots) 과정 속에서 여러분이 세계를 바라보는 시야가 확장되길 바랍니다. 서론이 길었습니다. 이제 2장 수와 연산에 대하여 본격적으로 알아봅시다. "],
["number-calc.html", "2 수와 연산 2.1 소인수분해 (prime factorization) 2.2 정수와 유리수", " 2 수와 연산 정수 (integer)와 유리수 (rational number)의 뜻에 대하여 살펴보고 정수와 유리수의 대소관계 및 연산에 대하여 알아봅니다. RStudio가 열려 있지 않으면 RStudio를 실행하고 메뉴에서 File &gt;&gt; Open Project…를 클릭하여 이전에 저장한 R 프로젝트 파일인 rmath01.Rproj을 찾아서 선택하고 Open 버튼을 클릭하여 이전에 작업하던 프로젝트 환경을 로딩합니다. 파일탐색기나 파인더에서 rmath01.Rproj 파일을 찾아서 더블 클릭하여도 RStudio가 실행되면서 작업하던 프로젝트 환경이 로딩됩니다. 프로젝트 환경이 로딩된 후에 RStudio 콘솔창에 getwd()를 실행하여 작업 환경이 제대로 로딩되었는지 확인합니다. RStudio 환경이 잘 로딩되었으면, 이제 본격적으로 시작해 봅시다. 2.1 소인수분해 (prime factorization) \\(0\\)보다 큰 정수인 자연수 (natural number)를 소수 (prime number)와 합성수 (composite number)로 구분해보고, 합성수를 소수들의 곱형태로 분해하는 방법에 대해 알아봅니다. 2.1.1 합성수의 소인수분해 \\(1\\)보다 큰 자연수 중 \\(1\\)과 그 자신 만을 약수로 가지는 수를 소수라고 하고, 소수가 아닌 자연수를 합성수라고 합니다. 합성수를 소수들의 곱으로 분해하는 과정을 소인수분해라고 합니다. 소인수 (prime factor)란 소수 (prime number) 이면서 인수 (factor)인 수를 말합니다. 인수는 약수 (divisor) 와 거의 동일한 개념이라고 이해해도 무방합니다. 그림 2.1은 \\(1\\)과 그 자신만을 약수로 가지는 소수와 소인수의 곱으로 표현 가능한 합성수의 예를 보여줍니다. \\(2\\), \\(3\\), \\(5\\), \\(7\\), \\(11\\)은 \\(1\\)과 그 자신 만을 약수로 가지는 소수이고, \\(4\\) (\\(2 \\times 2\\)), \\(6\\) (\\(2 \\times 3\\)), \\(8\\) (\\(2 \\times 4 = 2 \\times 2 \\times 2\\) ), \\(9\\) (\\(3 \\times 3\\)), \\(10\\) (\\(2 \\times 5\\)), \\(12\\) (\\(3 \\times 4 = 3 \\times 2 \\times 2\\))는 소인수의 곱으로 표현 가능한 합성수입니다. 그림 2.1: 소수 (왼쪽 파란색)와 합성수 (오른쪽 빨간색) (출처 https://en.wikipedia.org/wiki/Prime_number) 앞에 서 언급한 것처럼 다양한 분야를 아우르는 R 사용자 커뮤니티가 존재하고 그들에 의해 다양한 R 패키지가 배포되고 있으며 원하는 패키지를 다운로드 받아 설치하면, 그 패키지에 포함된 함수, 데이터, 분석 방법론을 사용할 수 있습니다. gmp 팩키지의 factorize() 함수를 사용하면 자연수에 대한 소인수분해를 수행할 수 있습니다. #install.packages(&quot;gmp&quot;) #gmp 패키지 설치 gmp::factorize(24) ## Big Integer (&#39;bigz&#39;) object of length 4: ## [1] 2 2 2 3 위의 소스코드를 실행했을 때 Error in loadNamespace(name) : there is no package called ‘gmp’와 같은 에러 메시지가 나온다면, gmp 패키지가 설치되어 있지 않기 때문이므로 install.packages(&quot;gmp&quot;)를 콘솔에 입력하고 실행하여 패키지를 설치해 줍니다. RStudio의 메뉴를 활용할 수도 있습니다 (메뉴에서 Tools &gt;&gt; Install Packages…를 클릭한 후, 패키지 설치창에서 두 번째 에디트박스에 gmp라고 입력하고 Install 버튼 클릭). library() 함수를 이용하여 설치되어 있는 패키지를 로딩하면 해당 패키지의 함수를 호출할 때 ::없이도 편하게 사용할 수 있습니다. #install.packages(&quot;gmp&quot;) #gmp 패키지 설치 library(gmp) #gmp 패키지 로딩 factorize(24) #gmp 패키지에서 제공하는 factorize() 함수 사용 합성수 \\(24\\)는 \\(2 \\times 2 \\times 2 \\times 3\\)으로 분해할 수 있으며 \\(2^3 \\times 3\\)으로 표현할 수 있습니다. \\(2^2\\) (\\(2\\)의 제곱), \\(2^3\\) (\\(2\\)의 세제곱), \\(2^4\\) (\\(2\\)의 네제곱), \\(2^5\\) (\\(2\\)의 다섯제곱), …을 통틀어 \\(2\\)의 거듭제곱이라 합니다. \\(2^3\\) (\\(2\\)의 세제곱)에서 밑 (base number)은 \\(2\\), 지수 (exponent, index)는 \\(3\\)이라고 읽습니다. 자연수는 아래와 같이 소인수 (또는 소인수의 거듭제곱)의 곱 형태로 분해될 수 있습니다. \\[23 = {23}^{1}\\] \\[24 = {2}^{3} \\times {3}^{1}\\] \\[252 = {2}^{2} \\times {3}^{2} \\times {7}^{1}\\] 소수 \\(23\\)은 \\({23}^{1}\\)의 형태로, 합성수 \\(24\\)는 \\({2}^{3} \\times {3}^{1}\\)의 형태로, 합성수 \\(252\\)는 \\({2}^{2} \\times {3}^{2} \\times {7}^{1}\\)의 형태로 분해됩니다. 2.1.2 에라토스테네스의 체 우리보다 \\(2200\\)년이나 앞서서 소수에 대해 고민했던 에라토스테네스 (Eratosthenes, B.C. 275 ~ B.C. 194?)의 소수 탐색법인 ’에라토스테네스의 체’에 대해 알아봅시다. 이 방법은 \\(2200\\)년이 지났음에도 여전히 정확도 측면에서 소수를 찾는 가장 확실한 방법으로 남아있습니다. 먼저 새로운 개념 세 가지 연산(%in%, !, if() {} else {})에 대하여 살펴보고 ‘에라토스테네스의 체’ 로직을 구현하는 소스코드를 작성해 보도록 하겠습니다. %in%연산자 (operator)는 1 %in% c(1,2,3)과 같은 형식으로 사용되며 연산자 앞의 값이 뒤의 벡터값에 포함되는지 여부를 TRUE/FALSE로 반환합니다. \\(1\\)은 \\(1,2,3\\)에 포함되므로 1 %in% c(1,2,3)의 연산 결과는 TRUE가 됩니다. c(1,2,3) %in% c(3,4)와 같이 앞의 값이 벡터인 경우, 앞의 벡터에 포함되는 요소 하나 하나의 결과를 벡터 형태로 반환합니다. \\(1\\)과 \\(2\\)는 \\(3,4\\)에 포함되지 않고 \\(3\\)은 \\(3,4\\)에 포함되므로 연산 결과는 c(FALSE,FALSE,TRUE)가 됩니다. !논리 연산자 (logical operator)는 !TRUE, !c(TRUE, FALSE)와 같은 형식으로 사용되며 연산자 뒤의 값 x와 반대되는 결과 (not x)를 TRUE/FALSE로 반환합니다. !TRUE의 연산결과는 FALSE가 되며 !c(TRUE, FALSE)의 연산 결과는 c(FALSE, TRUE)가 됩니다. if() {} else {}조건문 (if/else statement)은 if 다음에 오는 ()안의 조건을 만족할 경우에만 {}안의 소스코드를 수행하게 하는 연산문입니다. 조건에 만족하지 않을 경우에 다른 소스코드를 수행해야 하는 경우 if()문과 else문을 한 쌍으로 사용합니다. if(1+2 &gt; 2) { print (&quot;참&quot;) } else { print (&quot;거짓&quot;) }와 같은 형식으로 사용되며 if 다음에 오는 ()안의 조건인 1+2 &gt; 2가 TRUE를 반환하므로 if()다음에 오는 {}안의 소스코드인 print (&quot;참&quot;)부분만 실행이 되고 else다음에 오는 {}안의 소스코드는 실행되지 않습니다. if(1+2 &gt; 2) x = 1 else x = 2와 같이 실행되는 소스코드가 한 줄인 경우 {}없이 사용할 수 있습니다. 조건에 따라 변수에 값을 다르게 할당하는 경우, ifelse(조건, 참인경우, 거짓인경우)문을 활용하여 x &lt;- ifelse(1+2 &gt; 2, 1, 2)와 같이 사용할 수 있습니다. 위의 세가지 연산을 이용하여 \\(1\\), \\(2\\), \\(3\\), \\(4\\), \\(5\\)의 숫자로 이루어진 N벡터에서 \\(2\\), \\(3\\), \\(4\\)를 제거하고 \\(1\\)과 \\(5\\)만 남기는 로직을 만들어 봅시다. 파일탐색기나 파인더에서 프로젝트를 저장한 폴더를 찾아가서 rmath01.Rproj 파일을 더블클릭하여 RStudio를 실행하고 콘솔창에 아래의 소스코드를 한 줄 한 줄 입력하고 실행 결과를 확인해 보세요. #%in% 예제 1 %in% c(1,2,3) #1이 1,2,3 벡터 (집합) 안에 존재하므로 TRUE값 반환 5 %in% c(1,2,3) #5는 1,2,3 벡터 (집합) 안에 없으므로 FALSE값 반환 c(1,2) %in% c(1,2,3) #1은 TRUE, 2도 TRUE, 반환값은 c(TRUE, TRUE) c(1,2,3,4,5) %in% c(1,2,3) #1,2,3은 TRUE, 4,5는 FALSE #! 예제 !c(TRUE, TRUE, FALSE) #c(!TRUE,!TRUE,!FALSE)이므로 c(FALSE,FALSE,TRUE) !c(1,2,3,4,5) %in% c(1,2,3) #!1,!2,!3은 FALSE, !4, !5는 TRUE #if문 예제 if(1+2 != 4) { #1+2의 값과 4이 논리적으로 동일한지 않으면 {} 내용 실행 print (&quot;not same&quot;) } #if-else문 예제 if (1+2 == 3) { print(&#39;same&#39;) #1+2의 값과 3이 논리적으로 비교, 동일하면 print(&#39;same&#39;) } else { print(&#39;different&#39;) #동일하지 않으면 print(&#39;different&#39;) } x &lt;- 1:30 #1부터 30까지의 숫자를 가지는 벡터 x 생성 x2 &lt;- x[!x %in% 3:10] #x 벡터값 중 3부터 10까지의 값을 제외한 후 x2 벡터에 저장 x2 #x2 벡터값 확인 x &lt;- c(1:5) #벡터 x의 값을 1부터 5까지의 숫자값으로 변경 (갱신, 업데이트) length(x) #x 벡터의 길이 (벡터안에 저장된 값의 개수) 확인 #1,2,3,4,5 다섯 숫자 중 다섯 번째 값만 가져옴 (아래줄 소스코드에 대한 설명) x[5] #1,2,3,4,5 다섯 숫자 중 첫 번째와 다섯 번째 값만 가져옴 (아래줄 소스코드에 대한 설명) x[c(1, 5)] x[c(TRUE, FALSE, FALSE, FALSE, TRUE)] #제거하고 싶은 숫자 벡터 생성 y &lt;- c(2,3,4) #1,2,3,4,5 숫자 각각이 2,3,4 에 포함 (%in%)되는지 여부를 TRUE, FALSE로 나타냄 x %in% y #1,2,3,4,5 숫자 각각이 2,3,4 에 포함되지 않는지 (!) 여부를 TRUE, FALSE로 나타냄 !(x %in% y) #!x %in% y의 결과는 첫 번째와 다섯 번째 값만 TRUE를 가지므로 해당 위치에 있는 값만으로 x2 벡터 생성 x2 &lt;- x[!(x %in% y)] x2 위의 로직을 바탕으로 \\(2\\)~\\(10\\) 사이의 자연수 벡터에서 소수만 남기는 로직을 만들어 보겠습니다. natural &lt;- c(2:10) length(natural) #제거하고 싶은 합성수 벡터 생성 composite &lt;- c(4, 6, 8, 9, 10) #2~10 숫자 각각이 제거하고 싶은 숫자에 포함 (%in%)되는지 여부를 TRUE, FALSE로 나타냄 natural %in% composite #2~10 숫자 각각이 제거하고 싶지 않은 (!) 숫자인지 여부를 TRUE, FALSE로 나타냄 !natural %in% composite #!natural %in% composite의 결과는 소수 값인 경우만 TRUE를 가지므로 #해당 위치에 있는 값만으로 소수 벡터 생성 prime &lt;- natural[!natural %in% composite] prime 위의 소스코드들이 어렵게 느껴진다면 콘솔에서 코드 한 줄 한 줄 다시 실행해 보고 코드의 설명도 다시 읽어보세요. %in%과 !를 활용한 자신만의 문제를 만들고 소스코드를 작성해서 풀어보세요. 우리는 문제집 등을 통하여 남들이 만들어 놓은 문제를 풀어내는데 익숙하지만, 어떤 개념을 이해하고 그 개념을 특정 상황에 대입 시켜 스스로 문제를 만들어 내고 풀어본다면 그 개념을 더욱더 깊이 이해할 수 있게 됩니다. 어떤 개념을 이해하고 실제 생활에 접목 시키거나 실제 생활에서 그 개념의 응용 사례를 찾아낼 수 있는 안목을 기르는 것은 무엇보다 중요합니다. 우리는 일상 생활에서 어떤 목록에서 특정 요소만 제외해야 하는 상황을 많이 접하고 있기 때문에 위의 소스코드에서 소개된 개념을 어렵게 생각하지 말고 자신의 경험과 연결 지어서 쉽게 이해해보려고 노력한다면 어느 순간 이해되기 시작할 겁니다. 이해 안가는 개념을 마주했을 때 시간이 조금 더 걸리더라도 깊이 생각해보는 경험은 정말 중요합니다 (깊이 생각하기). 혹시 지금 이 순간, 그 경험을 하고 있다면 포기하지 말고 여러 각도에서 여러가지 상황을 떠올려 가면서 이해하려고 노력해보세요. 물론 문제를 마주하고 해법을 생각할 때 하나의 해법에만 집착할 필요는 없습니다. 우리가 하는 행동과 생각들은 이미 누군가 이미 경험했던 일인 경우가 대부분입니다. 이미 누군가가 조금 더 쉽고 간편한 해법을 제시했는지 확인할 필요가 있습니다 (넓게 생각하기). 위에서 살펴본 연산자 하나 하나에 매달리기 보다는 우리가 얻고자 했던 빅 픽처를 검색어로 만들어서 구글링해봅시다 (r two vectors difference). 구글링 결과 가장 첫 줄에 ’Difference between two vectors in R - Stack Overflow’라는 링크가 눈에 띕니다. 클릭해서 들어가 보니, 스택 오버플로우 (https://stackoverflow.com)에 누군가 이미 질문을 했고 또 다른 누군가 이미 답을 올려놓았습니다. 문서에서 언급된 setdiff()를 사용해서 위에서 살펴본 소스코드를 좀 더 쉽고 간편하게 변경해 보겠습니다. n &lt;- c(2:10) #2~10 사이의 자연수 벡터 생성 composite &lt;- c(4, 6, 8, 9, 10) #제거하고 싶은 숫자 벡터 생성 n &lt;- setdiff(n, composite) #n 벡터에서 composite 벡터값 제거 (n 집합 - composite 집합) n #n 벡터 값 확인 ## [1] 2 3 5 7 코드가 훨씬 간결해 졌고 이해하기도 쉬어졌습니다. 벡터는 여러 개의 값이 연속되어 저장되어 있는 \\(1\\)차원 자료 형태이기 때문에 기본적으로 값들의 집합입니다. 따라서 위와 같이 두 벡터들 간의 연산 (집합 연산, set operation)이 가능합니다 (그림 2.2). 그림 2.2: 두 집합간 차이 (차집합) (출처 https://https://en.wikipedia.org/wiki/Set_(mathematics)#Basic_operations) 위의 그림은 두 집합 간의 차이를 나타낸 것으로 왼쪽 집합 중 오른쪽 집합과 중복되는 부분을 제외하고 남은 부분의 집합입니다. 이를 차집합이라고 하고, R에서는 setdiff함수를 이용하여 차집합을 구할 수 있습니다. 특정 함수에 대해 좀 더 자세히 알고 싶은 경우 함수 이름 앞에 ?를 붙여서 콘솔창에 입력하면 해당 함수의 도움말을 볼 수 있습니다 . 콘솔창에서 ?setdiff를 입력하고 실행하면 도움말창에 ‘Set Operations in package base’ 링크가 나타납니다. 링크를 클릭해서 R에서 기본으로 제공하는 패키지 안에 존재하는 집합연산 함수들을 살펴볼 수 있습니다 (다시 깊이 생각하기). R 기본 패키지는 기본적인 집합 연산을 위하여 union(x, y), intersect(x, y), setdiff(x, y), setequal(x, y)함수들 뿐만 아니라 is.element(el, set)함수도 제공합니다. is.element()함수를 이용하면 위에서 사용했었던 %in%연산자와 동일한 결과를 얻을 수 있습니다. n &lt;- c(2:10) #2~10 사이의 자연수 벡터 생성 composite &lt;- c(4, 6, 8, 9, 10) #제거하고 싶은 숫자 벡터 생성 2 %in% composite is.element(2, composite) n %in% composite is.element(n, composite) 이제 본격적으로 ‘에라토스테네스의 체’ 로직을 다섯 단계로 나누어 구현해 보겠습니다. \\(2\\)에서 \\(100\\)사이의 자연수 벡터를 생성합니다. x &lt;- 100 n &lt;- 2:x length(n) ## [1] 99 \\(2\\)에서 \\(100\\)의 자연수 벡터에서 첫 번째 소수인 \\(2\\)를 남기고 \\(2\\)의 배수 (multiple)를 모두 제거합니다. 소스코드에서는 \\(p \\times 2\\)와 같은 곱셈 표현을 p * 2와 같이 합니다. 아래 소스코드의 #### '에라토스테네스의 체' 로직 시작 ####과 #### '에라토스테네스의 체' 로직 종료 ####사이에 있는 \\(4\\)줄 짜리 코드가 로직의 핵심 부분인데, 이 부분은 이해하기 어려울 수 있습니다. 아래의 각 단계마다 반복되는 ‘에라토스테네스의 체’ 로직 코드 부분은 머리를 싸매고 이해하려 하지 말고 그냥 쿨하게 복사해서 붙여 넣으세요. 나중에 이해되는 순간이 올 겁니다. i &lt;- 1 p &lt;- n[i] #### &#39;에라토스테네스의 체&#39; 로직 시작 ################ if (p*2 &lt;= x) { #if (현재 소수 p의 배수가 입력값 자연수 x보다 작거나 같으면) composite &lt;- seq(p*2, x, p) # { 소수가 아닌 숫자 벡터 생성 } } else composite &lt;- c() #else (아니면) { 배수 벡터 값을 빈값 (NULL)으로 설정 } n &lt;- setdiff(n, composite) #소수가 아닌 숫자 벡터를 제외한 자연수 벡터 #### &#39;에라토스테네스의 체&#39; 로직 종료 ################ length(n) ## [1] 50 head(n) #2보다 큰 2의 배수가 제거되었는지 확인 ## [1] 2 3 5 7 9 11 n[2] #다음 작업을 위해 남은 자연수 중 두 번째 소수값 확인 ## [1] 3 남은 자연수 벡터 중 두 번째 소수인 \\(3\\)를 남기고 \\(3\\)의 배수를 모두 제거합니다. Notepad, Notes, Sublime Text 등과 같은 문서 편집기 (text editor)나 RStudio의 R 스크립트 편집창을 열어서 아래 코드의 첫째 줄과 둘째 줄을 작성합니다. \\(2\\)단계의 ‘에라토스테네스의 체’ 로직부분 (로직시작 라인부터 로직 종료 라인까지) 코드를 복사해서 문서 편집기에 붙여 넣습니다. 그런 다음에, 나머지 코드를 작성합니다. \\(2\\)단계의 코드 전체를 문서 편집기로 복사한 후, i &lt;- 1을 i &lt;- 2로, n[2]를 n[3]으로 변경해도 \\(3\\)단계 코드를 얻을 수 있습니다. 문서 편집기에 작성된 코드를 모두 선택하여 복사한 후, RStudio 콘솔창에 붙여 넣고 엔터를 클릭하여 실행합니다. i &lt;- 2 p &lt;- n[i] #### &#39;에라토스테네스의 체&#39; 로직 시작 ################ 2단계에서 이미 구현한 &#39;에라토스테네스의 체&#39; 로직 부분 코드 4줄을 복사해서 여기에 붙여 넣으세요. #### &#39;에라토스테네스의 체&#39; 로직 종료 ################ length(n) head(n) n[3] 남은 자연수 벡터 중 세 번째 소수인 \\(5\\)를 남기고 \\(5\\)의 배수를 모두 제거합니다. \\(3\\)단계에서 문서 편집기 (text editor)에 생성한 코드에서 i &lt;- 2를 i &lt;- 3으로, n[3]을 n[4]로 변경하고 완성된 코드를 콘솔창에 실행합니다. i &lt;- 3 p &lt;- n[i] #### &#39;에라토스테네스의 체&#39; 로직 시작 ################ 위에서 이미 구현한 &#39;에라토스테네스의 체&#39; 로직 부분 코드를 복사해서 붙여 넣으세요. #### &#39;에라토스테네스의 체&#39; 로직 종료 ################ length(n) head(n) n[4] 남은 자연수 벡터 중 네 번째 소수인 \\(7\\)를 남기고 \\(7\\)의 배수를 모두 제거합니다. \\(4\\)단계에서 notepad, notes, sublime text 등과 같은 문서 편집기 (text editor)에 생성한 코드에서 i &lt;- 3을 i &lt;- 4로, n[4]를 n[5]로 변경하고 완성된 코드를 콘솔창에 실행합니다. i &lt;- 4 p &lt;- n[i] #### &#39;에라토스테네스의 체&#39; 로직 시작 ################ 위에서 이미 구현한 &#39;에라토스테네스의 체&#39; 로직 부분 코드를 복사해서 붙여 넣으세요. #### &#39;에라토스테네스의 체&#39; 로직 종료 ################ length(n) head(n) n[5] #이와 같이 계속 진행하면 2, 3, 5, 7, ⋯과 같은 소수만 남는다. 위의 소스코드를 잘 살펴보면 반복되는 부분이 보입니다. i &lt;- 1, n[2]부분만 i &lt;- 2, n[3]로, i &lt;- 3, n[4]로, i &lt;- 4, n[5]로 바뀌고 나머지 부분은 동일하게 반복됩니다. i &lt;- 1, n[2] 부분을 i &lt;- 1, n[i+1]로 바꾸면 i &lt;- 1 부분만 i &lt;- 2, i &lt;- 3, i &lt;- 4로 바뀌는 걸 알 수 있습니다. 변수 i의 값도 아래와 같이 초기값을 설정해 주면 반복되는 패턴으로 변경할 수 있습니다. 반복되는 패턴을 이용하여 위에서 다섯 단계로 구현된 로직을 두 단계로 줄여보겠습니다. 아래의 소스코드를 콘솔창에 실행하여 자연수 벡터 n을 생성하고 변수 i와 p의 초기값을 설정합니다. #2에서 100의 자연수 벡터 생성 x &lt;- 100 n &lt;- 2:x length(n) #첫 번째 i, p값 설정 i &lt;- 1 p &lt;- n[i] 자연수 벡터 n과 변수 i와 p의 초기값을 설정한 다음에 아래의 소스코드를 이용하여 소수의 배수들을 지워나가면서 자연수 벡터 값을 반복적으로 갱신합니다. 이번에는 콘솔창에서 직접 소스코드를 실행하지 않고 R 스크립트 편집창을 이용해 보도록 하겠습니다. 소스코드 밑 부분의 RStudio 메뉴 관련 설명을 참고하세요. #### &#39;에라토스테네스의 체&#39; 로직 시작 ################ 위에서 이미 구현한 &#39;에라토스테네스의 체&#39; 로직 부분 코드를 복사해서 붙여 넣으세요. #### &#39;에라토스테네스의 체&#39; 로직 종료 ################ i &lt;- i+1 #다음번째 i값 설정 p &lt;- n[i] #다음번째 p값 설정 n #갱신된 자연수 벡터 확인 length(n) #갱신된 자연수 벡터에 담긴 값의 개수 확인 plot(n) #그래프로 갱신된 자연수 벡터 확인 RStudio 메뉴에서 File &gt;&gt; New File &gt;&gt; R Script를 클릭한 후, R 스크립트 편집창에 위의 소스코드를 입력하고 마우스나 키보드를 이용하여 입력한 코드를 전부 선택한 다음에 스크립트창 상단에 위치한 Run 버튼을 마우스로 클릭하거나 키보드에서 Ctrl+Enter를 입력하면 선택된 소스코드의 모든 내용이 실행되고 그 결과가 콘솔창에 나타납니다. R 스크립트 편집창에서 소스코드를 전부 선택하는 과정 없이 Run 버튼에서 오른쪽으로 두 번째 위치에 있는 ‘Source the active document’ 버튼을 클릭하여도 현재 스크립트 편집창의 전체 소스코드를 실행해 볼 수 있습니다. 스크립트 편집창의 소스코드가 전부 선택되어 있는 상태에서 Run 버튼을 누르면 자연수 벡터 n에 저장된 자연수의 개수가 \\(50\\)개로 갱신되는 것을 콘솔창에서 확인할 수 있습니다. 스크립트 편집창의 소스코드가 전부 선택되어 있는 상태에서 Run 버튼을 다시 누르면 벡터 n의 자연수 개수가 \\(34\\)개로 갱신됩니다. 스크립트 편집창의 소스코드가 전부 선택되어 있는 상태에서 Run 버튼을 다시 누르면 벡터 n의 자연수 개수가 \\(28\\)개로 갱신됩니다. 스크립트 편집창의 소스코드가 전부 선택되어 있는 상태에서 Run 버튼을 다시 누르면 벡터 n의 자연수 개수가 \\(25\\)개로 갱신됩니다. 그 이후에는 Run 버튼을 다시 눌러도 벡터 n의 자연수 개수가 변하지 않습니다. \\(2\\)~\\(100\\) 사이의 자연수 중 소수만을 걸러내는 ‘에라토스테네스의 체’ 로직이 완성되었습니다. \\(2\\)~\\(100\\) 사이의 자연수 중 소수의 개수는 \\(25\\)개이고 그 결과는 아래와 같습니다. ## [1] 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 ## [21] 73 79 83 89 97 결과 첫 줄의 [1]은 출력되는 결과값의 순서를 나타내는 것으로, 결과 둘째 줄의 [21]은 둘째 줄에 출력될 결과값의 시작이 스물한 번째 값 부터라는 뜻입니다. 길이가 긴 벡터값을 화면에 출력할 때는 한 줄로 표현하기 힘들기 때문에 줄이 바뀌는 지점에서 해당 줄의 시작점에 있는 값이 몇번째인지를 []안의 값으로 알려주는 것입니다. 따라서 여러분의 콘솔창의 크기에 따라 []안의 값이 다를수 있습니다. 하지만 전체 결과값에는 영향이 없습니다. 위에서 구현된 ‘에라토스테네스의 체’ 로직은 1) 자연수 벡터 생성 및 i 변수 초기값 설정 로직, 2) 자연수 벡터 갱신 로직으로 나뉩니다. \\(2\\)~\\(1000\\) 사이의 자연수에 존재하는 소수 벡터를 구하려면 어떻게 해아할까요? ‘에라토스테네스의 체’ 의 첫 번째 로직 1) 자연수 벡터 생성 및 i 변수 초기값 설정 부분에서 자연수 벡터를 크게 생성해주면 됩니다. x &lt;- 100 부분을 x &lt;- 1000 변경하고 위에서 구현된 ‘에라토스테네스의 체’ 코드를 다시 실행하여 \\(2\\)~\\(1000\\) 사이의 자연수에 존재하는 소수 벡터를 직접 구해보세요. \\(11\\)번의 반복적인 Run 버튼 클릭 후에 \\(168\\)개의 소수를 가지는 소수벡터를 구할수 있습니다. 자연수 벡터 갱신 로직이 반복될 때마다 벡터의 크기는 \\(500\\) -&gt; \\(334\\) -&gt; \\(268\\) -&gt; \\(231\\) -&gt; \\(211\\) -&gt; \\(195\\) -&gt; \\(185\\) -&gt; \\(177\\) -&gt; \\(171\\) -&gt; \\(169\\) -&gt; \\(168\\) 순으로 줄어들게 됩니다. tail(n) ## [1] 967 971 977 983 991 997 \\(2\\)~\\(100\\) 사이의 자연수 중 소수만을 걸러내는 경우, 위의 코드를 반복적으로 \\(4\\)번 실행해줘야 원하는 결과를 얻을 수 있었습니다. 이와 같이 특정 로직을 반복적으로 실행해야 하는 경우 반복문 (루프, loop)을 이용하여 반복 실행하는 부분마저 로직에 포함할 수 있습니다. for() 루프와 while() 루프가 대표적인 반복문입니다. 먼저 for() 루프를 먼저 살펴보겠습니다. 아래와 같이 변수 i의 값을 \\(1\\)부터 \\(4\\)까지 변경해가면서 { } 안의 내용들을 반복해서 실행하도록 할 수 있습니다. for (i in c(1:4)) { print(paste(&quot;current i = &quot;, i)) #paste()함수로 두 개의 다른 문자열을 합쳐서 한 줄에 출력 } ## [1] &quot;current i = 1&quot; ## [1] &quot;current i = 2&quot; ## [1] &quot;current i = 3&quot; ## [1] &quot;current i = 4&quot; for() 루프를 \\(2\\)~\\(100\\) 사이의 자연수 중 소수를 걸러내는 로직에 적용해 보도록 하겠습니다. 위에서는 로직이 1) 벡터 및 변수 초기화, 2) 자연수 벡터 갱신로 나누어져 있었습니다. 이번에는 반복 수행하는 부분까지 로직안에 포함시켜 보겠습니다. 아래 코드의 #### '에라토스테네스의 체' for() 로직 시작 ####과 #### '에라토스테네스의 체' for() 로직 종료 ####사이에 있는 부분은 이해하기 어려울 수 있습니다. 그냥 쿨하게 복사해서 붙여넣으세요. #### 변수 x에 자연수 값 설정 x &lt;- 100 #### &#39;에라토스테네스의 체&#39; for() 로직 시작 ################ n &lt;- 2:x #자연수 벡터 생성 ## 자연수 벡터 반복 갱신 for (i in c(1:4)) { p &lt;- n[i] if (p*2 &lt;= x) { #if 현재 소수의 배수가 입력값 자연수보다 작거나 같으면 composite &lt;- seq(p*2, x, p) #소수가 아닌 숫자 벡터 생성 } else composite &lt;- c() #else 아니면 배수 벡터 값을 빈값 (NULL)으로 설정 n &lt;- setdiff(n, composite) #자연수 벡터 갱신 } #### &#39;에라토스테네스의 체&#39; for() 로직 종료 ################ #### 결과 확인 n #갱신된 자연수 벡터 확인 length(n) #갱신된 자연수 벡터에 담긴 값의 개수 확인 반복 수행하는 부분을 로직 안에 포함시키고 나니 로직을 두 부분으로 나눌 필요가 없을 뿐 아니라 소드코드 자체도 훨씬 단순해졌습니다. 이와 같이 반복 수행 회수를 정확히 알고 있는 경우에 for() 루프를 사용합니다. 하지만 루프문을 사용하기 전에 우리는 \\(2\\)~\\(100\\) 사이의 자연수 중 소수 벡터 구하는 로직 중 반복 수행 부분을 Run 버튼을 한번, 두 번 눌러가며 자연수 벡터가 갱신되는 걸 확인해봤기 때문에 \\(4\\)번 반복 수행하면 된다는 것을 알 수 있었습니다. 하지만 \\(2\\)~\\(1000\\) 사이의 소수 벡터를 구하거나 \\(2\\)~\\(10000\\) 사이의 소수 벡터를 구하려 한다면 몇 번을 반복 수행해야 할까요? 특정 조건을 만족하는 동안 루프문을 수행하고 싶은 경우에는 while() 루프를 사용합니다. 특정 조건을 만족하는 동안 루프문을 수행할 수 있다면, 반대로 특정 조건에 도달할 때까지 루프문을 수행하게 할 수도 있습니다. 위에서 for() 루프를 이용해서 변수 i의 값을 \\(1\\)부터 \\(4\\)까지 변경해 가면서 { } 안의 내용들을 반복해서 실행했던 로직을 while() 루프로 변경해보겠습니다. i &lt;- 1 while (i &lt; 5) { print(paste(&quot;current i = &quot;, i)) #paste()로 두 가지 문자열을 합쳐서 한 줄에 출력 i = i +1 } ## [1] &quot;current i = 1&quot; ## [1] &quot;current i = 2&quot; ## [1] &quot;current i = 3&quot; ## [1] &quot;current i = 4&quot; while() 루프를 만들 때에는 루프문을 멈추게 하는 조건을 찾는 것이 중요합니다. 언제 멈출지 모르면 무한 루프에 빠지게 됩니다. 우리가 위에서 사용했던 ‘에라토스테네스의 체’ 로직은 자연수 벡터 n에서 지울 값 벡터 composite를 반복적으로 삭제해 가면서 자연수 벡터를 갱신하는 방식으로 구현되었었습니다. 따라서, 지울 값 벡터 composite의 값이 자연수 벡터 n에 포함되어 있지 않다면 더 이상 지울 값이 없고 자연수 벡터의 갱신은 멈추게 됩니다. 반복 수행을 멈추는 조건이 될 수 있습니다. 거꾸로 생각해 보면, 지울 값 벡터 composite의 값이 자연수 벡터 n에 하나라도 포함되어 있으면 반복 수행을 유지하면 됩니다. 다른 말로 하면, (composite %in% n)의 결과 생성되는 로직형 벡터 안에 TRUE 값이 하나라도 있으면 반복 수행을 유지하면 됩니다 (TRUE %in% (composite %in% n)). 이 조건과 for() 루프 대신 while() 루프를 이용하여 ‘에라토스테네스의 체’ 로직에 적용해 보겠습니다. 아래 소스코드의 #### '에라토스테네스의 체' while() 로직 시작 ####과 #### '에라토스테네스의 체' while() 로직 종료 ####사이에 있는 부분은 이해하기 어려울 수 있습니다. 어떻게 해야 하는지 아시죠? 복붙하세요. #### 변수 x에 자연수 값 설정 x &lt;- 100 #### &#39;에라토스테네스의 체&#39; while() 로직 시작 ################ n &lt;- 2:x #자연수 벡터 생성 i = 0 flag = TRUE ##자연수 벡터 반복 갱신 while (flag) { #로직형 변수 flag 값이 TRUE인 동안 루프 작동 i = i + 1 #변수 i의 값은 1부터… p &lt;- n[i] #첫 번째 소수 if (p*2 &lt;= x) { #if 현재 소수의 배수가 입력값 자연수보다 작거나 같으면 composite &lt;- seq(p*2, x, p) #소수가 아닌 숫자 벡터 생성 } else composite &lt;- c() #else 아니면 배수 벡터 값을 빈값 (NULL)으로 설정 #flag = (TRUE %in% (composite %in% n)) #지울 값이 없으면 반복 중단 신호 flag = any(is.element(composite,n)) #지울 값이 없으면 반복 중단 신호 if (flag) n &lt;- setdiff(n, composite) ##지울 값이 있으면 자연수 벡터 갱신 } #### &#39;에라토스테네스의 체&#39; while() 로직 종료 ################ #### 결과 확인 i-1 #반복 수행 횟수 n[i-1] #지울 값 벡터 생성에 사용된 마지막 소수 length(n) #소수의 총 개수 head(n, 10) #소수 벡터 앞에서 열 개의 확인 tail(n, 10) #소수 벡터 뒤에서 열 개의 확인 위의 소스코드를 콘솔창에서 실행시켜 보고, 몇 번 반복 수행하는지 소수의 총 개수는 몇 개인지 벡터에 포함된 소수 중 가장 큰 소수의 값은 얼마인지 살펴보세요. 변수x의 값을 x &lt;- 10000, x &lt;- 1000000으로 변경하고 로직을 실행해 보세요. \\(10,000\\) 이하의 자연수 중에서 가장 큰 소수는 얼마입니까? \\(1,000,000\\) 이하의 자연수 중에서 가장 큰 소수는 얼마입니까? 소수를 구하는 방법인 ‘에라토스테네스의 체’ 로직에 대하여 자세히 살펴보았습니다. 이제 다시 소인수분해로 돌아가서 나만의 소인수분해 함수를 만들어 봅시다. 2.1.3 나만의 소인수분해 함수 myFactorize() 만들기 먼저 함수를 만드는 방법을 알아본 후에 ‘에라토스테네스의 체’ 로직을 함수로 만들어 보겠습니다. 우리는 이미 gmp 패키지의 소인수분해 함수인 gmp::factorize()를 사용해보았습니다. factorize(24)와 같이 입력값을 ()안에 넣으면 함수 안에서 정해진 계산을 거친 다음에 결과값을 반환합니다. factors &lt;- gmp::factorize(24) factors ## Big Integer (&#39;bigz&#39;) object of length 4: ## [1] 2 2 2 3 입력값에 \\(2\\)를 곱한 값을 반환하는 간단한 함수를 만들어 보겠습니다. ()안에 주어진 입력값을 가지고 {}안에서 처리 과정을 거친 다음에 반환할 결과값을 return ()에 넣어주면 됩니다. twoTimes &lt;- function(x) { result &lt;- x * 2 return (result) } y = twoTimes(3) y ## [1] 6 자 이제 ‘에라토스테네스의 체’ 함수를 만들어 보겠습니다. primeNumbers &lt;- function(x) { x &lt;- as.integer(x) #정수가 아닌 값이 입력되었을 경우 정수로 변환 if (x &lt; 2) { #2보다 작은 값이 입력값인 경우 로직부분에 들어가지않고 return (NULL) #빈 값(NULL)을 반환하고 함수 종료 } #### &#39;에라토스테네스의 체&#39; while() 로직 시작 ################ 위에서 이미 구현한 &#39;에라토스테네스의 체&#39; while() 로직 부분 코드를 복사해서 붙여넣으세요. #### &#39;에라토스테네스의 체&#39; while() 로직 종료 ################ return(n) } primeNumbers(24) ## [1] 2 3 5 7 11 13 17 19 23 ‘에라토스테네스의 체’ 함수에 입력값 \\(24\\)를 넣어서 결과를 보았더니 gmp::factorize(24)의 결과와 다릅니다. gmp::factorize(24)함수는 소인수분해 결과를 반환하는 반면, ‘에라토스테네스의 체’ 함수인 primeNumbers(24)는 \\(24\\)보다 작은 소수 벡터를 반환하기 때문입니다. 위에서 primeNumbers(24)함수로 구해진 소수들 중에 \\(24\\)의 인수 (약수)만 뽑아보도록 하겠습니다. primeNumbers() 함수를 이용하여 소인수를 반환하는 primeFactors()함수를 생성해 보겠습니다. 아래의 소스코드에 사용된 %%연산자는 나머지를 구하는 연산자입니다. \\(5\\)를 \\(2\\)로 나누면 몫은 \\(2\\)이고 나머지는 \\(1\\)이므로 5%%2의 결과는 \\(1\\)이고, \\(24\\)를 \\(23\\)으로 나누면 몫은 \\(0\\)이고 나머지는 \\(1\\)이므로 24 %% 23 == 0 (1 == 0)의 결과는 FALSE가 됩니다. primeFactors &lt;- function(x) { div &lt;- primeNumbers(x) factors &lt;- div[x %% div == 0] #소수 중 x의 약수만 추출 return(factors) } primeFactors(24) ## [1] 2 3 primeFactors() 함수에 입력값 \\(24\\)를 넣어서 결과를 보았더니 gmp::factorize(24)의 결과와 다릅니다. gmp::factorize(24)함수는 소인수분해 결과를 반환하는 반면, primeFactors() 함수는 \\(24\\)의 소인수를 결과로 반환하기 때문입니다. 문제를 푸는 방법은 다양합니다. 한순간에 머릿속에서 문제가 풀리는 경우도 있지만 문제가 조금 복잡한 경우 한 단계 한 단계 차근 차근 해결책에 가까워지는 형식으로 문제를 풀게 됩니다. 이 책에서 설명하는 소인수분해를 하는 방법이 가장 쉽게 빠른 방법은 아닙니다. 소수, 소인수, 소인수분해라는 개념의 흐름을 따라 데이터 처리, 로직 구현을 해보면서 R의 세계에 익숙해 지는 것이 목적입니다. 이제 primeFactors()함수를 이용하여 소인수분해 결과를 반환하는 myFactorize()함수를 생성해 보겠습니다. 다시 말하지만, 소스코드의 #### prime factorization 로직 시작 ####과 #### prime factorization 로직 종료 ####처럼 #### 로직 시작 ####과 #### 로직 종료 ####사이의 코드는 이해하기 어려울 수 있습니다. 이해되는 순간이 반드시 오니까 조급해하지 말고 쿨하게 복붙하세요. 첫 번째 루프에서 변수 i값이 \\(1\\)일때, div[i]값은 얼마인지 x값과 factors값은 어떻게 바뀌는지 차근 차근 종이에 써보면서 흐름을 따라가 보면 도움이 됩니다. 그다음에 두 번째 루프, 세 번째 루프… myFactorize &lt;- function(x) { div &lt;- primeFactors(x) i=1 factors = c() #### prime factorization 로직 시작 ################ while ((i &lt;= length(div)) &amp; (x %% div[i] == 0)) { x = x / div[i] factors = c(factors, div[i]) if (x %% div[i] != 0) i = i +1 #나누어지지 않으면 다음 소인수로 } #### prime factorization 로직 시작 ################ return(factors) } myFactorize(24) ## [1] 2 2 2 3 마침내, 우리가 원하는 소인수분해 결과를 얻었습니다. myFactorize() 함수에 입력값 24를 넣어서 결과를 보았더니 gmp::factorize(24)의 결과와 일치합니다. myFactorize() 함수의 결과를 거듭제곱 (밑과 지수) 형태를 포함하는 소인수들의 표현해내면 소인수분해는 끝이 납니다. myFactorize(24)의 결과는 \\(2\\)가 \\(3\\)개, \\(3\\)이 \\(1\\)개인 벡터입니다. 밑과 지수의 표현 방식은 중복되는 소인수들을 거듭제곱 형태로 간결하게 해줄 뿐 아니라 중복되는 소인수가 많을 경우 소인수들의 곱을 압축적으로 표현할 수 있습니다. 이러한 표현 방식은 연속해서 중복되는 데이터들을 value와 count로 나누어 저장하여 데이터를 압축하는 Run-length encoding (RLE) 표현 방식과 의미가 통합니다. rle()함수를 이용하여 밑과 지수를 이용한 거듭제곱 형태로 표현해 보겠습니다. x &lt;- myFactorize(24) xe &lt;- rle(x) #인코딩 base &lt;- xe[[2]] #rle의 value exponent &lt;- xe[[1]] #rle의 count xs &lt;- &#39;&#39; for (i in 1:length(base)) { xs &lt;- paste0(xs, base[i], &#39;^&#39;, exponent[i]) # 마지막 소인수 뒤에 &quot;*&quot;를 붙이지 않기 위한 조건문 if (i != length(base)) xs &lt;- paste0 (xs, &quot; * &quot;) } print(xs) ## [1] &quot;2^3 * 3^1&quot; 위의 소스코드를 통해 얻어진 변수 xs에 저장되어 있는 문자열을 수학 표현식으로 바꿔서 실제 계산해 보면 소인수분해 전의 원래 자연수 값을 확인할 수 있습니다. xexpr &lt;- parse(text=xs) #문자열을 표현식으로 변환 eval(xexpr) #표현식을 이용하여 실제 계산 수행 ## [1] 24 소인수분해를 설명하면서 R의 개념들 (패키지, 벡터, 반복문, 조건문, 연산자)을 소개했지만, 몇몇 부분들은 자세한 설명 없이 그냥 남겨두었습니다. 구글, 네이버, 다음, 유투브 등을 통해 궁금한 내용들을 검색해보면서 스스로 이해의 폭을 넓혀 가는 경험을 꼭 해보도록 하세요. 자, 이제 소인수분해가 최대공약수, 최소공배수를 구하는데 어떻게 활용되는지 살펴봅시다. 2.1.4 최대공약수와 최소공배수 두 개 이상의 자연수의 공통된 약수를 공약수 (common divisor)라고 하고 공약수 중 가장 큰 공약수를 최대공약수 (greatest common divisor, gcd)라고 합니다. 두 자연수의 최대공약수가 \\(1\\)이 되는 경우, 예를 들어 \\(25\\)와 \\(9\\)의 경우 \\(25\\)의 약수는 \\(1\\), \\(5\\), \\(25\\)이고, \\(9\\)의 약수는 \\(1\\), \\(3\\), \\(9\\)이므로 두 자연수의 최대공약수는 \\(1\\)이며 이러한 경우 두 자연수를 서로소 (coprime)라고 합니다. 두 개 이상의 자연수의 공통된 배수를 공배수 (common multiple)라고 하고 공배수 중 가장 작은 공배수를 최소공배수 (least common multiple)라고 합니다. 두 자연수 \\(48\\)과 \\(180\\)의 경우, 공약수인 소수 \\(2\\), \\(2\\), \\(3\\)을 모두 곱한 \\(2 \\times 2 \\times 3 = 12\\)가 최대공약수이고, 두 자연수의 소인수들을 공약수가 중복되지 않도록 모두 곱한 \\(2 \\times 2 \\times (2 \\times 2 \\times \\times 3) \\times 3 \\times 5 = 720\\)가 최소공배수입니다 (그림 2.3). 그림 2.3: 두 자연수 48과 180의 소인수 (출처 https://en.wikipedia.org/wiki/Greatest_common_divisor) 위의 그림에서는 두 자연수의 최대공약수와 최소공배수를 구하기 위하여 거듭제곱 (밑과 지수) 형태의 소인수분해를 사용했지만, 주어지는 자연수의 개수가 많아질 수록 그림을 이용한 해법은 점점 더 복잡해 집니다. 두 개 이상의 자연수가 주어질 경우에 최대공약수와 최소공배수를 구하기 위해 거듭제곱 형태의 소인수분해를 사용하여 최대공약수와 최소공배수를 구하는 로직을 사용할 수 있습니다. 먼저 최대공약수 구하는 로직을 네 단계로 나누어 구현해 보겠습니다. 먼저 주어진 자연수들 (\\(18\\), \\(60\\), \\(180\\))의 거듭제곱 형태로 소인수분해한 후, 데이터 프레임 형태로 변환합니다. 각 자연수를 for루프를 이용하여 하나씩 소인수분해하고 거듭제곱 형태로 표현한 후에 소인수의 밑과 지수를 각각 저장합니다. 이 과정에 새로운 자료 형태인 리스트 (list)가 사용됩니다. 아래 소스코드의 첫 줄은 리스트를 사용하기 위한 rlist패키지를 설치하는 코드입니다. 패키지가 설치되어 있어야 패키지를 로딩할 수 있기 때문에, 처음 패키지를 사용하는 경우에는 install.packages()를 이용하여 패키지를 설치해 주어야 합니다. rlist패키지를 설치하는 방법에는 두 가지가 있습니다. 첫 번째, RStudio 콘솔창에서 install.packages(&quot;rlist&quot;)를 실행하는 방법입니다. 두 번째, Rstudio 메뉴 &gt;&gt; Tools &gt;&gt; Install Packages…를 클릭한 후, Packages 입력상자에 rlist라고 입력하고 Install 버튼을 클릭하여 패키지를 설치하는 방법입니다. 두 가지 방법 중 하나를 선택하여 해당 패키지를 설치하여야 패키지 로딩시 에러가 발생하지 않습니다. #install.packages(&quot;rlist&quot;) #rlist 패키지를 처음 사용하는 경우, 패키지 설치 library(rlist) #리스트 (list) 자료 형태 사용을 위해 rlist 패키지 로딩 N &lt;- c(18, 60, 180) #주어진 자연수들 벡터 baselist &lt;- list() #자연수들의 밑을 저장할 리스트 exponentlist &lt;- list() #자연수들의 지수를 저장할 리스트 for (i in 1:length(N)) { #벡터 값의 개수만큼 반복 수행하면서 x &lt;- myFactorize(N[i]) #각 자연수 소인수분해 xe &lt;- rle(x) #인코딩 baselist &lt;- list.append(baselist, xe[[2]]) #rle의 value를 baselist 리스트에 추가 exponentlist &lt;- list.append(exponentlist, xe[[1]]) #rle의 count를 exponentlist 리스트에 추가 } 위의 소스코드에서는 자연수들을 소인수분해한 다음에 밑과 지수 값을 각각 리스트 (list) 자료 형태인 baselist, exponentlist에 저장했습니다. 리스트는 값을 저장할 때 벡터와 다르게 데이터 객체를 각각 다른 공간에 구분하여 저장합니다. 벡터는 값들을 왼쪽에서 오른쪽으로 한 줄로 나열하고 저장하는 형태인 반면에, 리스트는 각 값들을 위에서 아래로 칸을 나누어서 구분된 공간에 저장하는 형태입니다. 아래의 코드와 실행 결과를 보면 주어진 자연수들 (N 벡터; \\(18\\), \\(60\\), \\(180\\))의 소인수 밑 값이 baselist 리스트 안에 \\(3\\)개의 구분된 공간(baselist[[1]], baselist[[2]], baselist[[3]])에 각각 저장된 것을 알 수 있습니다. baselist ## [[1]] ## [1] 2 3 ## ## [[2]] ## [1] 2 3 5 ## ## [[3]] ## [1] 2 3 5 baselist[[1]] #첫 번째 자연수의 소인수 밑 ## [1] 2 3 baselist[[2]] #두 번째 자연수의 소인수 밑 ## [1] 2 3 5 baselist[[3]] #세 번째 자연수의 소인수 밑 ## [1] 2 3 5 주어진 자연수들의 소인수 밑과 지수를 저장하는 데이터 프레임을 만들기 위해서는 전체 자연수들이 가지는 소인수들의 밑 값들에서 중복되는 값을 제거한 후의 개수를 알아야 합니다. 그 개수 만큼의 밑과 지수 컬럼을 만들어야 하기 때문입니다. 아래의 소스코드로 중복을 제거한 후의 전체 밑 값의 개수를 알 수 있습니다. P &lt;- unlist(baselist) P &lt;- unique(P) P &lt;- sort(P) length(P) ## [1] 3 위의 소스코드를 한 줄로 좀 더 짧게 작성해보겠습니다. 소스코드 라인 개수는 줄어들었으나 코드를 읽는 순서가 거꾸로 되어서 이해가 더 어려워진 측면이 있습니다. length(sort(unique(unlist(baselist)))) 가독성을 높이면서 소스코드를 간결하게 만들기 위하여 dplyr 패키지의 그 유명한 파이프 연산자 (pipe operator, %&gt;%)를 사용해 보겠습니다. 파이프로 각 함수들을 연결하면 연속적인 데이터 처리 시 좀 더 직관적이고 간결한 코드를 생성할 수 있습니다. 파이프로 함수를 연결할 때 파이프 뒤에 있는 함수의 첫 입력값 (input, argument)은 파이프 앞에 있는 객체가 사용되므로, 파이프 뒤 함수의 ()안에 첫 번째 입력값은 생략하고 두 번째 입력값부터 넣어주면 됩니다. 함수의 입력값이 하나인 경우 ()처럼 입력값 부분이 비어있는 채로 사용 가능합니다. #install.packages(&quot;dplyr&quot;) ##처음 패키지를 사용하는 경우 패키지 설치 library(dplyr) ##패키지에서 제공하는 함수, 연산자 사용을 위해 패키지 로딩 unlist(baselist) %&gt;% unique() %&gt;% sort() %&gt;% length() #or baselist %&gt;% unlist() %&gt;% unique() %&gt;% sort() %&gt;% length() #or P &lt;- baselist %&gt;% unlist() %&gt;% unique() %&gt;% sort() length(P) 위의 소스코드로 부터 주어진 \\(3\\)개의 자연수에 사용된 중복 없는 소인수 P벡터, 자연수 별로 소인수 밑 값을 각각 구분해서 담은 baselist리스트, 자연수 별로 소인수 거듭제곱 지수 값을 각각 구분해서 담은 exponentlist리스트를 얻었습니다. 이들 리스트를 이용하여 소인수의 밑과 지수를 각 컬럼으로 가지는 pf_df데이터 프레임을 생성해 보도록 하겠습니다. 특정 자연수가 다른 자연수가 가지는 소인수 밑과 지수를 가지지 않는 경우는 NA (not applicable, not available or no answer)로 값을 설정하겠습니다. pf_df데이터 프레임을 생성하고 난 후, 밑 컬럼만 가지는 데이터 프레임 p_df과 지수 컬럼만 가지는 데이터 프레임 r_df도 추가로 생성해 보겠습니다. 아래 소스코드에서는 for (i in 1:length(N)) { }루프 안에 for (j in 1:length(P)) { }루프가 존재합니다. 루프 안에 루프가 존재하는 이중 반복문 형태로, 우리가 익숙한 이중 반복 형태는 구구단, 학년 별-반 별 등이 있습니다. 아래 소스코드에서는 \\(i\\) 번째 자연수의 \\(j\\) 번째 밑, 지수에 접근하기 위해 이중 루프를 사용하였습니다. #### 시작 ####과 #### 종료 ####사이의 코드는 다소 이해가 어려울 수 있습니다. 쿨하게 복붙하세요. library(dplyr) ##패키지에서 제공하는 함수, 연산자 사용을 위해 패키지 로딩 pf_df &lt;- data.frame() #pf 데이터 프레임 생성 #### prime factorization 데이터 프레임 로직 시작 ##################### for (i in 1:length(N)) { #첫 번째 자연수부터… base &lt;- baselist[[i]] #첫 번째 자연수의 밑 값 벡터 exponent &lt;- exponentlist[[i]] #첫 번째 자연수의 지수 값 벡터 #각 자연수별로 row를 만들어 rbind로 데이터 프레임을 행을 추가 r = c() #빈 row 벡터 생성. for (j in 1:length(P)) { #각 자연수의 첫 번째 밑 값부터… nth &lt;- which(P[j] == base)[1] #소인수 값으로 밑 값 벡터에서의 위치 파악 if (!is.na(nth)) { r = c(r, base[nth], exponent[nth]) #해당 밑과 지수 부분 값 추가 } else r = c(r, NA, NA) #해당 밑과 지수 부분 값 없음 (not assigned, NA) } pf_df &lt;- rbind(pf_df, r) #데이터 프레임에 행 추가 } #pf 데이터 프레임 컬럼명 설정 colnames(pf_df) &lt;- paste0(rep(c(&#39;P&#39;, &#39;r&#39;), times=length(P)), rep(1:length(P), each=2)) #### prime factorization 데이터 프레임 로직 종료 ##################### p_df &lt;- pf_df %&gt;% #dplyr 패키지의 select() 함수 사용 select(starts_with(&quot;P&quot;)) #밑수 P1, P2, P3 컬럼만 선택 r_df &lt;- pf_df %&gt;% #dplyr 패키지의 select() 함수 사용 select(starts_with(&quot;r&quot;)) #지수 r1, r2, r3 컬럼만 선택 print(p_df) ## P1 P2 P3 ## 1 2 3 NA ## 2 2 3 5 ## 3 2 3 5 print(r_df) ## r1 r2 r3 ## 1 1 2 NA ## 2 2 1 1 ## 3 2 2 1 첫 번째 단계에서 구해진 소인수 밑 데이터 프레임 p_df의 각 컬럼 중 NA값이 존재하지 않는 컬럼만을 선택합니다. NA값을 가지는 소인수 컬럼은 최대공약수의 소인수가 될 수 없기 때문입니다. no_na_column &lt;- function(x) {!any(is.na(x))} #컬럼 벡터에 NA가 존재하지 않으면 TRUE를 반환하는 함수 p_df1 &lt;- p_df %&gt;% select_if(no_na_column) #no_na_column 함수가 TRUE를 반환하는 컬럼만 선택 p_v &lt;- as.vector(p_df1[1,]) #자연수들의 공통 소인수 밑 벡터 생성 #or p_df1 &lt;- p_df %&gt;% select_if(function(x) {!any(is.na(x))} ) p_v &lt;- as.vector(p_df1[1,]) 두 번째 단계와 같은 조건으로 소인수 지수 데이터 프레임 r_df에서 NA값을 가진 컬럼을 제외한 후, 각 지수 컬럼의 최소값을 구합니다. no_na_column &lt;- function(x) {!any(is.na(x))} #컬럼 벡터에 NA가 존재하지 않으면 TRUE를 반환하는 함수 r_df1 &lt;- r_df %&gt;% select_if(no_na_column) %&gt;% #no_na_column 함수가 TRUE를 반환하는 컬럼만 선택 summarise_if(is.numeric, min, na.rm = TRUE) #각 컬럼의 최소값 (가장 작은 지수)을 구함 r_v &lt;- as.vector(r_df1[1,]) 선택된 밑 (p_v벡터) 의 선택된 지수 (r_v벡터)를 다시 거듭제곱 형태로 변환하고 모두 곱한다. base &lt;- p_v exponent &lt;- r_v xs &lt;- &#39;&#39; for (i in 1:length(base)) { xs &lt;- paste0(xs, base[i], &#39;^&#39;, exponent[i]) # 마지막 소인수 뒤에 &quot;*&quot;를 붙이지 않기 위한 조건문 if (i != length(base)) xs &lt;- paste0 (xs, &quot; * &quot;) } xexpr &lt;- parse(text=xs) #문자열을 표현식으로 변환 x &lt;- eval(xexpr) #표현식을 이용하여 실제 계산 수행 print(paste(&quot;주어진 자연수&quot;, toString(N), &quot;들의 최대공약수:&quot;, xs, &quot;=&quot;, x)) ## [1] &quot;주어진 자연수 18, 60, 180 들의 최대공약수: 2^1 * 3^1 = 6&quot; 데이터베이스 (database, DB) 분야에 데이터 추출, 변형, 로딩 (extract, transform, load; ETL)이라는 개념이 있습니다. ETL은 여러 데이터 소스로 부터 원하는 데이터를 뽑아내고, 원하는 형태로 변형한 후, 데이터 웨어하우스(data warehouse, DW)에 로딩하는 과정을 말합니다. 이렇게 구축된 데이터 웨어하우스는 데이터 분석, 데이터 마이닝, 데이터들 간의 상관관계 분석, 미래 예측, 의사결정에 활용됩니다. 주어진 자연수로부터 소인수들을 뽑아내고, 자연수들을 거듭제곱형태의 소인수로 분해 (변형)하고, 데이터 프레임 형태로 다시 변환한 다음에, 주어진 자연수들의 최대공약수를 구하는 과정은 위에서 설명한 ETL 개념과 유사하다고 볼 수 있습니다. 이 책의 소스코드들은 중등 수학 1에서 소개되는 개념들을 조금이라도 충실히 따라가면서 코드 한 줄 한 줄에서 조금이라도 더 많은 것을 경험하기 위해 의도적으로 비효율적으로 작성된 부분이 많습니다. 데이터 과학자들이 분석 과정에서 최대공약수를 구할 일이 있을때 반드시 이 책에서 소개된 소스코드대로 소인수분해를 이용하여 풀어내지는 않습니다. 좀더 빠르고 효율적인 다양한 방법이 존재하기 때문입니다 (Euclid’s algorithm, Lehmer’s GCD algorithm, Binary GCD algorithm 등). 우리 모두가 전문적인 데이터 과학자 (data scientist)가 될 필요는 없습니다. 하지만 우리는 데이터가 넘쳐 나는 시대에 살고 있기 때문에 여러분이 데이터를 집계하고 분석하고 이해할 수 있는 능력 (data literacy)을 갖춘다면 어느 분야에서 든 그 능력을 활용할 수 있게 될 것입니다. 다시 원래 내용으로 돌아가서, 위에서 살펴본 최대공약수 구하는 과정과 비슷한 단계 (네 단계)를 거쳐 최소공배수를 구해보겠습니다. 먼저, 주어진 자연수들의 거듭제곱 형태로 소인수분해한 후, 데이터 프레임 형태로 변환합니다. 위에서 이미 생성한 pf_df, p_df, r_df데이터 프레임 로직을 그대로 사용합니다, #library(rlist) #library(dplyr) N &lt;- c(18, 42, 84) #주어진 자연수들 벡터 baselist &lt;- list() #자연수들의 소인수 밑을 저장할 리스트 exponentlist &lt;- list() #자연수들의 소인수 지수를 저장할 리스트 for (i in 1:length(N)) { #벡터 값의 개수만큼 반복 수행하면서 x &lt;- myFactorize(N[i]) #각 자연수 소인수분해 xe &lt;- rle(x) #인코딩 baselist &lt;- list.append(baselist, xe[[2]]) #rle의 value exponentlist &lt;- list.append(exponentlist, xe[[1]]) #rle의 count } P &lt;- baselist %&gt;% unlist() %&gt;% unique() %&gt;% sort() #library(dplyr) pf_df &lt;- data.frame() #pf 데이터 프레임 생성 #### prime factorization 데이터 프레임 로직 시작 ##################### for (i in 1:length(N)) { #첫 번째 자연수부터… base &lt;- baselist[[i]] #첫 번째 자연수의 소인수 밑 값 벡터 exponent &lt;- exponentlist[[i]] #첫 번째 자연수의 소인수 지수 값 벡터 #각 자연수별로 row를 만들어 rbind로 데이터 프레임을 행을 추가 r = c() #빈 row 벡터 생성 for (j in 1:length(P)) { #각 자연수의 첫 번째 소인수 밑 값부터… nth &lt;- which(P[j] == base)[1] #소인수 값으로 소인수 밑 값 벡터에서의 위치 파악 if (!is.na(nth)) { r = c(r, base[nth], exponent[nth]) #해당 소인수 밑과 지수 부분 값 추가 } else r = c(r, NA, NA) #해당 소인수 밑과 지수 부분 값 없음 (not assigned, NA) } pf_df &lt;- rbind(pf_df, r) #데이터 프레임에 행 추가 } #pf 데이터 프레임 컬럼명 설정 colnames(pf_df) &lt;- paste0(rep(c(&#39;P&#39;, &#39;r&#39;), times=length(P)), rep(1:length(P), each=2)) #### prime factorization 데이터 프레임 로직 종료 ##################### p_df &lt;- pf_df %&gt;% #dplyr 패키지의 select() 함수 사용 select(starts_with(&quot;P&quot;)) #밑수 P1, P2, P3 컬럼만 선택 r_df &lt;- pf_df %&gt;% #dplyr 패키지의 select() 함수 사용 select(starts_with(&quot;r&quot;)) #지수 r1, r2, r3 컬럼만 선택 print(p_df) ## P1 P2 P3 ## 1 2 3 NA ## 2 2 3 7 ## 3 2 3 7 print(r_df) ## r1 r2 r3 ## 1 1 2 NA ## 2 1 1 1 ## 3 2 1 1 첫 번째 단계에서 구해진 밑 컬럼만 가지는 데이터 프레임 p_df에 존재하는 모든 밑들을 선택합니다. p_df2 &lt;- p_df %&gt;% summarise_if(is.numeric, max, na.rm = TRUE) #각 컬럼별 값이 전부 같음 p_v &lt;- as.vector(p_df2[1,]) r_df에서 각 지수 컬럼 중에서 가장 큰 지수를 선택합니다. r_df2 &lt;- r_df %&gt;% summarise_if(is.numeric, max, na.rm = TRUE) r_v &lt;- as.vector(r_df2[1,]) 선택된 밑 (p_v벡터) 의 선택된 지수 (r_v벡터)를 다시 거듭제곱 형태로 변환하고 모두 곱한다. base &lt;- p_v exponent &lt;- r_v xs &lt;- &#39;&#39; for (i in 1:length(base)) { xs &lt;- paste0(xs, base[i], &#39;^&#39;, exponent[i]) # 마지막 소인수 뒤에 &quot;*&quot;를 붙이지 않기 위한 조건문 if (i != length(base)) xs &lt;- paste0(xs, &quot; * &quot;) } xexpr &lt;- parse(text=xs) #문자열을 표현식으로 변환 x &lt;- eval(xexpr) #표현식을 이용하여 실제 계산 수행 print(paste(&quot;주어진 자연수&quot;, toString(N), &quot;들의 최소공배수:&quot;, xs, &quot;=&quot;, x)) ## [1] &quot;주어진 자연수 18, 42, 84 들의 최소공배수: 2^2 * 3^2 * 7^1 = 252&quot; 지금까지 2.1절에서는 자연수에 대하여 다루어 보았습니다. 소수와 합성수, 합성수의 소인수분해, 소인수분해를 이용한 최대공약수와 최소공배수 구하는 방법에 대하여 살펴보았습니다. 그 과정에서 다양한 벡터, 리스트, 데이터 프레임, 반복문, 조건문, 연산자, 함수들을 사용하고 만들어 보았습니다. 이제 좀 더 확장된 수의 개념인 정수와 유리수에 대하여 알아봅시다. 2.2 정수와 유리수 정수와 유리수의 정의와 대소 관계, 그리고 두 수 간의 사칙연산 (덧셈, 뺄셈, 곱셈, 나눗셈)에 대하여 알아봅시다. 2.2.1 정수와 유리수의 뜻과 대소 관계 우리가 지구 상에서 접할 수 있는 가장 거대한 물체는 지구 그 자체입니다. 물은 위에서 아래로 흐르기 때문에, 지구의 표면 (지표면, Earth’s surface)이 높으면 산이 되고 낮으면 강, 호수, 바다가 됩니다. 지표면의 \\(70 \\%\\) 이상을 바다가 뒤덮고 있으며 지구에 있는 \\(14\\)억\\(km^3\\)의 물 가운데 \\(97.5 \\%\\)가 바닷물입니다. 이렇기 때문에 지구 상에 존재하는 대부분의 물이 모여있는 바닷물의 해수면을 기준으로 높고 낮음을 측정합니다. 한반도에서 가장 높은 산은 한반도의 기본 산줄기이자 우리 민족 고유의 지리 인식체계인 백두대간의 시작점인 백두산 (해발 약 \\(2750m\\))과 제주도에 위치한 한라산 (해발 약 \\(1950m\\))이 대표적입니다. 한반도 인근에서 가장 깊은 바다는 동해 울릉도 북단에 위치한 우산해곡 (해저 \\(2985m\\))입니다. 백두산과 한라산은 해수면 (\\(0m\\))을 기준으로 위쪽에 위치해 있고 우산해곡은 해수면을 기준으로 아래쪽에 위치하기 때문에, \\(2750\\), \\(1950\\), \\(2985\\)간의 크고 작음은 비교하기 위해서는 각 숫자가 나타내는 높이의 방향성을 고려해주어야만 합니다. 이와 같이 두 개의 숫자가 반대 방향의 높이 값일 경우, 산의 높이는 양의 부호 (\\(+\\))를 이용하여 양수 (한라산 \\(+1950m\\))로 해곡의 높이는 음의 부호(\\(-\\))를 이용하여 음수 (우산해곡 \\(-2985m\\))로 표현합니다. 양수 (자연수)의 경우 양의 부호를 생략하고 사용하기도 합니다. 그림 2.4는 한반도 주변 지역의 지표면 높이 (고도, elevation)정보를 표현한 것으로 그림이 포함하는 지역에서 높이가 가장 높은 값 (짙은 빨간색)은 \\(2700\\) 정도이고 가장 낮은 값 (짙은 파란색)은 \\(-3600\\) 정도입니다. 그림 2.4: 한반도 주변의 높이 (고도) 정보 위의 한반도 고도정보 그림을 만들기 위하여 ggplot2, FRK, elevatr, rasterVis등의 패키지들이 사용되었고 여섯 단계를 거쳤습니다. 아래의 단계 별 코드들은 패키지들이 어떻게 사용되는 지를 보여주기 위한 것이기 때문에 세부적인 코드 한 줄 한 줄을 전부 이해하려고 하지 말고 단계 별 흐름에 집중해 보세요. 데이터를 가져오고, 변환하고, 시각화하는데 필요한 패키지들을 로딩합니다. #install.packages(&quot;ggplot2&quot;) library(ggplot2) #install.packages(&quot;mapproj&quot;) library(mapproj) #install.packages(&quot;rgdal&quot;) library(rgdal) #install.packages(&quot;sp&quot;) library(sp) #install.packages(&quot;FRK&quot;) library(FRK) #install.packages(&quot;raster&quot;) library(raster) #install.packages(&quot;elevatr&quot;) library(elevatr) #install.packages(&quot;rasterVis&quot;) library(rasterVis) ggplot2패키지의 map_data()함수를 이용하여 한반도 경위도 좌표를 가진 데이터 프레임을 생성합니다. ggplot()의 mapping 입력값에 aes()함수가 쓰이는데, 이는 데이터 프레임의 컬럼 벡터들과 그래프의 시각적 요소들 (aesthetics)을 \\(1:1\\)로 연결 (connecting, 매핑, mapping, 매칭, matching)시켜 그래프로 표현하기 위해서 입니다. 아래와 같이 ggplot()에서 aes(x = long, y = lat, group = group)로 매핑되었기 때문에 geom_polygon()와 같은 하위 그래프 요소 (geoms, geom_)에 자동으로 반영됩니다. korea_df &lt;- map_data(map = &#39;world&#39;, region = c(&#39;South Korea&#39;, &#39;North Korea&#39;)) ggplot(data = korea_df, mapping = aes(x = long, y = lat, group = group)) + geom_polygon(fill = &#39;white&#39;, color = &#39;black&#39;) + coord_map() map_data()함수를 이용해서 생성한 korea_df데이터 프레임에는 독도 정보가 누락되어 있어서 독도 서도와 동도의 중간 지점 좌표를 기준으로 작은 사각형을 하나 그려서 데이터 프레임에 추가하였습니다. 제시카는 외동딸 일리노이 시카고이고 독도는 우리 땅입니다. ddlong &lt;- 131.8674 ddlat &lt;- 37.2413 ddd &lt;- 0.004 dokdo_df &lt;- data.frame( long = c(ddlong-ddd, ddlong, ddlong+ddd, ddlong), lat = c(ddlat, ddlat+ddd/2, ddlat, ddlat-ddd/2), group = 14, order = 1001:1004, row.names = 1001:1004, region = &#39;South Korea&#39;, subregion = &#39;Dok Do&#39;) korea_df &lt;- rbind(korea_df, dokdo_df) write.csv(korea_df,&quot;korea_df.csv&quot;, row.names = FALSE) #현재 작업 디렉토리에 데이터 파일 저장 #한번 저장한 후에는 현재 작업 디렉토리에서 데이터 파일 로딩 #korea_df &lt;- read.csv (&quot;korea_df.csv&quot;) #현재 작업 디렉토리에서 데이터 파일 로딩 ggplot(data = korea_df, mapping = aes(x = long, y = lat, group = group)) + geom_polygon(fill = &#39;white&#39;, color = &#39;black&#39;) + coord_map() elevatr패키지의 get_elev_raster()함수에 원하는 지역을 입력하면 해당 지역의 고도 데이터를 가져올 수 있습니다. 해당 지역 정보는 공간 다각형 형태로 제공되어야 하기 때문에, FRK패키지의 df_to_SpatialPolygons()함수를 이용하여 korea_df데이터 프레임을 korea_sp 공간 다각형으로 변환합니다. proj &lt;- CRS(&quot;+init=epsg:4326&quot;) #경위도 좌표계로 설정 korea_sp &lt;- df_to_SpatialPolygons(korea_df, &quot;group&quot;, c(&quot;long&quot;,&quot;lat&quot;), proj) korea_sp &lt;- spTransform(korea_sp, proj) saveRDS(korea_sp, &#39;korea_sp.rds&#39;) #한번 저장한 후에는 현재 작업 디렉토리에서 데이터 파일 로딩 #korea_sp &lt;- readRDS(file = &quot;korea_sp.rds&quot;) elevatr패키지의 get_elev_raster()함수의 입력값으로 korea_sp 공간 다각형을 입력하여 한반도 지역의 고도 데이터를 가져옵니다. 고도 데이터를 다운로드한 후, 로컬 폴더에 “korea_elevation.grd”라는 이름으로 저장합니다. elevation &lt;- get_elev_raster(korea_sp, z = 8) #데이터 다운로드 writeRaster(elevation, filename=&quot;korea_elevation.grd&quot;, format=&quot;raster&quot;,overwrite=TRUE) #현재 작업 디렉토리에 데이터 파일 저장 #한번 저장한 후에는 현재 작업 디렉토리에서 데이터 파일 로딩 #elevation &lt;- raster(&quot;korea_elevation.grd&quot;) rasterVis패키지를 이용하여 한반도 지역 고도와 경계 정보를 시각화합니다. my.at &lt;- c(seq(-3800, -100, 100), seq(-80, 80, 10), seq(100, 2700, 70)) my.at2= seq(-4000, 3000, 500) myColorkey &lt;- list(at=my.at, labels=list(at=my.at2)) plt &lt;- levelplot(elevation, par.settings=BuRdTheme, at = my.at, colorkey=myColorkey, margin=F) plt + layer(sp.polygons(korea_sp, col=&quot;grey40&quot;, alpha=0.5)) 위에서 한라산 (+), 해수면 (0), 우산해곡 (-)의 높이 뿐만 아니라 한반도 주변의 높이 (고도)정보를 시각화 해보면서 정수 (양수, \\(0\\), 음수)에 대하여 살펴보았습니다. 이제 정수와 정수 사이에 존재하는 정수가 아닌 유리수 (rational number)에 대해서 알아보겠습니다. 숫자 중 정수가 아니면서 분수 (fraction) 또는 비율 (ratio, proportion)로 표현 가능한 소수 (decimal)를 유리수라고 합니다. \\(pi\\)나 \\(\\sqrt{2}\\)처럼 반복되는 패턴 없이 무한이 계속되는 무한 소수의 경우, 분수나 비율로 표현할 수 없기 때문에 유리수에 속하지 않습니다. 무한소수 중에서 같은 값이 계속 반복되어 분수로 표현 가능한 순환 소수 (\\(0.33333\\)… = \\(\\frac{1}{3}\\))나 유한한 소수 (\\(0.2\\), \\(0.3\\))와 같이 분수 또는 비율로 표현 가능한 소수 만을 유리수로 분류합니다. 분수 \\(\\frac{1}{3}\\)과 순환소수 \\(0.33333\\)…은 같은 값입니다. 하지만 두 값에 \\(3\\)을 곱해보면 조금 이상해 집니다. 한쪽 값은 \\(0.99999\\)…가 되고 다른 한쪽 값은 \\(1\\)이 됩니다. 같은 값에 똑같이 \\(3\\)을 곱해주었기 때문에 \\(0.99999\\)…\\(=1\\)이 성립되어야 하지만, 아무리 생각해도 \\(0.99999\\)…와 \\(1\\)이 같아 보이지는 않습니다. 이러한 애매모호한 개념들은 고등 수학에서 다루게 되므로 그냥 쿨하게 패스합시다. 다시 본론으로 돌아와서, 정수와 유리수를 선상에 표시하면 숫자들 간의 크고 작음을 쉽게 이해할 수 있습니다. 그림 2.5는 정수 \\(-3\\), \\(-2\\), \\(-1\\), \\(0\\), \\(1\\), \\(2\\), \\(3\\)과 유리수 \\(-2.5\\), \\(-\\frac{3}{4}\\), \\(\\frac{1}{4}\\), \\(2.4\\)를 수의 직선 (number line)상에 표현해 본 것입니다. 첫 번째 선에는 정수 만을 나타내서 정수 간의 크고 작음을 표현했고 두 번째 선에는 유리수만 나타내서 유리수 간의 크고 작음을 표현했습니다. 그리고 세 번째 선에는 주어진 정수와 유리수를 모두 한 선상에 표현해서 정수, 유리수 간의 구분 없이 주어진 모든 수들 간의 크고 작음을 직관적으로 비교할 수 있도록 했습니다. 그림 2.5: 정수와 유리수를 수직선 (number lilne)상에 표현 위의 그림의 선들을 그림으로 표현하기 위해서 ggplot2 패키지가 사용되었습니다. 2.1.4절 최대공약수와 최소공배수 부분에서는 데이터 처리 시 소스코드의 가독성을 높히면서도 직관적으로 함수를 사용하면서 효율적으로 작업 할 수 있도록 도와주는 dplyr 패키지의 파이프 연산자 (pipe operator, %&gt;%)에 대해서 알아보았습니다. 이번에는 데이터를 탐색할 때나 분석 결과를 시각화하는 용도로 많이 쓰이는 ggplot2에 대해서 알아봅시다. ggplot함수를 이용하면 다양한 그래프를 생성할 수 있고, +연산자를 통해서 그래프 요소를 하나 하나 설정해 나가는 방식으로 코드를 작성할 수 있습니다. %&gt;%연산자와 +연산자로 대표되는 dplyr 패키지와 ggplot2 패키지는 R 사용자들에게 있어서는 없어서는 안될 중요한 패키지들 입니다. 이 두 가지 패키지와 데이터 읽어오기, 변환하기, 반복문 수행하기, 모델 만들기 등에 필요한 여러 패키지들을 모아놓은 tidyverse패키지를 설치하면 데이터 처리 및 분석의 여러 단계에서 필요한 필수 패키지들을 한번에 설치할 수 있습니다 (그림 2.6). 그림 2.6: dplyr와 ggplot2를 포함하는 tidyverse 패키지 (출처 https://www.tidyverse.org) 아래의 소스코드에서는 선 (number line)상에 정수와 유리수를 표시하여 정수와 유리수들 간의 대소관계를 시각적으로 파악하기 위하여 ggplot함수가 사용되었습니다. +연산자로 그래프 설정을 한 줄 한 줄 추가하는 형태이기 때문에 각 라인의 코드가 무슨 역활을 하는지 명확하지 않으면 특정 라인 까지만 실행하여 결과를 확인하면 도움이 됩니다. 예를 들어, 아래 ggplot()함수 부분 중 세줄 ggplot(…) + annotate(…) + annotate(…)만 실행하면 RStudio의 Plots창에 파란선과 빨간선만 나타납니다. 다만 세 번째 줄 마지막 줄에 있는 +는 빼고 실행하여야 합니다. #1. 그래프와 그래프 요소에 사용할 색상표 생성을 위한 패키지 로딩 library(ggplot2) #ggplot 그래프 생성을 위한 패키지 로딩 #install.packages(&quot;RColorBrewer&quot;) library(RColorBrewer) #그래프 요소에 사용되는 색상표 (컬러 팔레트) 생성을 위한 패키지 #2. 숫자 표현식 문자열 벡터, 숫자 벡터, 숫자 색상 벡터을 각 컬럼으로 하는 데이터 프레임 생성 integerText &lt;- c(&quot;-3&quot;, &quot;-2&quot;, &quot;-1&quot;, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;) #정수 표현식 문자열 벡터 integerColor &lt;- rep(&quot;dimgray&quot;, length(integerText)) #정수 색상 벡터 rationalNumberText &lt;- c(&quot;-2.5&quot;, &quot;-3/4&quot;, &quot;1/4&quot;, &quot;2.4&quot;) #유리수 표현식 문자열 벡터 rationalNumberColr &lt;- rep(&quot;gray&quot;, length(rationalNumberText)) xtext &lt;- c(integerText, rationalNumberText) #숫자 (정수+유리수) 문자열 벡터 xcolor &lt;- c(integerColor, rationalNumberColr) #숫자 색상 벡터 x &lt;- numeric(length(xtext)) xexpr &lt;- parse(text=xtext) #유리수 표현식 벡터 생성 for(i in seq_along(xexpr)) x[i] &lt;- eval(xexpr[[i]]) #표현식 벡터로 부터 숫자 벡터 생성 number_df &lt;- data.frame(xtext=xtext, x=x, xcolor=xcolor) #ggplot에 사용할 데이터 프레임 생성 세 번째 ggplot()부분을 실행한 후에, RStudio의 그래프 정보창 (2.1.2절의 그림 1.1)의 윗부분에 있는 Zoom 버튼을 클릭하면 그래프를 더 큰 화면에서 볼 수 있습니다. #3. ggplot 그래프에서 사용할 데이터 프레임과 컬럼을 설정한 후, 각 그래프 요소 설정은 + 연산자로 한 줄씩 추가 mycolor &lt;- rev(brewer.pal(11, &quot;RdYlBu&quot;)) #그래프의 선 (number line) 색상 정보 ggplot(number_df, aes(x=x, y=0)) + #그래프에 사용할 데이터 프레임과 컬럼 설정 #음수부분 선 (number line) 파란색으로 추가 annotate(&quot;segment&quot;,x=min(x)-0.3,xend=0, y=0, yend=0, size=2, color=mycolor[2]) + #양수부분 선 (number line) 빨간색으로 추가 annotate(&quot;segment&quot;,x=0,xend=max(x)+0.3, y=0, yend=0, size=2, color=mycolor[10]) + #각 정수와 유리수 위치에 원 심볼 추가 geom_point(alpha=1.0, size=7, color=xcolor) + #mycolor2 ) + #각 숫자 원안에 숫자 표현식 추가 geom_text(aes(label = paste0(xtext)), col=&quot;white&quot;, size=3, fontface = &quot;bold&quot;) + #필요 없는 축 정보 등 모두 보이지 않도록 설정 theme_void() 이렇게 양의 유리수와 음의 유리수를 직선상에 표현하는 방법에 대하여 알아보았습니다. 위의 직선 상에 존재하는 두 점 \\(-2.5\\)와 \\(2.4\\)사이의 거리를 구해야 되는 경우, 두 점이 \\(0\\)을 기준으로 반대 방향에 있으므로 각 점과 \\(0\\)까지의 거리를 구한 다음에 합하여서 두 점간의 거리를 구합니다. 이때 각 점의 숫자 부호 (\\(+\\), \\(-\\))에 상관없이 각 점에서 \\(0\\)까지의 거리를 이용하는 데, 이를 절댓값 (absolute number)이라 하고 숫자 양쪽에 \\(|\\) 기호를 붙여서 표현합니다 (예: \\(3\\)의 절댓값 \\(= \\lvert 3 \\rvert\\), \\(8.7\\)의 절댓값 \\(= \\lvert 8.7 \\rvert = 8.7\\), \\(-1.6\\)의 절댓값 \\(= \\lvert -1.6 \\rvert = 1.6\\)). 양의 유리수는 그 값 자체가 절댓값이 되고, 음의 유리수는 부호를 생략한 값이 절댓값이 됩니다. 그림 2.7에 표현된 숫자를 예로 들어 두 수 간의 대소관계를 아래와 같이 정의해 볼 수 있습니다. 양수 &gt; 0, 예: 7 &gt; 0, 2.32 &gt; 0 음수 &lt; 0, 예: -1.6 &lt; 0, -4 &lt; 0 |양수1| &gt; |양수2|이면 양수1 &gt; 양수2, 예: |9.57| &gt; |4|이면 9.57 &gt; 4 |음수1| &gt; |음수2|이면 음수1 &lt; 음수2, 예: |-10| &gt; |-3|이면 -10 &lt; -3 그림 2.7: ggplot을 이용하여 정수와 유리수의 절댓값 크기를 원의 크기와 색상으로 표현 위의 그림을 생성하기 위하여 dplyr패키지의 %&gt;% 연산자와 ggplot2패키지의 +연산자가 동시에 사용되었습니다. 두 연산자 모두 한 줄 한 줄 함수를 추가해가며 세부적인 설정을 해나간다는 공통점이 있습니다. 아래의 소스코드에서는 각 함수의 입력값 세부 내용에는 신경 쓰지 말고 각 함수의 역활에만 파악해보도록 하세요. number_df 데이터 프레임에 mutate()함수로 절댓값 컬럼을 추가로 생성해 줍니다. 그런 다음에, ggplot()에 데이터 프레임과 컬럼을 입력값으로 넘겨주고, ylim()함수로 그래프의 세로축 범위를 설정하고, geom_point()로 각 유리수의 위치를 원형으로 그래프에 추가하고, geom_text()함수로 유리수 숫자를 텍스트 형태로 그래프에 추가합니다. 마지막으로, scale_fill_distiller()함수와 scale_size_continuous()함수로 그래프에 표현된 원형 심볼의 크기와 색상을 설정합니다. n = 40 number &lt;- runif(n, min = -10, 10) #-10과 10 사이에 존재하는 임의의 유리수 n개 벡터 생성 ith &lt;- 1:n #각 유리수의 순번 벡터 생성 rows &lt;- sample(n, n/3) #전체 유리수 중 1/3만큼 임의로 뽑아서 number[c(rows)] &lt;- as.integer(number[c(rows)]) #정수로 변형 number_df &lt;- data.frame(value=number, lat=ith) #데이터 프레임 생성 #dplyr의 %&gt;% 연산자와 ggplot의 + 연산자 동시 사용 number_df %&gt;% mutate(abs = abs(value)) %&gt;% #데이터 프레임에 절댓값 컬럼 추가 ggplot(aes(lat, value)) + ylim(-10, 10) + geom_point(aes(size = abs, fill = abs), shape = 21, alpha = 0.8) + geom_text(aes(label = round(value, 2), vjust = -1.1 - abs/8), col=&quot;dimgray&quot;, size=3, position = position_dodge(width = 1) ) + scale_fill_distiller(guide = &quot;legend&quot;, palette=&quot;OrRd&quot;, direction=1) + scale_size_continuous(range = c(1, 10)) 위에서 직선 상에 존재하는 두 점 \\(-2.5\\)와 \\(2.4\\)간의 거리를 계산하기 위하여 각각의 절댓값을 구한 다음에 두 절댓값을 합하는 방식을 취했었습니다 (\\(\\lvert -2.5 \\rvert + \\lvert 2.4 \\rvert = 2.5 + 2.4 = 4.9\\)). 하지만, 두 점 사이의 거리는 두 점 사이의 거리 차이이기 때문에 한 수를 다른 한 수로 뺀 다음에 절댓값을 취하는 방식으로 더 쉽고 빠르게 구할 수 있습니다. \\(\\lvert -2.5 \\rvert + \\lvert 2.4 \\rvert = 2.5 + 2.4 = 4.9\\) \\(\\lvert (2.4) - (-2.5) \\rvert = \\lvert 2.4 + 2.5 \\rvert = \\lvert 4.9 \\rvert = 4.9\\) \\(\\lvert (-2.5) - (2.4) \\rvert = \\lvert -2.5 - 2.4 \\rvert = \\lvert -4.9 \\rvert = 4.9\\) 위와 같은 경우 숫자 간의 연산이 필요하고, 여러 개의 수에 대한 사칙연산 (덧셈, 뺄셈, 곱셈, 나눗셈)이 섞여있는 경우에는 수의 순서를 바꾸거나 (교환법칙), 두 수의 먼저 연산한 후 (결합법칙) 그 결과값을 다른 수와 연산하거나, 괄호 안의 값을 풀어서 세부 연산을 나누어하거나 (분배법칙)하는 방식으로 풀어나가게 됩니다. 사칙연산과 교환법칙, 결합법칙, 분배법칙 및 사칙연산이 섞여있는 식의 계산 순서 등은 이 책에서는 다루지 않도록 하겠습니다. 그 대신 지금까지 배운 유리수 구분 체계를 좀 더 다양한 그래프로 표현해보도록 하겠습니다. 2.2.2 자연수, 정수, 유리수의 관계 시각화 위에서 ggplot을 이용한 그래프 표현을 다룬 김에 자연수, 정수, 유리수의 계층 관계를 트리 (tree) 구조 그래프와 원형 포함 관계 (써클 팩, circle pack) 그래프로 표현해 보도록 하겠습니다. 자연수, 정수, 유리수와 같이 상위 계층 (레벨, level)과 하위 계층으로 표현 가능한 계층형 (레벨, level) 포함 관계에 있는 데이터를 그래프로 표현해 보겠습니다. 표 2.1과 같이 유리수, 정수, 자연수의 상위-하위 레벨 포함 관계를 각 컬럼 속성으로 가지는 데이터가 있다고 생각해 봅시다. 이러한 데이터의 레벨을 컬럼으로 가지는 데이터 프레임을 생성하면 부모 노드 (parent node, root node)가 0개 이상의 자식 노드 (child node)를 가지고 그 자식들은 그 밑 자식 노드를 가지는 계층형 트리 (tree)구조로 표현할 수 있습니다 (그림 2.8). 표 2.1: 컬럼을 활용한 유리수 계층 관계 표현 level1 level2 level3 유리수 정수 양의 정수 유리수 정수 0 유리수 정수 음의 정수 유리수 정수가 아닌 유리수 NA 아래의 소스코드를 이용하면 표 2.1의 데이터를 데이터 프레임으로 변형하고 collapsibleTree()함수를 이용하여 트리 구조 형태의 그래프로 표현해 볼 수 있습니다 (그림 2.8). #패키지 로딩 #install.packages(&quot;collapsibleTree&quot;) library(collapsibleTree) library(colorspace) #자연수, 정수, 유리수 레벨별 컬럼을 가지는 데이터 프레임 생성 number_df &lt;- data.frame(level1=&quot;유리수&quot;, level2=c(rep(&quot;정수&quot;, 3), &quot;정수가 아닌 유리수&quot;), level3=c(&quot;양의 정수 (자연수)&quot;, &quot;0&quot;, &quot;음의 정수&quot;, NA )) #컬럼 레벨을 트리구조로 시각화 collapsibleTree(number_df, root = NULL, hierarchy = c(&quot;level1&quot;, &quot;level2&quot;, &quot;level3&quot;), fill = colorspace::rainbow_hcl(6), nodeSize = &quot;leafCount&quot;, width = 500, collapsed = FALSE) 그림 2.8: collapsibleTree()함수를 이용한 자연수, 정수, 유리수의 관계 표현 위와 같이 표 2.1과 같은 구조로 데이터 프레임을 생성하면 마지막 노드의 레벨이 다르기 때문에 예제 컬럼을 추가하고 싶은 경우 애매한 상황이 생깁니다. 예제 컬럼을 네 번째 컬럼으로 추가할 경우 정수가 아닌 유리수의 예제들은 세 번째 컬럼이 모두 비어있게 됩니다. 세 번째 컬럼이 비어있지 않게 하기 위해 정수가 아닌 유리수의 예제를 세 번째 컬럼에 넣으면, 컬럼별 계층 구조가 깨져 버립니다. 이렇듯, 레벨이 맞지 않아 레벨을 컬럼으로 가지는 데이터 프레임을 생성하기가 애매한 경우 표 2.2와 같이 선후 관계 (from-to) 또는 상하 관계 (top-down)를 중심으로 데이터 프레임을 생성할 수 있습니다. 이러한 방식으로 데이터 프레임을 생성하면 최상위 노드의 부모 노드값을 제외하고 모든 값을 NA없이 입력할 수 있습니다. 데이터의 첫 줄에 정의된 유리수가 가장 최상위 부모 노드이고 별도의 부모 노드를 가지지 않으므로 from컬럼 값이 NA로 입력되어 있습니다.. 표 2.2과 같았다고 생각해 봅시다. 표 2.2: 선후 관계를 활용한 유리수 계층 표현 from to level NA 유리수 1 유리수 정수 2 유리수 정수가 아닌 유리수 3 정수 양의 정수 (자연수) 3 정수 0 3 정수 음의 정수 3 양의 정수 (자연수) +1 example 양의 정수 (자연수) +2 example 양의 정수 (자연수) 3 example 음의 정수 -1 example 음의 정수 -2 example 음의 정수 -3 example 정수가 아닌 유리수 1/2 example 정수가 아닌 유리수 -2/3 example 정수가 아닌 유리수 0.4 example 정수가 아닌 유리수 -1.5 example 표 2.2의 데이터를 데이터 프레임으로 변형하고 이러한 형태로 저장된 데이터 프레임을 트리 구조 그래프로 표현하기 위해서 collapsibleTree()함수 대신에 collapsibleTreeNetwork()함수 함수를 이용하여야 합니다. 아래의 소스코드를 이용하면 그림 2.9과 같은 그래프를 그려낼 수 있습니다. #패키지 로딩 library(collapsibleTree) library(colorspace) #자연수, 정수, 유리수 선후 관계를 이용한 데이터 프레임 생성 number_df &lt;- data.frame( from = c(NA, &quot;유리수&quot;, &quot;유리수&quot;, &quot;정수&quot;, &quot;정수&quot;, &quot;정수&quot;), to = c(&quot;유리수&quot;, &quot;정수&quot;, &quot;정수가 아닌 유리수&quot;, &quot;양의 정수 (자연수)&quot;, &quot;0&quot;, &quot;음의 정수&quot;), mylevel = c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;3&quot;, &quot;3&quot;, &quot;3&quot;), stringsAsFactors=FALSE) #문자형 벡터의 데이터 타입을 factor로 인코딩 하지 않기 #양의 정수, 음의 정수, 유리수 예제 rows 추가 number_df &lt;- rbind (number_df, data.frame( from= c(rep(&quot;양의 정수 (자연수)&quot;, 3), rep(&quot;음의 정수&quot;, 3), rep(&quot;정수가 아닌 유리수&quot;, 4)), to=c(&quot;+1&quot;, &quot;+2&quot;, &quot;3&quot;, &quot;-1&quot;, &quot;-2&quot;, &quot;-3&quot;, &quot;1/2&quot;, &quot;-2/3&quot;, &quot;0.4&quot;, &quot;-1.5&quot;), mylevel= &quot;example&quot;)) #트리 노드 색상 설정 number_df$color &lt;- number_df$mylevel number_df$color &lt;- as.factor(number_df$color) levels(number_df$color) &lt;- colorspace::rainbow_hcl(4) #각 행의 선후 관계(from-to)를 이용하여 트리구조로 시각화 collapsibleTreeNetwork(number_df, attribute = &quot;mylevel&quot;, fill = &quot;color&quot;, nodeSize = &quot;leafCount&quot;, width = 400, collapsed = FALSE) 그림 2.9: collapsibleTreeNetwork()함수를 이용한 자연수, 정수, 유리수의 관계 표현 위의 트리 구조 그래프는 선후 관계 또는 상하 관계를 강조하는 그래프 표현입니다. 위의 number_df 데이터 프레임과 같이 from, to컬럼을 가지는 구조의 데이터인 경우, 포함 관계를 강조하는 써클팩 (circle pack) 그래프로 표현해 볼 수 있습니다 (그림 2.10) 그림 2.10: circlepackeR()함수를 이용한 자연수, 정수, 유리수의 관계 표현 위의 써클팩 그래프를 생성하기 위해 아래의 소스코드가 사용되었습니다. circlepackeR패키지의 그래프 함수가 요구하는 입력 데이터 형태를 얻기 위하여 데이터 프레임을 데이터 트리로, 데이터 트리를 중첩 구조 데이터로, 중첩 구조 데이터를 데이터 노드로 변형 하는 절차를 거쳤습니다. #install.packages(&quot;circlepackeR&quot;) install.packages(&quot;devtools&quot;) devtools::install_github(&quot;jeromefroe/circlepackeR&quot;) # If needed library(circlepackeR) #install.packages(&quot;data.tree&quot;) library(data.tree) data_edge &lt;- number_df[-c(1) , c(&quot;from&quot;, &quot;to&quot;)] #최상위 노드 데이터 삭제 #선후 관계 from, to컬럼을 가지는 데이터 프레임 -&gt; 데이터 트리 -&gt; 중첩 구조 데이터로 변형 (data.tree 패키지) data_tree &lt;- FromDataFrameNetwork(data_edge) data_nested &lt;- ToDataFrameTree(data_tree, level1 = function(x) x$path[1], level2 = function(x) x$path[2], level3 = function(x) x$path[3], level4 = function(x) x$path[4])[-1,-1] #각 노드의 레벨을 하나의 문자열로 가지는 컬럼 생성 (분수 표현과 겹치지 않는 구분자 사용) data_nested$pathString &lt;- paste(&quot;roots&quot;, data_nested$level1, data_nested$level2, data_nested$level3, data_nested$level4, sep = &quot;|&quot;) #빈 레벨의 값은 노드로 생성할 필요가 없으므로 문자열에서 지움 data_nested$pathString &lt;- gsub(&quot;\\\\|NA&quot;, &quot;&quot;, data_nested$pathString) data_nested$value= 1 #원의 크기 레벨 별로 동일하게 설정 #데이터 노드 생성 후 써클팩으로 표현 data_Node &lt;- as.Node(data_nested, pathDelimiter = &quot;|&quot;, na.rm = TRUE) cp &lt;- circlepackeR(data_Node, size = &quot;value&quot;) cp 이번 장에서는 자연수의 소인수분해, 최대공약수와 최소공배수 구하기, 정수와 유리수의 대소관계 및 절댓값, 정수와 유리수의 연산를 다루면서 벡터, 리스트, 데이터 프레임 등의 데이터 객체들을 알아보고, 반복문, 조건문, 연산자, 함수 등을 활용하여 원하는 로직을 구현하는 방법을 다루었습니다. 뿐만 아니라, 지도 형태, 그래프 형태, 트리 형태, 써글팩 형태 등의 다양한 시각화 방법1을 살펴보았습니다. 이제 3장 문자와 식에 대하여 본격적으로 알아봅시다. R 그래프 갤러리 사이트 (https://www.r-graph-gallery.com)↩ "],
["x-equation.html", "3 문자와 식 3.1 문자의 사용과 식의 계산 3.2 일차식과 일차방정식", " 3 문자와 식 문자를 사용한 식으로 다양한 문제를 간결하고 명확하게 나타내고 문자를 사용한 식과 일차방정식의 풀이에 대하여 알아봅니다. RStudio가 열려 있지 않으면 RStudio를 실행하고 메뉴에서 File &gt;&gt; Open Project…를 클릭하여 이전에 저장한 R 프로젝트 파일인 rmath01.Rproj을 찾아서 선택하고 Open 버튼을 클릭하여 이전에 작업하던 프로젝트 환경을 로딩합니다. 파일탐색기나 파인더에서 rmath01.Rproj 파일을 찾아서 더블 클릭하여도 RStudio가 실행되면서 작업하던 프로젝트 환경이 로딩됩니다. 프로젝트 환경이 로딩된 후에 RStudio 콘솔창에 getwd()를 실행하여 작업 환경이 제대로 로딩되었는지 확인합니다. RStudio 환경이 잘 로딩되었으면, 이제 본격적으로 시작해 봅시다. 3.1 문자의 사용과 식의 계산 문자를 사용한 식을 어떻게 만들고 어떻게 풀어나가는 지에 대하여 알아보고, 일차식에 대하여 살펴봅니다. 2장 수와 연산에서 이미 살펴본 것과 같이, 자연수는 아래의 식과 같이 소수 (또는 소수의 거듭제곱)의 곱 형태로 분해될 수 있습니다. \\[23 = {23}^{1}\\] \\[24 = {2}^{3} \\times {3}^{1}\\] \\[252 = {2}^{2} \\times {3}^{2} \\times {7}^{1}\\] \\[N = {P_1}^{r_1} \\times {P_2}^{r_2} \\times ⋯ \\times {P_n}^{r_n}\\] \\(N\\)은 자연수, \\({P_1}, {P_2}, ⋯, {P_n}\\)은 소인수 밑, \\({r_1}, {r_2}, ⋯, {r_n}\\)은 거듭제곱의 지수를 나타냅니다. 소수 \\(23\\)을 위의 식에 대입하면 \\(23 = {23}^{1}\\) 형태가 되므로, \\(N=23\\), \\(n=1\\), \\({P_1}=23\\), \\({r_1}=1\\)이 됩니다. 합성수 \\(24\\)를 위의 식에 대입하면 \\(24 = {2}^{3} \\times {3}^{1}\\) 형태가 되므로, \\(N=24\\), \\(n=2\\), \\({P_1}=2\\), \\({r_1}=3\\), \\({P_2}=3\\), \\({r_2}=1\\)이 됩니다. 이와 같이 문자를 이용하면 숫자들 간의 관계를 하나의 간결한 식으로 나타낼 수 있으며, 자연수의 소인수분해는 \\({P_1}, {P_2}, ⋯, {P_n}\\)과 \\({r_1}, {r_2}, ⋯, {r_n}\\)을 찾아가는 과정입니다. 소인수분해 식 뿐만 아니라 다양한 사칙연산을 활용하여 숫자들 간의 관계를 아래와 같이 문자와 식으로 표현할 수 있습니다. 밑변이 \\(a\\)이고 높이가 \\(h\\)인 삼각형의 넓이 \\(= \\frac {a \\times h}{2}\\) 현재 연도가 \\(x\\)일 때 20년 후의 연도 \\(= x + 20\\) 100개의 연필 중 \\(x\\)개 사용한 후 남은 연필의 개수 \\(= 100 - x\\) 유리수 \\(x\\)의 황금비율 \\(= 1.618 \\times x\\) 이미 앞에서 다룬 소스코드에서 문자와 식을 많이 다룬 셈이지만 복잡한 형태로 사용된 부분이 많기 때문에, 문자와 식이 소스코드에서 어떻게 사용되는지 간단한 경우를 예로 들어서 다시 한번 살펴보겠습니다. y &lt;- 1.618 * x #식이 성립하기 위해서는 먼저 x값을 입력해야 함 (임의 입력 후 추후 수정 가능) ## Error: object &#39;x&#39; not found x &lt;- 3 #자연수 3을 x라고 하고 y &lt;- 1.618 * x #y값 구하는 식을 작성한 후, y #y값 확인 ## [1] 4.854 x &lt;- c(1,2,3,4,5) #자연수 1,2,3,4,5를 가지는 벡터를 x라 하고 y &lt;- 1.618 * x #y값 구하는 식을 작성한 후, y #y값 확인 ## [1] 1.618 3.236 4.854 6.472 8.090 n &lt;-20 #20개 숫자 생성을 위해 20을 n이라 하고 a &lt;- sample(1:10, n, replace=T) #n개 임의의 자연수 벡터 a를 생성 (replace=T, 숫자 중복 허용) b &lt;- sample(1:10, n, replace=T) #n개 임의의 자연수 벡터 b를 생성 (replace=T, 숫자 중복 허용) area &lt;- a*b #a, b를 양 변으로 하는 직사각형 넓이 구하는 식 작성 area #첫 번째 a값과 b값을 곱한 넓이, ..., n번째 a값과 b값을 곱한 넓이 ## [1] 27 9 40 2 42 25 40 42 81 90 50 21 45 63 45 18 72 ## [18] 20 35 80 #mutate() 함수와 %&gt;% 연산자 사용을 위하여 dplyr 패키지 로딩 library(dplyr) #a벡터와 b벡터를 컬럼으로 가지는 데이터 프레임 생성 area_df &lt;- data.frame(a,b) area_df &lt;- area_df %&gt;% #shape 컬럼 추가: 삼각형 &#39;t&#39;, 사각형 &#39;r&#39; 중에서 임의의 값을 가지도록 함 mutate(shape=sample(c(&#39;t&#39;, &#39;r&#39;), n, replace=T)) %&gt;% #area 컬럼 추가: 사각형 (shape==&#39;r&#39;)이면 a*b, 사각형이 아니면 a*b/2로 계산 mutate(area=ifelse(shape==&#39;r&#39;, a*b, a*b/2)) #area_df$area #넓이값 확인 area_df[ ,&quot;area&quot;] #넓이값 확인 ## [1] 27.0 4.5 20.0 2.0 21.0 12.5 20.0 21.0 81.0 45.0 ## [11] 25.0 10.5 22.5 63.0 45.0 9.0 72.0 20.0 35.0 80.0 R에서는 문자 (변수)에 숫자를 대입할 때, 하나의 숫자를 대입할 수도 있고 숫자 벡터를 대입할 수도 있습니다. 물론 문자나 문자열 (단어나 문장)을 변수에 대입할 수도 있습니다. 변수에 숫자를 대입하면 변수를 사용한 식의 결과도 숫자로, 변수에 벡터를 대입하면 변수를 사용한 식의 결과도 벡터가 됩니다. 지금까지 문자를 사용한 식을 만들고 문자에 숫자를 대입하여 식의 값을 소스코드에서 어떻게 구해내는지 알아보았습니다. 문자 (변수)를 사용한 식의 계산에 초점을 맞추어, 위에서 언급한 숫자들 간의 관계 중에서 황금비율 (golden ratio, phi, \\(\\phi\\))에 대해서 조금 더 깊이 알아보도록 하겠습니다. 황금비율은 무엇인지, 황금비율을 가지는 숫자는 어떻게 찾아내고 시각화할 수 있는지 살펴봅시다. 황금비율은 수학적으로 가장 아름답다고 여겨지는 비율로 약 \\(1:1.618\\)로 표현됩니다. 그림 3.1에서와 같이 두 수가 \\(a &gt; b &gt; 0\\)을 만족하고 \\(\\frac {a+b}{a} = \\frac {a}{b}\\)의 관계를 가지면 두 수 \\(a\\), \\(b\\)는 황금비율 (\\(a=1.618 \\times b\\))관계에 있다고 정의합니다. 그림 3.1: 두 선의 두 직사각형의 황금비율 관계 (출처 https://en.wikipedia.org/wiki/Golden_ratio) 이 황금비율은 인체, 자연, 사진, 건축, 미술 등 모든 분야에서 찾아 볼 수 있습니다. 그림 3.2은 그리스 파르테논 (Parthenon) 신전, 레오나르도 다 빈치 (Leonardo da Vinci)가 그린 모나리자 (Mona Lisa), 현대의 사진 작품에서 발견되는 황금비율의 사례들을 보여줍니다. 그림 3.2: 건축물, 미술품, 사진 작품에서 찾아볼 수 있는 황금비율 (출처 https://www.geogebra.org/m/nmuaSXrK) 황금비율을 가지는 자연수들은 어떻게 찾을수 있을까요? \\(\\frac {a+b}{a} = \\frac {a}{b}\\)의 관계를 만족하는 두 자연수로 \\(55\\), \\(34\\)가 있습니다. \\(\\frac {55+34}{55} = 1.618\\)이고 \\(\\frac {55}{34} = 1.618\\)이기 때문에 황금비율 관계에 있습니다. \\(55+34\\)로 얻을 수 있는 \\(89\\)와 \\(55\\)도 황금비율이고 \\(89+55\\)로 얻을 수 있는 \\(144\\)와 \\(89\\)도 황금비율의 관계에 있습니다. \\[34{,} \\; 55{,} \\; 89{,} \\; 144{,} \\; \\dots\\] 이런 식으로 이전 두 숫자의 합으로 표현되는 무한히 진행되는 자연수를 얻어낼 수 있으며, 이러한 방법은 고대 인도인들에 의해 처음 고안되었습니다. 인도 밖에서는 이탈리아 수학자인 피보나치 (Fibonacci, R. 1170~1250)가 \\(1202\\)년에 출간한 수학책에서 처음 소개되었기 때문에, 이러한 숫자들을 피보나치의 수 (Fibonacci numbers)라고 부릅니다. 피보나치의 수는 아래와 같이 \\(1\\), \\(1\\)로 부터 시작하여 이전 두 숫자의 합인 \\(1+1=2\\), \\(1+2=3\\), \\(2+3=5\\), \\(3+5=8\\),…로 이어집니다. \\[1 {,} \\; 1 {,} \\; 2{,} \\; 3{,} \\; 5{,} \\; 8{,} \\; 13{,} \\; 21{,} \\; 34{,} \\; 55{,} \\; 89{,} \\; 144{,} \\; \\dots\\] 피보나치는 이러한 숫자들을 토끼의 개체 수 증가를 예로 들어 설명하였습니다. 1) 한 쌍의 아기 토끼는 한 달 후 한 쌍의 어른 토끼가 됩니다. 2) 한 쌍의 어른 토끼는 한 달에 한번 한 쌍의 아기 토끼를 낳습니다. 3) 토끼들은 죽지 않습니다. 이 세가지 조건이 주어지면 토끼의 개체 수는 점점 증가합니다. 태어난 한 쌍의 아기 토끼는 한 달 후 어른 토끼가 되고 그 다음 달부터 한 달에 한번 한 쌍의 아기 토끼를 낳습니다. 아기 토끼 한 쌍에서 시작해서 한 달 후에는 어른 토끼 한 쌍이 되고, 두 달 후에는 어른 토끼 한 쌍과 아기 토끼 한 쌍이, 다섯 달 후에는 총 여덟 쌍의 토끼가 됩니다 (그림 3.3). 그림 3.3: 토끼 개체 수를 이용한 피보나치 수의 설명 (출처 https://en.wikipedia.org/wiki/Fibonacci_number) 20개의 피보나치 수를 소스코드로 구해보겠습니다. 처음에는 \\(1\\), \\(1\\)로 시작하고 3번째 수부터는 이전 두 수의 합 (두 수를 수식의 문자 (변수)에 대입하여 계산)으로 구합니다. len &lt;- 20 #생성할 피보나치 수의 개수 설정 term &lt;- c(1:len) #첫 번째 부터 스무 번째까지 순서를 매기는 벡터 생성 fibval &lt;- numeric(len) #20개의 피보나치 수를 가지는 벡터 생성 (초기값 0, 0을 20개 가지는 벡터) fibval[1] &lt;- 1 ##첫 번째 피보나치 수에 1을 대입 fibval[2] &lt;- 1 #두 번째 피보나치 수에 1을 대입 for (i in 3:len) { #세 번째 피보나치 수 부터 20번째 피보나치 수까지 이전 두 수를 수식에 대입 fibval[i] &lt;- fibval[i-1] + fibval[i-2] } print(fibval) #20개의 피보나치 수 계산 결과 확인 ## [1] 1 1 2 3 5 8 13 21 34 55 ## [11] 89 144 233 377 610 987 1597 2584 4181 6765 아래의 소스코드는 fibval벡터에 저장되어있는 \\(20\\)개의 피보나치 수의 크기 증가 패턴을 그래프로 표현한 것입니다. 열여덟번째 피보나치 수는 \\(2000\\)보다 큰 값을, 열아홉 번째 피보나치 수는 \\(4000\\)보다 큰 값을, 스무 번째 피보나치 수는 \\(6000\\)보다 큰 값을 가집니다. 피보나치 수는 이전 수의 \\(1.618\\)배로 증가하기 때문에 뒤로 갈수록 수의 증가 폭이 커지게 됩니다 (그림 3.4). library(ggplot2) fib_df &lt;- data.frame(term=1:len, val=fibval) ggplot(fib_df, aes(x=term, y=val)) + geom_point() + geom_line(color=&#39;dimgray&#39;) 그림 3.4: 피보나치 수의 증가 패턴 이렇게 구해진 피보나치 수를 이용해서 각 수의 이전 숫자와의 비율도 손쉽게 계산해 볼 수 있습니다. 첫 번째 수는 이전 수가 존재하지 않기 때문에 아래 소스코드와 같이 두 번째 수부터 for루프를 이용하여 각 수의 비율을 구해냅니다. 이 또한 문자를 사용한 식에 문자 대신 수를 대입하여 식의 값을 구하는 과정을 거칩니다. fibratio &lt;- numeric(len-1) fibratio[1] &lt;- NA for (i in 2:(len)) { fibratio[i] &lt;- fibval[i]/fibval[i-1] } fib_ratio_df &lt;- data.frame(term=1:length(fibratio), val=fibratio) ggplot(fib_ratio_df, aes(x=term, y=val)) + geom_point(color=ifelse(round(fibratio,3) == 1.618, &#39;blue&#39;, &#39;red&#39;) ) + geom_line(color=&#39;dimgray&#39;) + ylim(0, 4) + theme(legend.position = &quot;none&quot;) 구해진 비율을 그래프로 나타내면 그림 3.5와 같습니다. 비율의 수치가 오르락 내리락 하다가 열 번째 수부터 비율이 일정하게 나타납니다. 그림 3.5: 각 피보나치 수의 증가 비율 구해진 피보나치 수의 비율 중 마지막 수가 가장 황금비율에 가깝다고 보고 스무 번째 수의 비율을 확인해 보면 다음과 같습니다. ## 벡터의 마지막 값을 가져오는 다양한 방법들 #fibratio[length(fibratio)] #tail(fibratio, n=1) #dplyr::last(fibratio) #fibratio[end(fibratio)[1]] #rev(fibratio)[1] golden_ratio &lt;- fibratio[len-1] #(1+sqrt(5))/2 print(paste0(&#39;황금비율 = &#39;, golden_ratio)) ## [1] &quot;황금비율 = 1.61803405572755&quot; print(paste0(&#39;황금비율 (소숫점 세째자리까지) = &#39;, round(golden_ratio, 3))) #소수점 세째자리 까지만 ## [1] &quot;황금비율 (소숫점 세째자리까지) = 1.618&quot; 이렇게 황금비율에서 피보나치 수를 거쳐 다시 황금비율로 돌아왔습니다. 황금비율을 가지고 그림 3.2에서 파르테논 신전 위에 그려졌던 황금비율 사각형들을 그리는 소스코드를 생성하여 보겠습니다. 여섯 개의 직사각형 양 변의 길이 값을 저장할 x, y벡터를 생성하고 i번째 사각형의 작은 변의 길이를 i-1번째 사각형 큰 변의 길이로, i번째 사각형의 큰 변의 길이는 같은 사각형 작은 변의 \\(1.618\\)배로 설정합니다. 사각형의 두 변 벡터를 가지고 데이터 프레임을 생성한 후, ggplot의 geom_rect함수를 이용하여 사각형을 그립니다. n &lt;- 6 x &lt;- numeric(n) y &lt;- numeric(n) turn &lt;- rep(c(1, 0), length.out = n) x[1] &lt;- 1 y[1] &lt;- x[1] * golden_ratio for (i in 2:n) { if(turn[i] == 1) { x[i] = x[i-1] y[i] = x[i] * golden_ratio } else { y[i] = y[i-1] x[i] = y[i] * golden_ratio } } d=data.frame(x1=0, x2=x, y1=0, y2=y, r=1:n) ggplot(data=d) + scale_x_continuous(name=&quot;x&quot;) + scale_y_continuous(name=&quot;y&quot;) + geom_rect(aes(xmin=x1, xmax=x2, ymin=y1, ymax=y2), fill = &#39;NA&#39;, color = colorspace::rainbow_hcl(n), size= 0.5 + 0.1 * (1:n), alpha= 0.5) + geom_text(aes(x=x1+(x2-x1)/2, y=y1+(y2-y1)/2, label=r), color = colorspace::rainbow_hcl(n), size=3.5, fontface = &quot;bold&quot;) + coord_fixed(ratio = 1) 작은 변의 길이가 \\(1\\)인 첫 번째 피보나치 사각형부터 큰 변의 길이가 \\(1 \\times {1.618}^{6}\\)인 여섯 번째 피보나치 사각형까지를 그래프로 표현하면 그림 3.6과 같습니다. 그래프에 그려진 여섯 개의 사각형들의 배치가 그림 3.2의 그리스 파르테논 신전 위에 그려졌던 황금비율 사각형들과는 다릅니다. 위의 소스코드에는 사각형의 시작점을 한 점으로 일치시켰기 때문입니다. 파르테논 신전 위의 황금비율 사각형들과 같은 배치를 얻으려면 첫 번째 사각형을 기준으로 나선형 구조의 배치가 이루어져야 합니다. 그림 3.6: 피보나치 사각형 아래의 소스코드와 같이 각 사각형의 시작점을 이전 사각형으로 부터의 상대 거리로 계산해서 나선형으로 설정하면 원하는 그림을 얻을 수 있습니다. 아래 소스코드의 #### 피보나치 사각형 (나선형 배치) 로직 시작 ####과 #### 피보나치 사각형 (나선형 배치) 로직 종료 ####사이에 있는 소스코드가 사각형 나선형 배치 로직 부분인데, 이 부분은 이해하기 어려울 수 있습니다. 머리를 싸매고 이해하려 하지 말고 그냥 쿨하게 복사해서 붙여 넣으세요. n &lt;- 6 x1 &lt;- numeric(n) y1 &lt;- numeric(n) x2 &lt;- numeric(n) y2 &lt;- numeric(n) dx &lt;- numeric(n) dy &lt;- numeric(n) turn &lt;- rep(c(1,2,3,4), length.out = n) x2[1] &lt;- 1 y2[1] &lt;- x2[1] * golden_ratio #### 피보나치 사각형 (나선형 배치) 로직 시작 ################ dx[1] &lt;- x2[1] - x1[1] dy[1] &lt;- y2[1] - y1[1] for (i in 2:n) { if(turn[i] %% 2 == 1) { dx[i] = dx[i-1] dy[i] = dx[i] * golden_ratio } else { dy[i] = dy[i-1] dx[i] = dy[i] * golden_ratio } if(turn[i] == 1) { x1[i] &lt;- x1[i-1] y1[i] &lt;- y2[i-1] - dy[i] } else if(turn[i] == 2) { x1[i] &lt;- x2[i-1] - dx[i] y1[i] &lt;- y1[i-1] } else { x1[i] &lt;- x1[i-1] y1[i] &lt;- y1[i-1] } x2[i] &lt;- x1[i] + dx[i] y2[i] &lt;- y1[i] + dy[i] } #### 피보나치 사각형 (나선형 배치) 로직 종료 ################ d=data.frame(x1=x1, x2=x2, y1=y1, y2=y2, r=1:n) saveRDS(d, &#39;Fibonacci_rectangle_df.rds&#39;) #데이터 프레임 저장 #한번 저장한 후에는 현재 작업 디렉토리에서 데이터 파일 로딩 #d &lt;- readRDS(file = &quot;Fibonacci_rectangle_df.rds&quot;) ggplot(d) + scale_x_continuous(name=&quot;x&quot;) + scale_y_continuous(name=&quot;y&quot;) + geom_rect(aes(xmin=x1, xmax=x2, ymin=y1, ymax=y2), fill = &#39;NA&#39;, color = colorspace::rainbow_hcl(n), size= 0.5 + 0.1 * (1:n), alpha=0.5) + geom_text(aes(x=x1+(x2-x1)/2, y=y1+(y2-y1)/2, label=r), color = colorspace::rainbow_hcl(n), size=3.5, fontface = &quot;bold&quot;) + coord_fixed(ratio = 1) 위의 피보나치 사각형 (나선형 배치) 소스코드를 이용하면 3.7과 같이 그리스 파르테논 신전 위에 그려졌던 황금비율 사각형들과는 동일한 피보나치 사각형을 그래프로 그려볼 수 있습니다. 그림 3.7: 피보나치 사각형 (나선형 배치) 지금까지 문자와 식의 표현이 소스코드에 어떻게 적용되는지 알아보았습니다. 소스코드 자체가 변수 선언과 식의 사용, 반복문과 함수 등을 통한 식의 계산을 포함하기 때문에, 문자를 사용한 식과 그 식의 계산은 이 책의 시작부터 별도의 설명 없이 반복적으로 다루어 진 내용이긴 합니다. 하지만, 3.1절에서는 좀 더 간단한 예를 들어서 문자에 숫자를 대입하고 식을 계산하는 소스코드들을 살펴보았습니다. 또한 그 과정에서 황금비율과 피보나치 수에 대해서도 알아보고 그리스 파르테논 신전의 구조와 일치하는 피보나치 사각형도 그려보았습니다. 이제 일차식과 일차방정식의 뜻과 계산 방법에 대하여 알아봅시다. 3.2 일차식과 일차방정식 앞서 살펴본 것처럼 식에서는 문자와 수의 다양한 사칙연산이 가능합니다. 우리가 종이와 연필로 식을 계산할 때는 \\(1.618 \\times x\\)와 같이 숫자와 문자의 곱 형태에서는 곱셈 기호를 생략하고 \\(1.618x\\)로, \\(y ÷ 1.618\\)와 같이 숫자와 문자의 나눗셈 형태에서는 \\(\\frac{y}{1.618}\\)와 같이 분수의 형태로 나타내어 식을 좀 더 간단히 표현합니다. 하지만, 소스코드에서는 \\(1.618x\\)와 같은 곱셈 표현의 생략은 불가능하고 \\(1.618 \\times x\\)는 1.618 * x로 표현하고, \\(y ÷ 1.618\\)과 같은 나눗셈의 표현은 분수와 비슷한 형태인 y / 1.618로 표현합니다. \\(1.618x + 1\\)과 같이 숫자와 문자의 곱 또는 숫자의 합 형태로 표현되는 식의 경우, 합형태를 이루는 부분인 \\(1.618x\\)와 \\(1\\)을 항이라 부르고, \\(1\\)과 같이 숫자로만 이루어진 항을 상수항 (항상 같은 수인 항)이라고 합니다. \\(1.618x\\)과 같이 문자가 포함된 항의 경우, 문자 \\(x\\)와 곱의 관계에 있는 \\(1.618\\)을 \\(x\\)의 계수 (coefficient)라고 합니다. 또한, \\(1.618x + 1\\)과 같이 항이 두 개 이상인 식을 다항식이라 하고 \\(1.618x\\)와 같이 하나의 항으로 이루어진 식을 단항식이라고 합니다. \\(-1.618x +y - 1\\)와 같이 뺄셈이 포함된 세 개의 항을 가진 다항식의 경우 \\((-1.618x) +y + (-1)\\)와 같이 합 형태의 식으로 변환한 다음에 각 항을 설명할 수 있습니다. 이 식의 각 항은 \\(-1.618x\\), \\(y\\), \\(-1\\)이고 상수항은 \\(-1\\)입니다. \\(x\\)의 계수는 \\(-1.618\\)이고 \\(y\\)는 \\(1y\\)이므로 \\(y\\)의 계수는 \\(1\\)입니다. \\(-1.6x^2 +3x - 1\\)식의 첫 항의 경우 \\(x\\)의 거듭제곱 형태로 되어있고 풀어서 쓰면 \\(-1.6 \\times x \\times x\\)와 같이 \\(x\\)가 두 번 곱해진 형태이므로 첫 항의 차수는 \\(2\\)입니다. 식에서 문자가 포함된 항들 중 가장 차수가 큰 항의 계수가 \\(2\\)인 식을 이차식이라고 하고, 식에서 문자가 포함된 항의 차수가 \\(1\\)인 경우 일차식이라고 합니다. 일차식의 계산은 동류항 (문자와 차수가 같은 항과 상수항)을 모으고 사칙연산의 교환법칙, 결합법칙, 분배법칙 등을 이용하여 식을 단순화하는 방식으로 풀어나가게 됩니다. 식 \\(3a + 4 + 2a - 2\\)의 경우에 소스코드에서는 곱셈 기호 *를 이용하여 3*a + 4 + 2*a - 2와 같이 표현합니다. 식으로는 아래의 소스코드와 같이 표현됩니다. xs &lt;- &quot;2*a + 5 + 4*a - 1&quot; #문자열 생성 xexpr &lt;- parse(text=xs) #문자열을 식으로 변환 #or xexpr &lt;- expression(2*a + 5 + 4*a -1) #식 직접 생성 print(xexpr[[1]]) #표현식 안에 저장된 첫 번째 리스트값을 확인 ## 2 * a + 5 + 4 * a - 1 위의 일차다항식을 단순화를 하기 위해서 아래 소스코드와 같이 Deriv패키지의 Simplify()함수를 사용할 수 있습니다. #install.packages(&quot;Deriv&quot;) library(Deriv) xexpr &lt;- Simplify(xexpr) #식 단순화 print(xexpr) #식 확인 ## expression(4 + 6 * a) print(xexpr[[1]]) #식에 저장된 첫 번째 리스트값을 확인 ## 4 + 6 * a 단순해 진 식은 4 + 6 * a의 형태입니다. 이 식의 문자 (변수) a에 숫자가 대입된다면 소스코드 차원에서 어떤 순서로 계산되는 지 확인해 봅시다. myexpr &lt;- xexpr[[1]] myexpr[[1]] #두 값을 더한다. ## `+` myexpr[[2]] #첫 번째 값 ## [1] 4 myexpr[[3]] #두 번째 값 ## 6 * a 아래와 소스코드와 같이 식 4 + 6 * a의 문자 a에 숫자 \\(3\\)을 대입하고 식을 계산하여 값을 구해볼 수도 있습니다. a&lt;-3 #문자 a에 숫자 3을 대입 eval(xexpr) #식 4 + 6 * a을 이용하여 실제 계산 수행 ## [1] 22 두 개의 식의 값이 같다는 수학 기호인 등호 (\\(=\\))로 묶어서 하나의 식으로 만든 식을 등식이라 하고, 등호의 왼쪽 식을 좌변, 오른쪽 식을 우변이라고 합니다. 좌변과 우변을 합하여 양변이라고 부릅니다. 등식 \\(x + 3 = 5\\)와 같이 문자 \\(x\\)를 포함하는 항이 있는 경우에 \\(x\\)의 값에 따라 이 등식은 참이 되기도 거짓이 되기도 합니다. 이러한 경우의 등식을 \\(x\\)에 대한 방정식이라 하고 \\(x\\)를 이 방정식의 미지수라고 합니다. 이 방정식이 참이 되도록 하는 미지수의 값을 이 방정식의 해 또는 근이라고 합니다. 아래의 소스코드를 이용하여 방정식 \\(x + 3 = 5\\)의 미지수 \\(x\\)에 \\(1\\)부터 \\(5\\)까지 숫자를 대입해 보면서 방정식이 참이 되는지 거짓이 되는지 확인해 보도록 하겠습니다. 방정식 문자열로부터 등호를 기준으로 문자열을 이등분하여 각 양변 문자열을 구하고 난 후, 첫 번째 문자열을 좌변으로 두 번째 문자열을 우변으로 설정합니다. 새로운 데이터 프레임을 생성하고 for()루프를 이용하여 네 개의 컬럼값을 가지는 레코드를 한 줄씩 추가합니다. #install.packages(&quot;stringr&quot;) library(stringr) #str_replace_all() 함수를 사용하기 위한 패키지 로딩 equation &lt;- &#39;x+3=5&#39; #식 sides &lt;- strsplit(equation, &quot;=&quot;) #등호로 양변을 구분 sides &lt;- sides[[1]] #양변 leftside &lt;- sides[1] #좌변 rightside &lt;-sides[2] #우변 x_df &lt;- data.frame(x=integer(), left=integer(), right=integer(), equal=logical()) for (x in 1:5) { left&lt;- str_replace_all(leftside, &quot;[x]&quot;, as.character(x)) #좌변에 숫자 대입한 식 right &lt;- rightside #우변은 상수 식 leftvalue &lt;- eval(parse(text=left)) #좌변 계산 rightvalue &lt;- eval(parse(text=right)) #우변 계산 equal &lt;- ifelse(leftvalue == rightvalue, TRUE, FALSE) #좌변과 우변 값 비교 x_df &lt;- rbind( x_df, data.frame(x, left, right, equal)) #데이터 프레임에 한 줄 추가 } x_df #데이터 프레임 결과 확인 ## x left right equal ## 1 1 1+3 5 FALSE ## 2 2 2+3 5 TRUE ## 3 3 3+3 5 FALSE ## 4 4 4+3 5 FALSE ## 5 5 5+3 5 FALSE 이렇게 구해진 데이터 프레임 x_df로 부터 \\(x=2\\)일 때 이 방정식이 참이 되므로 \\(x=2\\)가 이 방정식의 해가 되는 것을 알 수 있습니다. 아래의 소스코드와 같이 kable패키지를 이용하면 x_df데이터 프레임을 우리가 웹페이지나 책에서 보는 표의 형태로 만들 수도 있습니다 (표 3.1). 이 책에 나오는 대부분의 표들도 kable패키지를 사용하여 만들어 졌습니다. #install.packages(&quot;dplyr&quot;) library(dplyr) #install.packages(&quot;kableExtra&quot;) library(kableExtra) knitr::kable( x_df, col.names = c(&#39;x의 값&#39;, &#39;좌변 x+3&#39;, &#39;우변 5&#39;, &#39;참/거짓&#39;), #표 컬럼 이름 설정 booktabs = TRUE, align = &quot;c&quot;, #표 위치 설정 caption = &#39;방정식에 x값을 대입한 결과&#39; #표 제목 설정 ) %&gt;% kable_styling(full_width=FALSE,font_size=15) #표 컬럼 간격 설정 표 3.1: 방정식에 x값을 대입한 결과 x의 값 좌변 x+3 우변 5 참/거짓 1 1+3 5 FALSE 2 2+3 5 TRUE 3 3+3 5 FALSE 4 4+3 5 FALSE 5 5+3 5 FALSE 등식의 양변에 같은 수를 더하거나 빼거나 곱하거나 0이 아닌 수로 나누어도 등식은 성립하기 때문에, 등식의 한 변에 있는 항을 부호를 바꾸어 다른 변으로 옮기는 방식 (이항)으로 식을 정리하고 동류항 끼리 정리하는 방식으로 식을 풀어나가게 됩니다. 우변의 모든 항을 좌변으로 옮겨서 \\(x\\)에 대한 일차식 \\(= 0\\)의 형식으로 표현한 방정식을 \\(x\\)에 대한 일차방정식이라고 합니다. 연필과 종이로 일차방정식을 풀 때에는 미지수를 포함하는 항은 좌변으로 상수항은 우변으로 이항하고 동류항을 정리하는 방식으로 식을 풀어나가게 되지만, 소스코드 상에서는 우변의 모든 항을 좌변으로 옮겨서 \\(x\\)에 대한 일차식$ = 0$으로 표현한 일차방정식의 형태로 해를 구하게 됩니다. 등식 \\(3x + 10 = x + 1\\)이 주어진 경우, 아래의 소스코드를 이용하면 일차방정식 형태로 이항하고 해를 구해볼 수 있습니다. 표 3.1에서 방정식에 \\(x\\)값을 1부터 5까지 대입해보면서 해를 구한 것과는 달리 아래 소스코드에서는 일차방정식과 미지수 \\(x\\)의 계수를 활용하여 해를 구합니다. 일차방정식 \\(ax + b\\)의 경우 미지수에 \\(0\\)을 대입한 결과는 \\(b\\), 미지수 \\(x\\)의 계수는 \\(a\\)이므로 방정식의 해를 구하는 공식은 \\(- \\frac{b}{a}\\)이며 아래 소스코드에서는 x &lt;- - f(0)/df(0)로 표현되어 있습니다. 소스코드의 x &lt;- x0 - f(x0)/df(x0) 부분은 일반방정식의 수치해석 해법으로 사용되는 뉴튼 방법 (Newton’s method)이기 때문에 반복문만 추가하면 높은 차수의 방정식 해를 구하는 데에도 사용할 수 있습니다. 하지만, 뉴튼 방법은 중등 수학 과정에서는 다루지 않으므로 나중에 배우겠구나 정도로 생각하고 넘어가면 됩니다. library(Deriv) library(stringr) #str_replace_all() 함수를 사용하기 위한 패키지 로딩 equationString &lt;- &#39;3*x + 10 = x + 1&#39; #식 문자열 sides &lt;- strsplit(equationString, &quot;=&quot;) #등호로 양변을 구분 sides &lt;- sides[[1]] #리스트의 첫 번째 공간에 저장되어있는 양변을 가져옴 leftside &lt;- sides[1] #좌변 rightside &lt;-sides[2] #우변 rightside &lt;- paste(&#39;-(&#39;, rightside, &#39;)&#39;) #우변의 등호를 바꿈 leftside &lt;- paste(leftside, rightside) #우변을 좌변으로 이항 equation &lt;- parse(text=leftside) #문자열을 식으로 변환 F &lt;- Simplify(equation) #식 단순화 f &lt;- function(x){ eval(F[[1]]) } #일차방정식을 숫자 대입한 형태의 함수로 변환 dF &lt;- D(F, &quot;x&quot;) #일차방정식 미지수 x의 계수 얻기 df &lt;- function(x){ eval(dF[[1]]) } #계수는 상수이므로 dF와 df의 반환값은 같음 x0 &lt;- 0 x &lt;- x0 - f(x0)/df(x0) # print(paste0(&#39;x0값이 &#39;, x0, &#39;일 때의 x값: &#39;, x)) ## [1] &quot;x0값이 0일 때의 x값: -4.5&quot; x0 &lt;- 10 x &lt;- x0 - f(x0)/df(x0) print(paste0(&#39;x0값이 &#39;, x0, &#39;일 때의 x값: &#39;, x)) ## [1] &quot;x0값이 10일 때의 x값: -4.5&quot; x &lt;- - f(0)/df(0) print(paste0(&#39;x0값에 0을 대입하여 수식을 단순화 했을 때의 x값: &#39;, x)) ## [1] &quot;x0값에 0을 대입하여 수식을 단순화 했을 때의 x값: -4.5&quot; 위의 소스코드 중에서 df(0)는 미지수의 계수이고, f(0)는 일차방정식의 상수항입니다. 미지수를 좌변으로 상수항을 우변으로 하는 등식인 \\(ax = b\\) 형태로 표현한 후 solve(a, b)함수를 이용해도 방정식의 해를 구할 수 있습니다. a &lt;- df(0) b &lt;- -f(0) solve(a, b) 위의 소스코드 중에서 F는 미지수 \\(x\\)에 대한 일차방정식입니다. rootSolve패키지를 이용하면 일차방정식의 해 뿐만 아니라 고차방정식 (비선형방정식)의 해도 구해볼 수 있습니다. 아래 소소코드를 한 줄 한 줄 실행해보면서 그림 3.8과 같은 결과가 나오는지 확인해 보세요. #install.packages(&quot;rootSolve&quot;) library(rootSolve) F func &lt;- function(x){ eval(F[[1]]) } curve(func(x), -10, 10) abline(h = 0, lty = 3) #y=0인 직선을 그래프에 표시 uni &lt;- uniroot(func, c(-10, 10))$root #해를 구함 points(uni, 0, pch = 16, cex = 2) #해를 그래프에 표시 그림 3.8: rootSolve 패키지를 이용한 일차방정식의 해 이번 장에서는 문자를 사용한 식, 일차식, 등식, 방정식, 일차방정식 등을 다루면서 황금비율과 피보나치 수, 피보나치 사각형에 대하여 알아보고 소스코드에서 일차방정식의 좌변, 우변, 이항, 숫자 대입, 해 구하기 등이 소스코드로 어떻게 구현되는지 알아보았습니다. 이제 4장 좌표평면과 그래프에 대하여 본격적으로 알아봅시다. "],
["coordinates-graph.html", "4 좌표평면과 그래프 4.1 순서쌍과 좌표 4.2 그래프 4.3 정비례와 반비례", " 4 좌표평면과 그래프 특정 위치를 나타내거나 두 문자 (변수)간의 관계를 시각적으로 표현하는데 유용한 좌표평면과 그래프에 대해서 알아봅니다. RStudio가 열려 있지 않으면 RStudio를 실행하고 메뉴에서 File &gt;&gt; Open Project…를 클릭하여 이전에 저장한 R 프로젝트 파일인 rmath01.Rproj을 찾아서 선택하고 Open 버튼을 클릭하여 이전에 작업하던 프로젝트 환경을 로딩합니다. 파일탐색기나 파인더에서 rmath01.Rproj 파일을 찾아서 더블 클릭하여도 RStudio가 실행되면서 작업하던 프로젝트 환경이 로딩됩니다. 프로젝트 환경이 로딩된 후에 RStudio 콘솔창에 getwd()를 실행하여 작업 환경이 제대로 로딩되었는지 확인합니다. RStudio 환경이 잘 로딩되었으면, 이제 본격적으로 시작해 봅시다. 4.1 순서쌍과 좌표 직선 상에 대응하는 한 점을 대표하는 숫자를 그 점의 좌표라고 하고, 점들의 좌표를 기호로 표현할 수 있습니다. 직선 상의 다섯 개의 점 \\(A\\), \\(B\\), \\(O\\), \\(C\\), \\(D\\)의 각 좌표가 \\(-4\\), \\(-1\\), \\(0\\), \\(3\\), \\(5\\)라고 하면, 이를 기호로 \\(A(-4)\\), \\(B(-1)\\), \\(O(0)\\), \\(C(3)\\), \\(D(5)\\) 와 같이 표현합니다. 이를 소스코드로 작성해보면 아래와 같습니다. #직선 상의 점들 이름과 좌표 벡터 생성 xtext &lt;- c(&#39;A&#39;, &#39;B&#39;, &#39;O&#39;, &#39;C&#39;, &#39;D&#39;) #점 이름 벡터 x &lt;- c(-4, -1, 0, 3, 5) #점 벡터 #각 점의 좌표를 기호로 표현 coordinateVector &lt;- paste0(xtext, &#39;(&#39;, x, &#39;)&#39;) #점 이름과 좌표를 합한 벡터 coordinateString &lt;- paste(paste0(coordinateVector,collapse=&quot;, &quot;)) #문자열로 변형 print(paste(&#39;각 점의 좌표를 기호로 표현:&#39;, coordinateString)) ## [1] &quot;각 점의 좌표를 기호로 표현: A(-4), B(-1), O(0), C(3), D(5)&quot; 이제, 위의 소스코드에서 생성된 xtext, x벡터를 이용하여 수직선 상에 점들을 그려보겠습니다. 2.1절의 그림 2.5를 만드는데 사용된 소스코드를 조금 수정하고 세 단계로 나누어 작성된 아래의 소스코드를 이용하면 직선 위에 다섯 개의 점과 점들의 좌표를 그려볼 수 있습니다. ggplot 그래프에 다섯 개의 점을 추가합니다. library(ggplot2) #ggplot 그래프 생성을 위한 패키지 로딩 xaxis &lt;- seq(-5,5) #직선 벡터 p1 &lt;- ggplot() + #데이터 프레임 없이 각 그래프 요소에서 벡터를 사용하여 그래프 생성 ylim(min(xaxis), max(xaxis)) + #x축과 y축 폭을 동일하게 설정 #각 점 추가 geom_point(aes(x=x, y=0), alpha=1.0, size=1.5, color=&#39;black&#39;) + #mycolor2 ) + #각 점 이름 추가 geom_text(aes(x=x, y=0.3, label=xtext), color=&quot;black&quot;, size=3.5, fontface = &quot;bold&quot;) p1 #그래프 확인 ggplot 그래프에 필요 없는 축 정보 등을 보이지 않도록 설정합니다. p2 &lt;- p1 + #필요 없는 축 정보 등을 모두 보이지 않도록 설정 theme_void() p2 #그래프 확인 ggplot 그래프에 직선과 좌표 눈금을 추가합니다. p3 &lt;- p2 + #직선 (좌표축) + 오른쪽 화살표 추가 annotate(&quot;segment&quot;,x=min(xaxis)-1,xend=max(xaxis)+1, y=0, yend=0, size=0.5, color=&#39;dimgray&#39;, arrow=arrow(length=unit(0.2,&quot;cm&quot;))) + #직선 (좌표축) 왼쪽 화살표 추가 annotate(&quot;segment&quot;,x=0,xend=min(xaxis)-1, y=0, yend=0, size=0.5, color=&#39;dimgray&#39;, arrow=arrow(length=unit(0.2,&quot;cm&quot;))) + #직선에 눈금 추가 annotate(&quot;segment&quot;,x=xaxis,xend=xaxis, y=-0.1, yend=0.1, size=0.2, color=ifelse(xaxis %in% x, &#39;black&#39;, &#39;dimgray&#39;)) + #직선 눈금 밑에 좌표 추가 geom_text(aes(x=xaxis, y=-0.3, label=xaxis), size=3.5, color=ifelse(xaxis %in% x, &#39;black&#39;, &#39;dimgray&#39;)) p3 #그래프 확인 위의 소스코드에서 p1, p2, p3를 구하는 과정을 거쳐서 그림 4.1이 생성되었습니다. RStudio의 콘솔창에서 p1, p2, p3를 각각 실행해보며 그래프의 변화를 확인해 봅시다. 그림 4.1: 1차원 직선 위에 표현한 다섯 점의 좌표 지금까지는 \\(x\\)축 하나의 좌표축 만을 이용한 직선 상의 좌표에 대하여 알아보았습니다. 두 개 또는 세 개의 좌표축이 각각 90도를 이루도록 배치하면 이차원 평면공간 또는 삼차원 입체공간의 좌표를 표현할 수 있습니다. 두 개의 좌표축 (가로축 \\(x\\)축, 세로축 \\(y\\)축)을 포함하는 이차원 평면공간을 좌표평면 (coordinate plane)이라고 합니다. 좌표평면 위에 존재하는 점은 두 개의 좌표축을 기준으로 하여 두 개의 좌표를 가지게 되며 이러한 두 개의 좌표를 순서를 정하여 쌍으로 표현한 것을 순서쌍 (ordered pair)이라고 합니다. 일반적으로, 좌표평면 상의 점 \\(A\\)의 좌표를 기호로 나타내면 \\(A(x_a, y_a)\\)와 같으며, 가로축인 \\(x\\)축의 좌표 \\(x_a\\)를 앞에, 세로축인 \\(y\\)축의 좌표 \\(y_a\\)를 뒤에 표시합니다. 좌표평면은 프랑스의 철학자이자 수학자이자 과학자인 데카르트 (Descartes, R., 1596~1650)에 의해 처음 소개되었으며, 직교좌표계 (rectangular coordinate system) 또는 카테시안 좌표계 (Cartesian coordinate system)라고도 불립니다. 카테시안 좌표계라는 이유는 데카르트가 카테시우스 (Cartesius)라는 이름으로 불리었던 데서 비롯되었습니다. 데카르트는 “나는 생각한다. 그러므로 나는 존재한다.”라는 철학 명제로도 유명합니다. 데카르트는 처음 저서에서 이 명제를 프랑스어로 썼지만 (“Je pense, donc je suis”) 나중에는 다른 저서에서 라틴어로 된 명제인 “dubito, ergo cogito, ergo sum” (“나는 의심한다. 그러므로 나는 생각한다. 그러므로 나는 존재한다.”)을 사용하였습니다. 이 라틴어 명제의 일부인 “cogito, ergo sum”가 인식론에서 중요하게 다루어지기 시작하면서 널리 알려졌으며, 오늘날에도 서양 철학의 근간을 이루는 중요한 명제 중의 하나로 평가됩니다.2 다시 본론으로 돌아와서, 좌표평면 이야기를 계속해 봅시다. 우리는 이미 2.1절의 그림 2.4를 생성하는 과정에서 좌표평면을 사용하였습니다. 그 때 사용한 단계 별 소스코드 중 두 번째 단계의 코드를 다시 기억해보면, 아래의 소스코드와 같이 ggplot2패키지의 map_data()함수를 이용하여 한반도 경위도 좌표를 가진 데이터 프레임을 생성하고 좌표평면으로 그려보는 내용이었습니다. 이전 소스코드에서 저장했던 데이터 파일들 (korea_df.csv, korea_sp.rds)을 활용하여 좌표평면을 조금 더 자세히 알아봅시다. 먼저 아래 소스코드를 이용하여 한반도 지도를 좌표평면 위에 그려보고 제주도의 대략적인 위치를 살펴보세요. #korea_df &lt;- map_data(map = &#39;world&#39;, # region = c(&#39;South Korea&#39;, &#39;North Korea&#39;)) getwd() korea_df &lt;- read.csv (&quot;korea_df.csv&quot;) #현재 작업 디렉토리에서 데이터 파일 로딩 ggplot(data = korea_df, mapping = aes(x = long, y = lat, group = group)) + geom_polygon(fill = &#39;white&#39;, color = &#39;black&#39;) + coord_map() + ylim(32.5, 43.5) 제주도의 \\(x\\)축 좌표는 \\(126\\)과 \\(127\\)사이에 \\(y\\)축 좌표는 \\(33\\)과 \\(34\\)사이에 있는 것을 알 수 있습니다. 대략적인 위치는 알 수 있지만 정확한 위치는 알 수 없습니다. leaflet패키지를 이용하면 다양한 배경지도 (background map)를 이용하여 원하는 지역을 확대, 축소, 이동해 보면서 확인할 수 있습니다. 아래 소스코드와 같이 관련 패키지를 설치하고 패키지를 로딩한 다음 korea_sp.rds를 좌표평면에 표현해 봅시다. #install.packages(&quot;leaflet&quot;) #웹맵 패키지인 리플렛 설치 library(leaflet) #웹맵 패키지인 리플렛 로딩 #install.packages(&quot;leafem&quot;) #리플렛 추가패키지 설치 library(leafem) #리플렛 추가패키지 로딩 korea_sp &lt;- readRDS(file = &quot;korea_sp.rds&quot;) #한반도 공간 다각형 파일 로딩 leaflet() %&gt;% setView(lng = 127, lat = 38, zoom = 8) %&gt;% addPolygons(data = korea_sp, fillColor = &#39;black&#39;, stroke = FALSE) %&gt;% addMouseCoordinates() 위의 소스코드를 실행한 후에, +버튼과 -버튼 그리고 마우스를 이용하여 그래프정보창 화면에 한반도 전체가 나오도록 화면을 움직여보세요. 그래프정보창 화면의 +버튼 위쪽에 lon:와 lat: 다음에 나오는 숫자는 각각 마우스 위치의 \\(x\\)좌표, \\(y\\)좌표를 나타냅니다. 이제, 제주도가 그래프정보창 화면에 가득 차도록 화면을 확대, 축소, 이동한 후에 한라산의 (\\(x\\), \\(y\\)) 좌표를 찾아보세요. 현재 그래프 정보창에는 제주도와 바다의 경계 정보 밖에 주어지지 않았기 때문에 한라산의 좌표는 여전히 알 수 없습니다. 아래 소스코드와 같이 setView() 라인 밑에 파이프 연산자를 이용하여 addProviderTiles() 라인을 추가합니다. leaflet() %&gt;% setView(lng = 127, lat = 38, zoom = 8) %&gt;% addProviderTiles(&quot;Stamen.TerrainBackground&quot;) %&gt;% #배경지도 추가 addPolygons(data = korea_sp, fillColor = &#39;black&#39;, stroke = FALSE) %&gt;% addMouseCoordinates() 제주도가 그래프정보창 화면에 가득 차도록 화면을 확대, 축소, 이동한 후에 확인해보면, 제주도의 대략적인 지형 정보가 확인됩니다. 이제 마우스를 한라산 정상 위치에 놓고 한라산의 (\\(x\\), \\(y\\)) 좌표를 찾아 소수점 둘 째짜리 까지 종이 메모장이나 컴퓨터 메모장에 적어두세요. RStudio의 스크립트창을 이용하여 좌표를 메모하거나 소스코드의 일부를 변경해 볼 수 있습니다. 메모한 한라산의 좌표값을 이용하여 setView()함수의 입력값인 lng, lat값을 변경하고 위의 소스코드를 다시 실행하면 한라산이 그래프정보창의 중심에 위치하게 됩니다. setView()함수의 세 번째 입력값인 zoom값을 \\(9\\)나 \\(10\\)으로 크게 설정할수록 소스코드 실행 시 제주도가 화면에 크게 나타납니다. setView()함수의 세가지 입력값이 잘 설정되었으면 이제 제주도와 바다의 경계 부분을 유심히 살펴봅시다. korea_sp.rds로 부터 그려진 제주도 경계 정보보다 Stamen.TerrainBackground배경지도가 보여 주는 경계 정보가 더 자세하고 정확한 것을 알 수 있습니다. 이를 통하여 korea_sp.rds에 저장된 좌표 정보는 한반도 전체를 대략적으로 보여주기 위해 단순화 된 좌표라고 추론해 볼 수 있습니다. 참고로, 이 단순화된 좌표정보를 대략적인 시각화에 사용하는 것은 문제가 되지 않으나 면적을 계산하거나 비율을 계산하는 등의 수치 연산에 사용하기에는 부적절합니다. 콘솔창에서 ?addProviderTiles를 실행하면 도움말창에 해당 함수의 설명 뿐만 아니라 입력값과 반환값 (출력값) 관련 정보도 조회할 수 있습니다. 도움말의 입력값 (argument) 항목의 provider정보를 살펴보면 leaflet패키지가 다양한 배경지도를 제공하고 있다는 것을 알 수 있습니다. 도움말에 제공된 링크 (https://leaflet-extras.github.io/leaflet-providers/preview/)에 들어가 보면 수십 가지의 배경지도를 확인해 볼 수 있습니다. 한라산이 중심이 되도록 setView()함수의 입력값을 여러분이 직접 수정한 소스코드에서 addProviderTiles()의 입력값을 OpenStreetMap.Mapnik, Esri.WorldStreetMap, Stamen.Watercolor와 같이 변경하면서 배경지도가 변하는 것을 확인해보고, 그림 4.2의 배경지도와 비교해 보세요. 그림 4.2: 한라산 좌표와 수채화풍 배경지도를 이용한 제주도 지역의 시각화 위의 수채화 풍의 제주도 그림을 생성한 소스코드는 아래와 같습니다. leaflet() %&gt;% setView(lng = 126.53, lat = 33.36, zoom = 10) %&gt;% addProviderTiles(&quot;Stamen.Watercolor&quot;) %&gt;% #배경지도 추가 addPolygons(data = korea_sp, fillColor = &#39;black&#39;, stroke = FALSE) %&gt;% addMouseCoordinates() 지금까지는 (\\(x\\), \\(y\\)) 좌표가 모두 양수인 한반도 지도를 예로 들어 좌표평면을 설명했습니다. 이제 좌표가 음수인 예를 살펴보기에 앞서, 먼저 좌표평면의 사분면에 대하여 알아보겠습니다. 좌표평면에서 두 좌표축이 수직으로 만나는 점을 원점 \\(O\\)이라고 합니다. 두 개의 좌표축은 원점을 기준으로 각각 양수 부분과 음수 부분, 총 \\(4\\)개의 부분으로 나누어집니다. 이 4개의 부분을 각각 제1사분면, 제2사분면, 제3사분면, 제4분면이라고 하며, 좌표평면에 존재하는 한 점 \\(a\\)의 좌표 (\\(x_a\\), \\(y_a\\))가 \\(x\\)축, \\(y\\)축, 또는 원점 \\(O\\)(\\(0\\), \\(0\\)) 위의 점이 아니라면 \\(a\\)의 좌표는 \\(4\\)개의 사분면들 (quadrants) 중 하나에 속하게 됩니다. 3.1절의 그림 3.7을 만드는데 사용되었던 소스코드를 재사용하여 피보나치 사각형 (나선형 배치)이 그려진 좌표평면의 위에 \\(x\\)축, \\(y\\)축, 원점\\(O\\)과 \\(4\\)개의 사분면 정보를 추가해 보겠습니다. 아래 소스코드의 p1부분은 기존 소스코드로 부터 생성되었고 \\(x\\)축과 \\(y\\)축은 p2부분과 p3부분에, 원점\\(O\\)과 사분면의 위치는 p4부분에 구현되었습니다. 그래프의 각 요소를 추가하기 위해서는 각 요소의 위치를 좌표로 설정해 주어야 하기 때문에 소스코드로 좌표평면을 다루면서 좀 더 좌표에 익숙해 지기 바랍니다. 아래 소스코드는 흐름 위주로 살펴보고 세부적으로 이해가 어려운 부분은 쿨하게 복붙하세요. 피보나치 사각형 데이터 프레임을 읽어 와서 그래프에 추가하고 필요 없는 배경요소를 제거합니다. #library(tidyverse) #library(ggplot2) rect_df &lt;- readRDS(file = &quot;Fibonacci_rectangle_df.rds&quot;) #피보나치 사각형 파일 읽어오기 n &lt;- nrow(rect_df) #사각형의 개수 maxv = 13 #그래프의 표현할 공간확보 minv = -1 * maxv p1 &lt;- ggplot(rect_df) + xlim(minv, maxv) + ylim(minv, maxv) + #x축, y축 공간확보 coord_fixed(ratio = 1) + #두축의 비율 설정 geom_rect(aes(xmin=x1, xmax=x2, ymin=y1, ymax=y2), fill = colorspace::rainbow_hcl(n), color = colorspace::rainbow_hcl(n), size= 0.2, alpha=0.2) + geom_text(aes(x=x1+(x2-x1)/2, y=y1+(y2-y1)/2, label=r), color = colorspace::rainbow_hcl(n), size=3.5, fontface = &quot;bold&quot;, alpha=0.9) + theme_void() #필요 없는 배경요소 제거 p1 #피보나치 사각형 확인 그래프에서 한글 폰트를 사용할 수 있도록 환경을 설정합니다. 아래의 소스코드는 한 줄 한 줄 실행해 줍니다. #install.packages(&quot;extrafont&quot;) library(extrafont) mypattern &lt;- &quot;Myungjo|myungjo|Gothic|gothic|Nanum|nanum&quot; #한글 폰트 패턴 loadfonts() #한글 폰트 가져오기 #아래의 코드는 한 줄만 단독 실행, 실행 후 추가로 나오는 질문 #Continue?에 y를 입력하고 엔터 font_import(pattern = mypattern) library(stringr) fonts()[str_detect(fonts(), mypattern)] #폰트 리스트 확인 #위의 fonts() 리스트 중에서 하나를 선택하여 아래와 같이 입력 myfont에 입력 #myfont &lt;- &quot;HUIncludegothic 110&quot; myfont &lt;- &quot;AppleMyungjo&quot; #여러분의 컴퓨터 환경에 맞도록 변경하세요! #myfont &lt;- &quot;AppleGothic&quot; #myfont &lt;- &quot;NanumBarunGothic&quot; #한글 폰트를 사용하는 그래픽 요소에 폰트 설정 (family=myfont) x축 정보를 그래프에 추가합니다. unit &lt;- c(seq (-10, -2, 2), seq (2, 10, 2)) #x, y 축의 눈금 간격 설정 p2 &lt;- p1 + #x축 + 오른쪽 화살표 추가 annotate(&quot;segment&quot;,x=minv,xend=maxv,y=0,yend=0, size=0.5,color=&#39;black&#39;,arrow=arrow(length=unit(0.2,&quot;cm&quot;))) + #x축 이름 추가, 한글 폰트 사용 annotate(geom=&quot;text&quot;,x=maxv,y=-0.7,label=&#39;x축&#39;,size=5,color=&quot;black&quot;,family=myfont) + #x축에 눈금 추가 annotate(&quot;segment&quot;,x=unit,xend=unit,y=-0.2,yend=0.2,size=0.2,color=&#39;black&#39;) + #직선 눈금 밑에 좌표 추가 annotate(geom=&quot;text&quot;,x=unit,y=-0.7,label=unit,size=5,color=&quot;black&quot;) p2 #x축 정보 확인 y축 정보를 그래프에 추가합니다. p3 &lt;- p2 + #y축 + 위쪽 화살표 추가 annotate(&quot;segment&quot;,x=0,xend=0,y=minv,yend=maxv, size=0.5,color=&#39;black&#39;,arrow=arrow(length=unit(0.2,&quot;cm&quot;))) + #y축 이름 추가, 한글 폰트 사용 annotate(geom=&quot;text&quot;,x=1,y=maxv,label=&#39;y축&#39;,size=5,color=&quot;black&quot;,family=myfont) + #y축에 눈금 추가 annotate(&quot;segment&quot;,x=-0.2,xend=0.2,y=unit,yend=unit,size=0.2,color=&#39;black&#39;) + #직선 눈금 밑에 좌표 추가 annotate(geom=&quot;text&quot;,x=-0.7,y=unit,label=unit,size=5,color=&quot;black&quot;) p3 #y축 정보 확인 원점과 각 사분면 정보를 그래프에 추가합니다. p4 &lt;- p3 + #원점 O 추가 annotate(geom=&quot;text&quot;, x=-0.7, y=-0.7, label=&#39;O&#39;, size=5, color=&quot;black&quot;) + #제1사분면 정보추가, 한글 폰트 사용 geom_label(x=7,y=7,label=&#39;제1사분면 (+,+)&#39;,family=myfont,label.padding=unit(1,&quot;lines&quot;), fill = &#39;lightblue1&#39;, color = &#39;black&#39;, size = 5) + #제2사분면 정보추가, 한글 폰트 사용 geom_label(x=-7,y=7,label=&#39;제2사분면 (-,+)&#39;,family=myfont,label.padding=unit(1,&quot;lines&quot;), fill = &#39;thistle1&#39;, color = &#39;black&#39;, size = 5) + #제2사분면 정보추가, 한글 폰트 사용 geom_label(x=-7,y=-7,label=&#39;제3사분면 (-,-)&#39;,family=myfont,label.padding=unit(1,&quot;lines&quot;), fill = &#39;peachpuff1&#39;, color = &#39;black&#39;, size = 5) + #제2사분면 정보추가, 한글 폰트 사용 geom_label(x=7, y=-7,label=&#39;제4사분면 (+,-)&#39;,family=myfont,label.padding=unit(1,&quot;lines&quot;), fill = &#39;lightpink1&#39;, color = &#39;black&#39;, size = 5) p4 #사분면 정보 확인 위의 다섯 단계를 거쳐서 그림 4.3을 얻을 수 있었습니다. 흐린 색으로 피보나치 사각형들이 보이고 그 위에 \\(x\\)축, \\(y\\)축, 원점 그리고 제1사분면, 제2사분면, 제3사분면, 제4사분면의 영역이 구분되어 있습니다. 제1사분면에 속하는 점들의 \\(x\\)좌표와 \\(y\\)좌표는 모두 양수이고, 제3사분면에 속하는 점들의 \\(x\\)좌표와 \\(y\\)좌표는 모두 음수입니다. 그림 4.3: 피보나치 사각형과 좌표평면의 사분면 이제 좌표평면의 \\(x\\)축과 \\(y\\)축에 숫자로 표현 가능한 양 (mass), 길이 (length), 시간 (time)을 대입하여 다양한 상황을 표현해 봅시다. 4.2 그래프 좌표평면에서는 \\(x\\)축과 \\(y\\)축을 이용하여 \\(x\\)와 \\(y\\) 두 변수 사이의 관계를 점 또는 선 (직선이나 곡선, 선형이나 비선형)으로 그려볼 수 있으면 이러한 형태의 그림을 그래프라고 합니다. 이미 3.1절에서 살펴본 것처럼, 피보나치 수를 가지고 그래프로 나타낼 때 \\(y\\)변수값이 무엇이 되는 가에 따라 곡선 그래프가 되기도 하고 (그림 3.4) 오르락 내리락 하다가 직선이 되는 그래프가 되기도 합니다 (그림 3.5). milktea3의 초등학교 시절 키의 변화를 매년 측정한 기록을 가지고 그래프를 그려보고 이 그래프를 해석해 봅시다. 아래의 소스코드와 같이 측정한 기록을 가지고 연도, 학년, 키 벡터를 생성하고 이 세 개의 벡터를 컬럼으로 가지는 데이터 프레임을 생성합니다. year &lt;- 2014:2019 #연도 grade &lt;- 1:6 #학년 height &lt;- c(129.8, 136.7, 142, 150.5, 156.6, 162.2) #학년 별 키 h_df &lt;- data.frame(year, grade, height) #데이터 프레임 생성 생성된 데이터 프레임 h_df의 각 행 (로우, row)은 각 관측치 (관측값, 측정값, observation, obs.)를 나타내고, 각 열 (컬럼, column, col.)은 전체 관측치의 특정 속성 또는 변수의 벡터값을 나타냅니다. 데이터 프레임의 행 (로우)과 열 (컬럼)의 개수와 컬럼별 데이터 타입, 어떤 데이터가 들어있는지 등을 확인하기 위하여 nrow(), ncol(), dim(), str(), 함수들을 사용할 수 있습니다. 아래의 소스코드를 실행해 보면서 각 함수의 차이를 파악해 보세요. nrow(h_df) #number of rows; 데이터프레임 h_df의 행 (로우, row, 관측치, observation, obs.)의 개수 ## [1] 6 ncol(h_df) #number of columns; 데이터프레임 h_df의 열(컬럼, column, col.)의 개수 ## [1] 3 dim(h_df) #dimension of h_df; 데이터프레임 h_df의 차원 확인; 행 (로우, 관측치)과 열(컬럼, 변수)의 개수 ## [1] 6 3 str(h_df) #데이터 프레임 h_df의 행과 열의 구조 (structure) 확인; 행과 열의 개수, 열의 데이터 타입 ## &#39;data.frame&#39;: 6 obs. of 3 variables: ## $ year : int 2014 2015 2016 2017 2018 2019 ## $ grade : int 1 2 3 4 5 6 ## $ height: num 130 137 142 150 157 ... 데이터 프레임 h_df의 정보를 표로 표현해 보겠습니다. 표로 표현하기 위하여 각 컬럼에 한글 이름을 주고 knitr패키지를 이용하면 표 4.1과 같이 표를 그려볼 수 있습니다. library(dplyr) library(kableExtra) knitr::kable( h_df, col.names = c(&#39;연도&#39;, &#39;학년&#39;, &#39;milktea3의 키 (cm)&#39;), #표 컬럼 이름 설정 booktabs = TRUE, align = &quot;c&quot;, #표 위치 설정 caption = &#39;학년 별 키의 변화 테이블&#39; #표 제목 설정 ) %&gt;% kable_styling(full_width=FALSE,font_size=15) #표 컬럼 간격 설정 표 4.1: 학년 별 키의 변화 테이블 연도 학년 milktea3의 키 (cm) 2014 1 129.8 2015 2 136.7 2016 3 142.0 2017 4 150.5 2018 5 156.6 2019 6 162.2 위의 소스코드로 생성된 데이터 프레임 h_df의 세 개의 컬럼 중 학년 컬럼과 키 컬럼을 각각 그래프의 \\(x\\), \\(y\\)변수로 하여 그래프를 그려보면 그림 4.4와 같습니다. 각 점을 이어서 선 (회색 실선)을 그려보면 milktea3의 키 변화를 쉽게 확인할 수 있습니다. 그리고 ggplot()그래프의 ()geom_smooth(method = &quot;lm&quot;)함수를 이용하면 두 변수 (x=grade, y=height)사이의 관계를 가장 잘 설명하는 \\(x\\)의 일차방정식을 직선 (파란 점선)으로 그려볼 수 있습니다. 그려진 그래프를 바탕으로, milktea3는 초등학교 기간 동안 꾸준히 자란 것을 알 수 있습니다. 1학년 때 키와 6학년 때 키를 비교해보면 \\(30cm\\)이상 자랐으며 3학년 때에는 조금 덜 자랐고 4학년 때에는 조금 더 자랐다는 것을 알 수 있습니다. 실제 키의 변화를 나타낸 선 (실선)과 일차방정식 직선 (점선)을 비교해 보면 자라는 추세보다 조금 덜 자란 때와 조금 더 자란 때를 구별하는 데 도움이 됩니다. library(ggplot2) ggplot(h_df, aes(x=grade, y=height)) + geom_point() + geom_line(color=&#39;dimgray&#39;, alpha=0.5, size=1) + geom_smooth(method = &quot;lm&quot;, se = FALSE, size=0.5, linetype=&quot;dashed&quot;) 그림 4.4: 학년 별 키의 변화 그래프 각 학년 별로 얼마나 컸는지를 알아보기 위해 해당 연도 키를 전년도 키와 비교해 볼 수 있습니다. 두 값을 비교하는 방법은 뺄셈 연산으로 두 값의 차이 (변화량, difference)를 구하는 방법과 나눗셈 연산으로 두 값의 변화율 (percentage change)을 구하는 방식이 있습니다. 이번 연도 키를 \\(value_{new}\\)라 하고 전년도 키를 \\(value_{old}\\)이라 하면 두 값 사이의 차이 (변화량)와 변화율을 구하는 수식은 아래와 같습니다. \\[{difference} = {{value}_{new}} - {{value}_{old}}\\] \\[{percentage}_{change} = \\frac{{value_{new}} - {value_{old}}}{\\left\\lvert {value}_{old} \\right\\rvert} \\times 100 \\%\\] 위의 변화율의 경우에는 한 사람의 과거 키와 현재 키를 비교하는 것이기 때문에 과거 값을 기준으로 보아 분모로 삼았습니다. 그러나, 두 사람의 키를 비율로 비교할 경우, 어떤 사람의 키를 기준으로 삼아야 하는지 애매합니다. 이런 경우, 두 사람의 키의 평균을 분모로 삼아 비율을 계산하며 변화율과 구분하여 백분율 차이 (percentage difference)라고 하며, 구하는 수식은 아래와 같습니다. \\[{percentage}_{difference} = \\left\\lvert \\frac{{{value}_{new}} - {{value}_{old}}} {({{value_{old}} + {value_{new}}}) / {2}} \\right\\rvert \\times 100 \\%\\] 아래의 소스코드를 활용하여, milktea3의 학년 별 키의 변화량과 변화율 컬럼을 데이터 프레임에 추가하고, \\(2\\)학년부터 \\(6\\)학년까지의 키 변화량, 변화율 그래프로 그려보면 그림 4.5와 같습니다. 변화량 선 (실선)과 변화율 (점선)의 선의 변화 패턴은 \\(3\\)학년 때 감소하였다가 \\(4\\)학년 때 증가하고 \\(5\\)학년, \\(6\\)학년 때 다시 감소하는 경향을 보입니다. 두 선이 비슷한 변화 패턴을 가지지만, \\(4\\)학년 때 키의 변화량은 \\(9\\)cm이고 변화율은 약 \\(6 \\%\\)로 다른 것을 알 수 있습니다. 변화량의 단위는 cm이고 변화율의 단위는 백분율 (\\(\\%\\))이기 때문에 서로 다른 두 \\(y\\) 변수를 하나의 그래프에 그리기 위해서 두 개의 \\(y\\)축을 사용하였습니다. 변화량의 값은 왼쪽 \\(y\\)축을 기준으로 값 (cm)을 읽어야 하고 변화율의 값은 오른쪽 \\(y\\)축을 기준으로 값 (\\(\\%\\))을 읽어야 합니다. 이 그래프의 경우 두 \\(y\\)축의 숫자 눈금이 일치하지만, 두 \\(y\\) 변수 값의 범위가 달라서 두 \\(y\\)축의 숫자 눈금이 다른 경우도 많습니다. h_df$difference &lt;- NA #차이 (변화량) 벡터 생성 h_df$percentagechange &lt;- NA #변화율 벡터 생성 for (i in 2:nrow(h_df)) { #두 개의 벡터 값 설정 h_df$difference[i] &lt;- (h_df$height[i] - h_df$height[i-1]) h_df$percentagechange[i] &lt;- (h_df$height[i] - h_df$height[i-1]) / abs(h_df$height[i-1]) * 100 } ggplot(h_df[-c(1),], aes(x=grade)) + #1학년은 전년도 값이 없으므로 제외 geom_point(aes(y=difference)) + #변화량 점 geom_line(aes(y=difference, linetype=&#39;Difference&#39;), color=&#39;dimgray&#39;) + #변화량 선 geom_point(aes(y=percentagechange)) + #변화율 점 geom_line(aes(y=percentagechange, linetype=&#39;Percentage Change&#39;), color=&#39;dimgray&#39;) + scale_linetype_manual(values=c(&#39;solid&#39;, &#39;dashed&#39;)) + #변화량은 실선으로 변화율은 점선으로 설정 labs(x = &quot;Grade&quot;, y = &quot;Difference [cm]&quot;) + #x축과 y축 제목 설정 #변화율 변수를 위한 두 번째 y축 설정 scale_y_continuous(sec.axis = sec_axis(~., name = &quot;Percentage Change [%]&quot;)) + #실선, 점선 범례 위치 이동 및 범례 제목 삭제 theme(legend.position = c(0.8, 0.85), legend.title = element_blank()) 그림 4.5: 연도 별 전년도와의 키 차이 (변화량과 변화율) 지금까지 (\\(x\\),\\(y\\)) 좌표를 이용한 그래프 표현에 대하여 알아보았습니다. 이제 두 변수들 간의 정비례, 반비례 관계에 대해서 알아봅시다. 4.3 정비례와 반비례 seongcho가 팟캐스트를 들으면서 다섯 시간 동안 \\(1\\)시간에 \\(4km\\)씩 꾸준히 걷는다고 하면, 다섯 시간 후 우리는 표 4.2와 같은 정보를 얻을 수 있습니다. 주어진 \\(x\\) (시간)와 \\(y\\) (거리) 정보를 기반으로 두 변수들 간의 관계를 알아보기 위하여 \\(y/x\\) 컬럼과 \\(y*x\\) 컬럼도 추가로 생성해 보았습니다. 표를 생성하는 데 사용된 소스코드는 아래와 같습니다. library(dplyr) library(kableExtra) x &lt;- 1:5 #시간 벡터 y &lt;- seq(from=4, by=4, length.out=5) #거리 벡터 direct_a &lt;- y/x #비례 상수 벡터 inverse_a &lt;- y*x #반비례 상수 벡터 walk_df &lt;- data.frame(x, y, direct_a, inverse_a) #데이터 프레임 생성 knitr::kable( walk_df, col.names = c(&#39;x (시간 h)&#39;, &#39;y (거리 km)&#39;, &#39;비례상수 y/x&#39;, &#39;반비례상수 x*y&#39;), #표 컬럼 이름 설정 booktabs = TRUE, align = &quot;c&quot;, #표 위치 설정 caption = &#39;시간과 거리의 관계 테이블&#39; #표 제목 설정 ) %&gt;% kable_styling(full_width=FALSE,font_size=15) #표 컬럼 간격 설정 표 4.2: 시간과 거리의 관계 테이블 x (시간 h) y (거리 km) 비례상수 y/x 반비례상수 x*y 1 4 4 4 2 8 4 16 3 12 4 36 4 16 4 64 5 20 4 100 위의 표에서 \\(y/x\\) 컬럼값이 일정한 수인 \\(4\\)이기 때문에 \\(x\\)변수가 증가할 수록 \\(y\\)변수도 \\(4\\)배 만큼 증가하는 관계에 있고, 두 변수가 이러한 관계를 가질 때 정비례 (direct proportion) 관계가 있다고 하고 수식으로 표현하면 아래와 같습니다. \\[y = ax \\quad \\Rightarrow \\quad \\frac{y}{x} = a \\quad (a \\neq 0)\\] 만약 \\(y*x\\) 컬럼값이 상수였다면, \\(x\\)변수가 증가할 수록 \\(y\\)변수가 감소하고 \\(x\\)변수가 감소할 수록 \\(y\\)변수가 증가하는 관계에 있고, 두 변수가 이러한 관계를 가질 때 반비례 (inverse proportion) 관계에 있다고 합니다. 위의 표의 경우에는 \\(y*x\\) 컬럼값이 일정한 상수 값이 아니기 때문에 두 변수의 관계를 설명하지 못합니다. 따라서, 두 변수가 반비례 관계에 있지 않습니다. seongcho가 \\(4km/h\\)의 속력으로 걸었을 때 \\(5\\)시간 걸려서 이동한 거리를 다음날에는 \\(10km/h\\)의 속력으로 뛰어서 \\(2\\)시간 걸렸고 그 다음날에는 자전거를 타고 \\(20km/h\\)의 속력으로 이동해서 \\(1\\)시간 걸렸다고 가정해 봅시다. 이 상황을 표로 표현해 보면 표 4.3과 같습니다. 주어진 \\(x\\) (속력)와 \\(y\\) (시간) 정보를 기반으로 두 변수들 간의 관계를 알아보기 위하여 \\(y/x\\) 컬럼과 \\(y*x\\) 컬럼도 추가로 생성해 보았습니다. 표를 생성하는 데 사용된 소스코드는 아래와 같습니다. library(dplyr) library(kableExtra) day &lt;- c(1:3) #일수 벡터 mode &lt;- c(&#39;walking&#39;, &#39;running&#39;, &#39;cycling&#39;) #이동 수단 벡터 x &lt;- c(4, 10, 20) #속력 벡터 y &lt;- c(5, 2, 1) #시간 벡터 direct_a &lt;- y/x #비례 상수 벡터 inverse_a &lt;- y*x #반비례 상수 벡터 speed_mode_df &lt;- data.frame(day, mode, x, y, direct_a, inverse_a) #데이터 프레임 생성 knitr::kable( speed_mode_df, #표 컬럼 이름 설정 col.names = c(&#39;일수 (day)&#39;,&#39;이동수단&#39;,&#39;x (속력 km/h)&#39;,&#39;y (시간 h)&#39;,&#39;비례상수 y/x&#39;,&#39;반비례상수 x*y&#39;), booktabs = TRUE, align = &quot;c&quot;, #표 위치 설정 caption = &#39;시간과 거리의 관계 테이블&#39; #표 제목 설정 ) %&gt;% kable_styling(full_width=FALSE,font_size=15) #표 컬럼 간격 설정 표 4.3: 시간과 거리의 관계 테이블 일수 (day) 이동수단 x (속력 km/h) y (시간 h) 비례상수 y/x 반비례상수 x*y 1 walking 4 5 1.25 20 2 running 10 2 0.20 20 3 cycling 20 1 0.05 20 위의 표에서 \\(y/x\\) 컬럼값은 일정한 수 (상수)를 가지지 못하는 반면 \\(y*x\\) 컬럼값은 상수인 \\(20\\)이기 때문에 \\(x\\)변수의 증가 비율만큼 \\(y\\)변수의 비율은 감소하는 관계에 있고, 두 변수가 이러한 관계를 가질 때 반비례 관계가 있다고 하고 식으로 표현하면 아래와 같습니다. \\[x \\times y = a \\quad \\Rightarrow \\quad y = \\frac{a}{x} \\quad (a \\neq 0)\\] 두 변수 간의 관계가 정비례인지 확인하는 함수 direct_func, 반비례인지 확인하는 함수 inverse_func, 그리고 두 개의 함수를 사용하여 결과를 화면에 출력하는 함수 print_relation를 생성하고 위의 표 4.2에 주어진 \\(x\\) (시간)와 \\(y\\) (거리) 변수의 관계와 표 4.3에 주어진 \\(x\\) (속력)와 \\(y\\) (시간) 변수의 관계가 각각 정비례인지 반비례인지 화면에 출력해 보았습니다. 이 작업에 사용된 소스코드는 아래와 같습니다. direct_func &lt;- function(x, y) { #정비례 관계일 때 TRUE를 반환하는 함수 a &lt;- y/x #정비례 관계일 때의 a a &lt;- unique(a) #a가 일정한 수이면 한 개의 숫자가 중복되므로 한 개의 숫자가 됨 if (length(a) == 1) return (TRUE) #a의 값이 한 개이면 정비례 else return (FALSE) } inverse_func &lt;- function(x, y) { #반비례 관계일 때 TRUE를 반환하는 함수 a &lt;- x*y #반비례 관계일 때의 a a &lt;- unique(a) #a가 일정한 수이면 한 개의 숫자가 중복되므로 한 개의 숫자가 됨 if (length(a) == 1) return (TRUE) #a의 값이 한 개이면 반비례 else return (FALSE) } print_relation &lt;- function(x,y) { if (direct_func(x,y)) { print(&quot;x와 y는 정비례합니다.&quot;) print(paste0(&#39;y = &#39;, unique(y/x), &#39;x&#39;)) } else if (inverse_func(x,y)) { print(&quot;x와 y는 반비례합니다.&quot;) print(paste0(&#39;y = &#39;, unique(x*y), &#39;/x&#39;)) } else { print(&quot;x와 y 사이의 관계를 알 수 없습니다.&quot;) } } x &lt;- 1:5 #시간 벡터 y &lt;- seq(from=4, by=4, length.out=5) #거리 벡터 print_relation(x,y) ## [1] &quot;x와 y는 정비례합니다.&quot; ## [1] &quot;y = 4x&quot; x &lt;- c(4, 10, 20) #속력 벡터 y &lt;- c(5, 2, 1) #시간 벡터 print_relation(x,y) ## [1] &quot;x와 y는 반비례합니다.&quot; ## [1] &quot;y = 20/x&quot; 이렇게 구해진 두 개의 식을 가지고 아래의 소스코드를 이용하여 그래프로 그려보면 그림 4.6와 같습니다. #정비례 그래프 x &lt;- seq(1, 20, 1) y &lt;- 4 * x ggplot() + geom_point(aes(x=x, y=y)) + geom_line(aes(x=x, y=y), color=&#39;dimgray&#39;) #반비례 그래프 x &lt;- c(seq(0.1,0.3,0.02),seq(0.4,2,0.1)) y &lt;- 20 / x ggplot() + #coord_fixed(ratio = 1) + geom_point(aes(x=x, y=y)) + geom_line(aes(x=x, y=y), color=&#39;dimgray&#39;) 그림 4.6: 시간과 거리의 정비례 그래프와 속력과 시간의 반비례 그래프 위의 그림에서는 \\(x\\)변수가 양수인 경우만 그래프에 표현하였지만, \\(x\\)변수가 음수인 경우 또한 그래프로 그려볼 수 있습니다. 또한 정비례식 \\(y = ax\\)와 반비례식 \\(y = \\frac{a}{x}\\) 모두 \\(a\\)값에 따라 그래프 모양이 달라집니다. 아래의 소스코드를 이용하여 \\(a\\)값이 변할 때 정비례 그래프와 반비례 그래프의 모양이 어떻게 변하는데 확인해 볼 수 있습니다 (그림 4.7). a 값에 따른 선 그래프 그룹을 생성하기 위하여 factor()함수로 인코딩하였기 때문에, factor(a)값은 \\(4\\)개의 레벨 (Levels: -3 -0.5 1 3) 그룹을 가지게 됩니다. factor()인코딩은 주로 문자 (문자열) 컬럼 벡터의 데이터를 인코딩할 때 주로 사용되지만, 특정 숫자 값이 반복 사용되는 패턴을 가지는 데이터에도 사용 가능합니다. #정비례 그래프 x &lt;- rep (c(-10:-1,1:10), time = 4) #-10에서 10 사이의 x변수 값 a &lt;- rep (c(-3, -0.5, 1, 3), each = 20) #4가지 a값 y &lt;- a * x #정비례 관계의 y값 계산 direct_df &lt;- data.frame(a, x, y) #데이터 프레임 생성 ggplot(direct_df) + geom_line(aes(x=x,y=y,color=factor(a),linetype=factor(a))) + geom_point(aes(x=0, y=0),color=&#39;dimgray&#39;) + annotate(geom=&quot;text&quot;,x=0,y=-3,label=&#39;O&#39;,color=&quot;dimgray&quot;,fontface=&#39;bold&#39;) + labs(color=&#39;a&#39;,linetype=&#39;a&#39;) #반비례 그래프 x &lt;- rep(c(seq(-2,-0.4,0.1),seq(-0.3,-0.1,0.01),seq(0.1,0.3,0.01),seq(0.4,2,0.1)),time=4) a &lt;- rep(c(-3, -0.5, 1, 3), each = 76) y &lt;- a / x #반비례 관계의 y값 계산 direct_df &lt;- data.frame(a, x, y) #데이터 프레임 생성 ggplot(direct_df) + #x=0일때는 식이 성립하지 않기 때문에 x &gt; 0인 경우와 x &lt; 0이 경우로 나누어서 선 그래프 생성 geom_line(aes(x= ifelse(x &gt; 0, x, NA), y=y,color=factor(a),linetype=factor(a))) + geom_line(aes(x= ifelse(x &lt; 0, x, NA), y=y,color=factor(a),linetype=factor(a))) + geom_point(aes(x=0, y=0),color=&#39;dimgray&#39;) + annotate(geom=&quot;text&quot;,x=0,y=-3,label=&#39;O&#39;,color=&quot;dimgray&quot;,fontface=&#39;bold&#39;) + labs(x=&#39;x&#39;, color=&#39;a&#39;,linetype=&#39;a&#39;) 그림 4.7: a값에 따른 정비례 그래프와 반비례 그래프의 변화 이번 장에서는 (\\(x\\),\\(y\\)) 좌표를 이용하여 두 변수 간의 관계를 그래프로 그려보고, 두 변수들 간의 관계 식을 이용하여 정비례 관계에 있는지 반비례 관계에 있는지 알아보았습니다. 두 변수의 관계를 측정하거나 기록할 때는 표의 형태를 사용하고, 기록된 두 변수들 간의 관계는 식 (비례식, 반비례식)으로 표현하거나 그래프를 그려서 파악해 보았습니다. 이러한 각 과정들이 소스코드로 어떻게 구현되는지도 알아보았습니다. 이제 5장 도형의 기초에 대하여 본격적으로 알아봅시다. https://en.wikipedia.org/wiki/Cogito,_ergo_sum↩ "],
["features-dimensions.html", "5 도형의 기초 5.1 기본 도형 5.2 작도와 합동", " 5 도형의 기초 점 (point), 선 (line), 면 (plane)이 이루는 도형과 여러 도형 위치 간의 관계, 그리고 평행선과 삼각형의 성질에 대하여 알아봅니다. RStudio가 열려 있지 않으면 RStudio를 실행하고 메뉴에서 File &gt;&gt; Open Project…를 클릭하여 이전에 저장한 R 프로젝트 파일인 rmath01.Rproj을 찾아서 선택하고 Open 버튼을 클릭하여 이전에 작업하던 프로젝트 환경을 로딩합니다. 파일탐색기나 파인더에서 rmath01.Rproj 파일을 찾아서 더블 클릭하여도 RStudio가 실행되면서 작업하던 프로젝트 환경이 로딩됩니다. 프로젝트 환경이 로딩된 후에 RStudio 콘솔창에 getwd()를 실행하여 작업 환경이 제대로 로딩되었는지 확인합니다. RStudio 환경이 잘 로딩되었으면, 이제 본격적으로 시작해 봅시다. 5.1 기본 도형 점, 선, 면이 이루는 도형과 도형의 위치 관계 그리고 선들 간의 관계에 대하여 알아봅니다. 5.1.1 점, 선, 면 점과 선의 관계를 알아본 후에 선과 면의 관계를 알아봅니다. 선은 무수히 많은 연속적인 점으로 이루어져 있습니다. 직선 상의 두 점 \\(A\\), \\(B\\) 사이에 점을 무수히 생성해 나가면 선이 생성됩니다. 다른 말로 하면, 점 \\(A\\)에서 움직이기 시작해서 점 \\(B\\)에서 멈추면 하나의 선이 생성됩니다. 두 점이 반드시 직선 상에 있어야 하는 것은 아니며, 좌표평면 상의 두 점 사이의 무수히 많은 연속적인 점들이 직선적인 움직임을 보여야 하는 것도 아닙니다. 점과 선의 관계를 보여 주는 그래프를 생성하는 소스코드를 작성해 보면 아래와 같습니다. gganimate패키지를 사용하면 ggplot()로 그려진 그래프에 시간 프레임 (time frame) 개념을 추가하여 움직이는 그림을 생성할 수 있습니다. 4.1절의 그림 4.1을 만드는데 사용된 소스코드를 조금 수정하고 여덟 단계로 나누어서 소스코드를 생성하였습니다. 전체 소스코드가 긴 것처럼 보이지만 단계 별로 나누어 보면 그렇게 복잡하거나 길지 않습니다. 각 단계 별 코드의 주석문을 참고하여 전체적인 흐름을 파악해보세요. 두 점의 이름과 좌표를 입력하고 두 점 사이에 무수히 많은 점의 좌표를 생성하고 데이터 프레임에 저장합니다. #install.packages(&quot;gganimate&quot;) library(gganimate) #ggplot 애니메이션을 위한 패키지 로딩 #두 점 정보 입력 (변경 가능) xtext &lt;- c(&#39;A&#39;, &#39;B&#39;) #두 점 이름 벡터 x &lt;- c(-5, 5) #두 점 좌표 벡터 #각 점 좌표와 이름을 ggplot에서 이해하기 쉽게 변수 이름 설정 A &lt;- x[1] #첫 번째 점 좌표 B &lt;- x[2] #두 번째 점 좌표 Aname &lt;- xtext[1] #첫 번째 점 이름 Bname &lt;- xtext[2] #두 번째 점 이름 #점진적인 변화를 보여주기 위한 벡터와 데이터 프레임 xm &lt;- seq(A, B, 0.1) #A와 B 사이에 무수히 많은 점 좌표 생성 point_df &lt;- data.frame(x=xm) #xm 벡터를 컬럼으로 가지는 데이터 프레임, 컬럼명은 &#39;x&#39; 그래프에 직선 축을 그리고 원점을 표시합니다. p1 &lt;- ggplot(point_df) + #데이터 프레임 없이 각 그래프 요소에서 벡터를 사용하여 그래프 생성 ylim(A, B) + #x축과 y축 폭을 동일하게 설정 #직선 (좌표축) + 오른쪽 화살표 추가 annotate(&quot;segment&quot;,x=A-1,xend=B+1, y=0, yend=0, size=0.5, color=&#39;dimgray&#39;, arrow=arrow(length=unit(0.2,&quot;cm&quot;))) + #왼쪽 화살표 추가 annotate(&quot;segment&quot;,x=A-1,xend=A-1, y=0, yend=0, size=0.5, color=&#39;dimgray&#39;,arrow=arrow(length=unit(0.2,&quot;cm&quot;))) + #원점 눈금 추가 annotate(&quot;segment&quot;,x=0,xend=0,y=-0.1,yend=0.1,size=0.2,color=&#39;black&#39;) + #원점 좌표와 점 이름 &#39;O&#39; 추가 annotate(&#39;text&#39;,x=0,y=c(-0.5,0.5),label=c(&#39;0&#39;,&#39;O&#39;),size=5,color=&#39;black&#39;) p1 #그래프 확인 그래프에 두 점 \\(A\\), \\(B\\)를 빨간색 점으로 추가하고 두 점 사이의 공간에 선이 생성될 부분을 회색으로 표현합니다. p2 &lt;- p1 + #각 점의 좌표와 점 이름 추가 annotate(&#39;text&#39;,x=c(A,B),y=c(-0.5,-0.5),label=c(A,B),size=5, color=&#39;black&#39;) + annotate(&#39;text&#39;,x=c(A,B),y=c(0.5,0.5),label=c(Aname,Bname),size=5, color=&#39;black&#39;) + #생성될 선의 윤각 추가 annotate(&quot;segment&quot;, x=A,xend=B, y=0, yend=0, size=2, color=&#39;gray&#39;) + #두 점과 두 점의 눈금 추가 annotate(&quot;pointrange&quot;,x=c(A,B),y=0,ymin=-0.2,ymax=0.2,colour=&#39;red&#39;,size=0.5) p2 그래프의 기본 배경 정보를 제거합니다. p3 &lt;- p2 + #필요 없는 축 정보 등을 모두 보이지 않도록 설정 theme_void() p3 #그래프 확인 p3에 점 \\(A\\)에서 부터 점 \\(B\\) 방향으로 이동하면서 생성되는 점과 선들 중 하나의 예로 좌표가 \\(-3\\)인 경우를 추가로 그려봅니다. p4 &lt;- p3 + annotate(&quot;segment&quot;,x=min(point_df$x),xend=-3,y=0,yend=0,size=2,color=&#39;black&#39;) + #geom_line(aes(x=xm,y=0), color=&#39;black&#39;, size=2) + #각 점 추가 geom_point(x=-3, y=0,color=&#39;red&#39;,size=3) + #각 점 이름 추가 geom_text(x=-3, y=0.3, label=sprintf(&#39;%1.1f&#39;,-3), color=&quot;black&quot;) p4 #그래프 확인 p3으로 돌아와서, 점 \\(A\\)에서 부터 점 \\(B\\) 방향으로 이동하면서 생성되는 무수히 많은 점과 선들을 추가합니다. p5 &lt;- p3 + annotate(&quot;segment&quot;,x=min(point_df$x),xend=point_df$x,y=0,yend=0,size=2,color=&#39;black&#39;) + #geom_line(aes(x=xm,y=0), color=&#39;black&#39;, size=2) + #각 점 추가 geom_point(aes(x=x, y=0),color=&#39;red&#39;,size=3) + #각 점 이름 추가 geom_text(aes(x=x, y=0.3, label=sprintf(&#39;%1.1f&#39;,x)), color=&quot;black&quot;, size=4, fontface = &quot;bold&quot;) p5 #그래프 확인 시간 프레임으로 사용할 숫자 벡터를 transition_time()의 입력값으로 하여 실행하면 움직이는 그림이 생성됩니다. p5생성 시 사용된 점들과 선들 추가 시 움직이는 그림을 생성하기 위해 시간 프레임 입력값과의 연관성이 이미 고려되었기 때문에 p5의 무수히 많은 점과 선들은 특정 시간 프레임에서는 하나의 점과 선 (시작점부터 현재점까지의 연결선)으로 표현됩니다. p6 &lt;- p5 + #동영상 생성을 위한 프레임 설정 transition_time(point_df$x) p6 anim_save(&quot;point-to-line.gif&quot;) # 파일로 저장 생성된 움직이는 그림은 직선 상의 움직이는 점을 표현한 것이기 때문에, 그림 파일의 윗부분과 아래부분에 여백이 많습니다. magick패키지를 이용하여 저장된 그림파일에서 원하는 부분만 추출하여 새로운 그림 파일을 생성합니다. #install.packages(&quot;magick&quot;) library(magick) line &lt;- image_read(&quot;point-to-line.gif&quot;) #&quot;480x480&quot; 크기의 영상 왼쪽 제일 위에서 시작해서 #오른쪽으로 +0만큼 아래쪽으로 +190만큼 이동한 후 &quot;480x100&quot; 영상 생성 #결과적으로 gif 이미지의 위쪽 여백과 아래쪽 여백만 없앰 line2 &lt;- image_crop(line, &quot;480x100+0+190&quot;) image_write(line2, &quot;point-to-line2.gif&quot;) 위의 소스코드의 세부적인 함수 입력값 하나 하나까지 이해할 필요는 없습니다. 세부적인 함수의 입력값이 궁금한 경우 도움말을 참조할 수 있습니다. 예를 들어, annotate() 함수의 여러 입력값에 대하여 궁금하다면 콘솔창에서 ?annotate를 입력하고 엔터를 누릅니다. RStudio의 그림정보창 (Plots)옆에 위치한 도움말창 (Help) 상단에 위치한 검색창에 annotate를 입력하고 엔터를 눌려도 동일한 결과를 얻을 수 있습니다. 위의 여덟 단계를 거쳐서 그림 5.1이 생성되었습니다. RStudio의 콘솔창에서 p1, p2, p3, p4, p5, p6를 각각 실행해보며 그래프의 변화를 확인해 봅시다. 그림 5.1: 무수히 많은 점으로 이루어진 선 p5생성 부분의 코드 첫 줄을 p5 &lt;- p3 +에서 p5 &lt;- ggplot(point_df) + ylim(A, B) +로 변경하고 p5, p6를 각각 다시 한번 실행하여 보면, p5, p6 만으로 도 움직이는 그림을 만들 수 있습니다. p5, p6부분이 위의 소소코드의 핵심 부분으로, p1, p2, p3, p4 부분은 생략할 수 있습니다. 데이터 시각화를 위한 소스코드 생성 시에는 p5, p6부분과 같은 핵심 부분에 집중하여 핵심 로직을 먼저 만들고 그 다음에 그래프를 꾸미는 부분들이 추가되는 순서로 코드를 작성하는 것이 좋습니다. 이제, 선과 면의 관계로 넘어가 봅시다. 선이 무수히 많은 연속적인 점으로 이루어져 있는 것처럼, 면은 무수히 많은 연속적인 선으로 이루어져 있습니다. 평면 상의 두 선 \\(A\\), \\(B\\) 사이에 선을 무수히 생성해 나가면 면이 생성됩니다. 다른 말로 하면, 선 \\(A\\)에서 움직이기 시작해서 선 \\(B\\)에서 멈추면 하나의 면이 생성됩니다. 두 선이 반드시 같은 높이이거나 선이 움직일 때 직선적인 움직임을 보여야 하는 것도 아닙니다. 선과 면의 관계를 보여 주는 그래프를 생성하기 위하여 위의 점과 선의 관계 그래프 생성에 사용한 소스코드를 수정하고 곡선적인 움직임을 보이는 경우까지 고려하여 일곱 단계로 나누어서 소스코드를 생성하였습니다. 각 단계 별 코드의 주석문을 참고하여 전체적인 흐름을 파악해보세요. 두 선의 이름과 좌표를 입력하고 두 선 사이에 움직임을 표현하는 함수 세 개 중 하나를 선택하여 무수히 많은 선의 \\(x\\),\\(y\\) 좌표를 생성합니다. #install.packages(&quot;gganimate&quot;) library(gganimate) #ggplot 애니메이션을 위한 패키지 로딩 #두선 정보 입력 (변경 가능) linetext &lt;- c(&#39;A&#39;,&#39;B&#39;) #두선 이름 벡터 x &lt;- c(1,10) #두선 x좌표 벡터 #세 개의 함수 중 하나만 선택하여 실행 가능하도록 # 제거, 나머지 두 개는 주석 처리 func &lt;- function(x) {return (rep(1,length(x)))} #y=1 #func &lt;- function(x) {return (0.5 * x)} #y=0.5*x #func &lt;- function(x) {return (5 / x)} #y=5/x #각 선의 좌표와 이름을 ggplot에서 이해하기 쉽게 변수 이름 설정 x1 &lt;- x[1] x2 &lt;- x[2] dx &lt;- x2 - x1 #입력된 두 x1, x2 좌표의 간격을 구함 dy &lt;- dx #dx를 이용하여 y1, y2 좌표 간격 설정 Aname &lt;- linetext[1] #첫 번째 점 이름 Bname &lt;- linetext[2] #두 번째 점 이름 #점진적인 변화를 보여주기 위한 벡터와 데이터 프레임 #무수히 많은 x 좌표 생성 xm &lt;- seq(x1, x2, 0.1) #세 번째 입력값을 0.1에서 0.5나, 1로 변경하고 실행 결과 확인하기 y1 &lt;-func(xm) #생성된 x 좌표를 위의 함수에 적용하여 같은 수의 y1 좌표 생성 y2 &lt;- y1 + dy #생성된 y1 좌표와 dy를 이용하여 같은 수의 y2 좌표 생성 생성된 xm, y1, y2 좌표 벡터를 이용하여 특정 시간 프레임 i의 선과 이전 시간 프레임 i-1의 선으로 생성되는 면을 그려봅니다. i = 10 #i-1의 선 좌표 생성 A(xm[i-1], y1[i-1]), B(xm[i-1], y2[i-1]) #i의 선 좌표 생성 C(xm[i], y1[i]), D(xm[i], y2[i]) ggplot() + xlim(min(xm),max(xm)) + #위의 A,B,C,D 4개의 좌표를 꼭짓점으로 하는 사각형이 생성되도록 좌표 생성, A-B-D-C 순으로 geom_polygon(aes(x=c(xm[i-1],xm[i-1],xm[i],xm[i]), y=c(y1[i-1],y2[i-1],y2[i],y1[i])), colour=&quot;lightblue&quot;, fill=&#39;lightblue&#39;) + #i-1의 선과 i의 선 생성 annotate(&quot;segment&quot;,x=xm[i-1],xend=xm[i-1],y=y1[i-1],yend=y2[i-1],color=&#39;red&#39;,size=0.1) + annotate(&quot;segment&quot;,x=xm[i],xend=xm[i],y=y1[i],yend=y2[i],color=&#39;red&#39;,size=0.1) 생성된 xm, y1, y2 좌표 벡터와 위에서 테스트해 본 면 생성 로직을 이용하여 전체 시간 프레임을 포함하는 면 데이터 프레임을 생성하고 시각화 합니다. poly_df &lt;- data.frame(x=numeric(), y=numeric(), xm=numeric()) for (i in 2:length(xm)) { #데이터 프레임에 사각형 4개의 좌표를 4개의 행으로 추가 poly_df &lt;- rbind(poly_df,data.frame(x=xm[i-1],y=y1[i-1],xm=xm[i])) poly_df &lt;- rbind(poly_df,data.frame(x=xm[i-1],y=y2[i-1],xm=xm[i])) poly_df &lt;- rbind(poly_df,data.frame(x=xm[i],y=y2[i],xm=xm[i])) poly_df &lt;- rbind(poly_df,data.frame(x=xm[i],y=y1[i],xm=xm[i])) } p0 &lt;- ggplot(poly_df) + #각 시간 프레임별 면 생성 geom_polygon(aes(x=x,y=y,group=xm), colour=&quot;lightblue&quot;, fill=&#39;white&#39;) + #전체 시간 프레임이 만들어내는 전체 면 생성 annotate(&quot;polygon&quot;,x=c(xm,rev(xm)),y=c(y2,rev(y1)),color=&#39;lightblue&#39;,size =2,fill=NA) + #두 선 추가 annotate(&quot;segment&quot;,x=x, xend=x,y=c(y1[1],y1[length(y1)]),yend=c(y2[1],y2[length(y2)]), colour=&#39;red&#39;,size=0.5) p0 #그래프 확인 각 시간 프레임 별 면을 생성하는 로직이 완성되었습니다. 이제 본격적으로 그래프를 생성하고 \\(x\\), \\(y\\) 좌표 축을 그래프에 추가합니다. p1 &lt;- ggplot(poly_df) + xlim(ifelse(x1&gt;0,0,x1-1), x2+1) + #x축과 y축 폭을 동일하게 설정 ylim(ifelse(min(y1)&gt;0,0,min(y1)-1), max(y2)+1) + #x축과 y축 폭을 동일하게 설정 coord_fixed(ratio = 1) + #x축 선과 화살표 추가 annotate(&quot;segment&quot;,x=ifelse(x1&gt;0,0,x1-1),xend=x2+1, y=0, yend=0, size=0.5, color=&#39;dimgray&#39;, arrow=arrow(length=unit(0.2,&quot;cm&quot;))) + #y축 선과 화살표 추가 annotate(&quot;segment&quot;,x=0,xend=0, y=ifelse(min(y1)&gt;0,0,min(y1)-1), yend=max(y2)+1, size=0.5, color=&#39;dimgray&#39;, arrow=arrow(length=unit(0.2,&quot;cm&quot;))) p1 #그래프 확인 두 선과 두 선이 생성할 면의 윤각을 그래프에 추가합니다. p2 &lt;- p1 + #생성될 면의 윤곽 추가 annotate(&quot;polygon&quot;,x=c(xm,rev(xm)),y=c(y1,rev(y2)),color=&#39;gray&#39;,fill=&#39;gray&#39;,alpha=0.5) + #두 선 추가 annotate(&quot;segment&quot;,x=x, xend=x,y=c(y1[1],y1[length(y1)]),yend=c(y2[1],y2[length(y2)]), colour=&#39;red&#39;,size=0.5) + #각 선의 x좌표와 점 이름 추가 annotate(&#39;text&#39;,x=c(x1,x2),y=c(y1[1]-0.5,y1[length(y1)]-0.5),label=c(x1,x2), size=5,color=&#39;black&#39;) + annotate(&#39;text&#39;,x=c(x1,x2),y=c(y2[1]+0.5,y2[length(y2)]+0.5),label=c(Aname,Bname), size=5,color=&#39;black&#39;) p2 각 시간 프레임 별 선과 면을 그래프에 추가합니다. p3 &lt;- p2 + geom_polygon(aes(x=x,y=y,group=xm), color=&#39;lightblue&#39;, fill=&#39;lightblue&#39;) + #각 선 추가 annotate(&quot;segment&quot;,x=xm,xend=xm,y=y1,yend=y2,color=&#39;red&#39;,size=0.5) + #각 점 이름 추가 geom_text(aes(x=xm, y=func(xm)-0.5, label=sprintf(&#39;%1.1f&#39;,xm)), color=&quot;black&quot;, size=4, fontface = &quot;bold&quot;) p3 시간 프레임으로 사용할 숫자 벡터를 transition_reveal()의 입력값으로 하여 실행하면 움직이는 그림이 생성됩니다. p4 &lt;- p3 + #동영상 생성을 위한 프레임 설정 transition_reveal(xm) p4 anim_save(&quot;line-to-polygon1.gif&quot;) # Save as gif 위의 일곱 단계를 거쳐서 정사각형 모양의 도형이 완성되었습니다. \\(x\\)축을 따라 빨간색 직선이 이동하면서 정사각형의 모양을 그리게 되는데, 빨간색 직선의 아래 부분 끝점은 직선 그래프 \\(y = 1\\)를 따라 이동하게 됩니다. 첫 번째 단계의 코드 중 func부분을 아래와 같이 \\(y = 1\\)관련 라인은 주석문 처리하고 \\(y = 0.5 \\times x\\)관련 라인은 주석문 해제하여 실행 가능하도록 변경하고 위의 일곱 단계를 처음 부터 다시 반복하면 평행사변형 모양의 도형을 얻을 수 있습니다. 이번에도, \\(x\\)축을 따라 빨간색 직선이 이동하면서 평행사변형 모양을 그리게 되는데, 빨간색 직선의 아래 부분 끝점은 직선 그래프 \\(y = 0.5 \\times x\\)를 따라 이동하게 됩니다. #세 개의 함수 중 하나만 선택하여 실행 가능하도록 # 제거, 나머지 두 개는 주석 처리 #func &lt;- function(x) {return (rep(1,length(x)))} #y=1 func &lt;- function(x) {return (0.5 * x)} #y=0.5*x #func &lt;- function(x) {return (5 / x)} #y=5/x 첫 번째 단계의 코드 중 func부분을 아래와 같이 \\(y = 0.5 \\times x\\)관련 라인은 다시 주석문 처리하고 \\(y = 5 / x\\)관련 라인은 주석문 해제하여 실행 가능하도록 변경하고 위의 일곱 단계를 처음 부터 또 다시 반복하면 곡선을 변으로 가지는 도형을 얻을 수 있습니다. 이번에도, \\(x\\)축을 따라 빨간색 직선이 이동하면서 도형을 그리게 되는데, 빨간색 직선의 아래 부분 끝점은 직선 그래프 \\(y = 5 / x\\)를 따라 곡선을 그리며 이동하게 됩니다. #세 개의 함수 중 하나만 선택하여 실행 가능하도록 # 제거, 나머지 두 개는 주석 처리 #func &lt;- function(x) {return (rep(1,length(x)))} #y=1 #func &lt;- function(x) {return (0.5 * x)} #y=0.5*x func &lt;- function(x) {return (5 / x)} #y=5/x 이렇게 위의 일곱 단계를 세 번 반복하면 세 개의 다른 도형을 그리는 움직이는 그림을 생성할 수 있습니다 (그림 5.2). 위의 일곱 번째 단계에서 시간 프레임을 사용하기 위하여 transition_time()함수 대신 transition_reveal()함수를 사용한 이유는 세 번째 도형의 곡면 부분을 그리는 움직임을 표현하기 위해서 입니다. 선이 곡선 위를 움직이는 경우, 효율적인 면 표현을 위하여 특정 시간 프레임i가 보여 주는 면을 생성할 때 전체면 (선 \\(A\\)부터 현재 움직이는 선이 만들어낸 면) 대신에 시간 프레임 i의 선과 이전 시간 프레임 i-1의 선이 만들어내는 면을 사용했습니다 (위의 두 번째 단계 참고). 이러한 경우, 특정 시간 프레임이 지나면 이전 시간 프레임에서 만들어 진 면을 모두 보여 주는 transition_reveal()함수를 사용하여야 원하는 움직이는 그림을 만들어 낼 수 있습니다. 두 함수의 차이를 알고 싶으면 일곱 번째 단계의 p4 &lt;- p3 + transition_reveal(xm)부분을 p4 &lt;- p3 + transition_time(xm)로 변경하고 실행해 보세요. 그림 5.2: 무수히 많은 선으로 이루어진 면 (세가지 경우) 이제 점으로 이루어진 선과 선으로 이루어진 면을 직접 그려봅시다. 아래의 소스코드와 같이 두 패키지 mapedit와 mapview를 설치하고 로딩한 후에 editMap(mapview())를 실행하면 RStudio의 뷰어창에 지도 화면이 나타납니다. 확대 버튼과 축소 버튼 그리고 마우스를 이용하여 여러분의 집과 학교에 화면에 나타나도록 지도를 확대, 축소, 이동해 봅시다. 일단 아시아 대륙이 보일 때까지 화면을 축소합니다. 그 다음에 확대 버튼이나 마우스 더블 클릭을 이용하여 대한민국 지역을 확대하고 여러분이 살고 있는 시, 동으로 확대해 갑니다. 축소 버튼 밑부분에 있는 레이어 버튼을 이용하면 배경지도 (한글 지도, 위성영상 지도)를 바꾸어 볼 수 도 있습니다. 지도 영역을 여러분의 집과 학교가 나오도록 적절히 조정되었으면, 지도화면 왼쪽 부분에 있는 선, 다각형 그리기 버튼을 이용하여 등교길 (선)이나 학교 운동장 (다각형)을 도형으로 그려봅시다. 도형을 다 그린 후에는 Done 버튼을 눌러서 작업을 끝냅니다. #install.packages(&quot;mapedit&quot;) #처음 패키지 사용 시 설치 library(mapedit) #install.packages(&quot;mapview&quot;) #처음 패키지 사용 시 설치 library(mapview) myfeatures &lt;- editMap(mapview()) 아래 두 개의 소스코드 중 하나를 이용하여 위에서 그린 도형을 다시 지도 위에 그려 볼 수 있습니다. 두 개의 소스코드가 하는 일은 동일합니다. mapview(sf::st_union(myfeatures$finished)) library(dplyr) library(sf) myfeatures$finished %&gt;% #dplyr 패키지를 로딩하여 파이프라인 (%&gt;%) 사용 가능 st_union() %&gt;% #sf 패키지를 로딩하였으므로 sf::st_union() 대신 st_union()로 사용 가능 mapview() 지금까지 무수히 많은 점이 생성하는 선과 무수히 많은 선이 생성하는 면에 대해서 알아보았습니다. 이제 두 개의 다른 도형이 서로 교차하는 지점에 생성되는 도형에 대해서 알아봅시다. 점, 선, 면으로 이루어진 두 도형이 서로 교차하면서 생기는 점, 선, 면을 각각 교점 (intersection point), 교선 (intersection line), 교면 (intersection area)이라고 합니다. sf패키지의 st_intersection()함수를 이용하면 두 도형에 교차되는 지점에 대한 정보를 구해볼 수 있을 뿐만 아니라 교차 지점 정보 그 자체도 도형으로 표현할 수 있기 때문에 교점, 교선, 교면을 그래프에 그려볼 수 있습니다. 도형과 도형의 교차 관계를 점과 선이 교차, 선과 선의 교차, 선과 면의 교차, 면과 면의 교차로 나누어 살펴보겠습니다. 먼저, 점과 선이 만나서 생기는 교점을 구해보겠습니다. 아래 소스코드와 같이 \\(1\\)개의 직선 l과 \\(8\\)개의 점들 A8을 생성하고 직선과 점들이 교차하는 지점 i를 구해보면 \\(3\\)개의 교점이 생성되는 것을 알 수 있습니다. library(sf) #선 l의 꼭짓점 좌표 cbind(c(x1,x2),c(y1,y1))) l &lt;- st_linestring(cbind(c(0,10),c(0,0))) #8개 점들 A8의 좌표 cbind(c(x1,x2,x3,x4,x5,x6,x7,x8),c(y1,y2,y3,y4,y5,y6,y7,y8)) A8 &lt;- st_multipoint(cbind(c(0,1,2,4,6,7,9,10),c(1,0,1,-1,1,0,0,1))) #l과 a8 사이의 교차 부분 도형 생성 i &lt;- st_intersection(l,A8) i #3개의 교점 정보 확인 ## MULTIPOINT ((1 0), (7 0), (9 0)) 아래의 소스코드와 같이 sf패키지의 plot()함수를 이용하면 직선 l과 점들 A8, 그리고 교점 i의 상대적 위치를 그림으로 표현해 볼 수 있습니다. opar &lt;- par(mfrow = c(1, 2)) #두 개의 그림을 옆으로 나란히 #왼쪽 그림: 교점 추가 전 plot(l, ylim = c(-2,2)) #선 a는 검은색 plot(A8, add = TRUE, pch = 19, col=&#39;red&#39;) #점들은 빨간색 #오른쪽 그림: 교점 추가 후 plot(l, ylim = c(-2,2)) plot(a8, add = TRUE, pch = 19, col=&#39;red&#39;) plot(i, add = TRUE, pch = 19, col = &#39;green&#39;) #교점은 녹색 그림 5.3의 오른쪽 부분은 직선 l과 점들 A8의 상대적 위치를 보여주고, 왼쪽 부분은 직선 l과 점들 A8의 교점 i의 위치를 보여 줍니다. \\(8\\)개의 점들 중에서 왼쪽에서 두 번째 점 A8[2, ], 여섯 번째 점 A8[6, ], 일곱 번째 점 A8[7, ]만 직선 l과 만납니다. 그림 5.3: 점과 선이 만나서 생기는 교점 두 번째로 선과 선이 만나서 생기는 교점과 교선을 구해보겠습니다. 위에서 사용한 직선 l과 \\(8\\)개의 점들 A8을 이어서 생성된 꺽은선 m, 그리고 두 선의 교차 부분 i를 구해보면 \\(3\\)개의 교점과 \\(1\\)개의 교선이 생성되는 것을 알 수 있습니다. library(sf) #선 l의 꼭짓점 좌표 cbind(c(x1,x2),c(y1,y1))) l &lt;- st_linestring(cbind(c(0,10),c(0,0))) #선 m의 꼭짓점 좌표 cbind(c(x1,x2,x3,x4,x5,x6,x7,x8),c(y1,y2,y3,y4,y5,y6,y7,y8)) m &lt;- st_linestring(cbind(c(0,1,2,4,6,7,9,10),c(1,0,1,-1,1,0,0,1))) #l과 m 사이의 교차 부분 도형 생성 i &lt;- st_intersection(l,m) i #3개의 교점과 1개의 교면 정보 확인 ## GEOMETRYCOLLECTION (POINT (1 0), POINT (3 0), POINT (5 0), LINESTRING (7 0, 9 0)) 아래의 소스코드를 이용하면 그림 5.4와 같이 두 선의 교차 부분을 그림으로 표현해 볼 수 있습니다. opar &lt;- par(mfrow = c(1, 2)) #두 개의 그림을 옆으로 나란히 #왼쪽 그림: 교점과 교선 추가 전 plot(l, ylim = c(-2,2)) plot(m, add = TRUE, pch = 19, col=&#39;red&#39;) #오른쪽 그림: 교점과 교선 추가 후 plot(l, ylim = c(-2,2)) plot(m, add = TRUE, pch = 19, col=&#39;red&#39;) plot(i, add = TRUE, pch = 19, col = &#39;green&#39;, lwd = 2) 그림 5.4: 선과 선이 만나서 생기는 교점과 교선 세 번째로 선과 면이 만나서 생기는 교점과 교선을 구해보겠습니다. 위의 직선 l을 한 변으로 하는 사각형 면 P와 꺽은선 m의 교차 부분 i를 구해보면 \\(1\\)개의 교점과 \\(2\\)개의 교선이 생성되는 것을 알 수 있습니다. library(sf) #사각형 면 P의 꼭짓점 좌표 list(cbind(c(x1,x2,x3,x4,x1),c(y1,y2,y3,y4,y1) P &lt;- st_polygon(list(cbind(c(0,10,10,0,0),c(0,0,-2,-2,0)))) #선 m의 꼭짓점 좌표 cbind(c(x1,x2,x3,x4,x5,x6,x7,x8),c(y1,y2,y3,y4,y5,y6,y7,y8)) m &lt;- st_linestring(cbind(c(0,1,2,4,6,7,9,10),c(1,0,1,-1,1,0,0,1))) #P와 m 사이의 교차 부분 도형 생성 i &lt;- st_intersection(P,m) i #1개의 교점과 두 개의 교선 정보 확인 ## GEOMETRYCOLLECTION (POINT (1 0), LINESTRING (7 0, 9 0), LINESTRING (3 0, 4 -1, 5 0)) 아래의 소스코드를 이용하면 한 개의 사각형 면과 한 개의 꺽은선이 교차하는 부분에 생성되는 교점과 교선을 그림으로 표현해 볼 수 있습니다 (그림 5.5). opar &lt;- par(mfrow = c(1, 2)) #두 개의 그림을 옆으로 나란히 #왼쪽 그림: 교점과 교선 추가 전 plot(P, ylim = c(-2,2)) plot(m, add = TRUE, pch = 19, col=&#39;red&#39;) #오른쪽 그림: 교점과 교선 추가 후 plot(P, ylim = c(-2,2)) plot(m, add = TRUE, pch = 19, col=&#39;red&#39;) plot(i, add = TRUE, pch = 19, col = &#39;green&#39;, lwd = 2) 그림 5.5: 선과 면이 만나서 생기는 교점과 교선 네 번째로 면과 면이 만나서 생기는 교점과 교선, 그리고 교면을 구해보겠습니다. 직사각형 면 P와 꺽은선 m을 한 변으로 하는 다각형 면 Q의 교차 부분 i를 구해보면 \\(1\\)개의 교점과 \\(1\\)개의 교선, 그리고 \\(1\\)개의 교면이 생성되는 것을 알 수 있습니다. library(sf) #사각형 면 P의 꼭짓점 좌표 list(cbind(c(x1,x2,x3,x4,x1),c(y1,y2,y3,y4,y1) P &lt;- st_polygon(list(cbind(c(0,10,10,0,0),c(0,0,-2,-2,0)))) #다각형 면 Q의 꼭짓점 좌표 cbind(c(x1,x2,x3,...,x8,x9,x10,x1),c(y1,y2,y3,...,y8,y9,y10,y1)) Q &lt;- st_polygon(list(cbind(c(0,1,2,4,6,7,9,10,10,0,0),c(1,0,1,-1,1,0,0,1,2,2,1)))) #P와 Q 사이의 교차 부분 도형 생성 i &lt;- st_intersection(P,Q) i #1개의 교점, 1개의 교선, 1개의 교면 정보 확인 ## GEOMETRYCOLLECTION (POINT (1 0), LINESTRING (7 0, 9 0), POLYGON ((3 0, 5 0, 4 -1, 3 0))) 아래의 소스코드를 이용하면 한 개의 사각형 면과 한 개의 다각형 면이 교차하는 부분에 생성되는 교점과 교선, 그리고 교면을 그림으로 표현해 볼 수 있습니다 (그림 5.6). #왼쪽 그림: 교점, 교선, 교면 추가 전 plot(P, ylim = c(-3,3)) plot(Q, add = TRUE, pch = 19, border=&#39;red&#39;) #오른쪽 그림: 교점, 교선, 교면 추가 후 plot(P, ylim = c(-3,3)) plot(Q, add = TRUE, pch = 19, border=&#39;red&#39;) plot(i, add = TRUE, pch = 19, col = &#39;green&#39;, border = &#39;green&#39;, lwd = 2) 그림 5.6: 면과 면이 만나서 생기는 교점과 교선, 그리고 교면 이전의 소스코드에서는 ggplot()패키지에 익숙해지기 위해서 간단한 그래프를 그릴 때에도 ggplot()를 사용해왔지만, 위의 교점, 교선, 교면 소스코드에서 살펴본 것처럼 간단한 그래프를 그려볼 때에는 plot()를 사용할 수 있습니다. 콘솔창에 ?plot을 입력하고 실행하면 도움말창에 plot()함수를 포함하는 두 개의 패키지 정보가 아래와 같이 나타납니다. plot sf object in package sf: sf패키지에서는 점 (st_point), 점들 (st_multipoint), 선 (st_linestring), 면 (st_polygon) 등의 공간 도형 객체 (sf objects)들을 plot()함수의 입력값으로 직접 사용할 수 있습니다. Generic X-Y Plotting in package graphics: R이 제공하는 기본 패키지인 graphics에서는 \\(x\\), \\(y\\) 좌표로 이루어진 점과 선 등의 정보들을 plot()함수의 입력값으로 사용하여 간단히 그래프를 그려볼 수 있습니다. 예를 들어, 두 점 (\\(2\\),\\(0\\))과 (\\(6\\),\\(0\\))을 그래프에 추가할 경우 첫 번째 입력값은 c(2,6), 두 번째 입력값은 c(0,0)이 됩니다. 직선의 개념을 직선(straight line, line), 반직선 (half-line, ray), 선분 (line segment)으로 세분화하기 위하여 R의 기본 패키지인 graphics에서 제공하는 plot()함수를 이용하여 점 \\(A\\)와 \\(B\\) 사이는 지나는 직선을 그린 다음, 이를 기준으로 반직선과 선분의 개념을 설명해 보겠습니다. 서로 다른 두 점 \\(A\\)(\\(2\\),\\(0\\))와 \\(B\\)(\\(6\\),\\(0\\))를 지나는 직선을 끝없이 연장한 직선 \\(l\\)을 그리는 소스코드는 아래와 같습니다. 두 점 \\(A\\)와 \\(B\\)를 넘어서 끝없이 곧게 이어지는 직선을 유한한 공간에 그림으로 표현하기 위해서 직선의 시작점과 끝점의 좌표는 (\\(0\\),\\(0\\))와 (\\(8\\),\\(0\\))로 잡았습니다 (그림 5.7의 직선 \\(l\\)). 직선 \\(l\\)을 기호로 나타내면 \\(\\overleftrightarrow{AB}\\) 입니다. 이때 아래의 공식이 성립합니다. \\[l = \\overleftrightarrow{AB} = \\overleftrightarrow{BA}\\] opar &lt;- par(mfrow = c(1, 1)) #한번에 한 개의 그림만 #opar &lt;- par(mfrow = c(1, 4)) #네 개의 그림을 옆으로 나란히 #library(graphics) #기본 함수라서 로딩하지 않아도 자동으로 로딩됨 #(0,0) 좌표와 (8,0)좌표를 이용하여 선을 생성, &quot;l&quot; : 라인 타입, 축 정보 없이 plot(c(0,8),c(0,0),type=&quot;l&quot;,xlim=c(-0.5,8),ylim =c(-2,2),axes=FALSE,xlab=&#39;&#39;,ylab=&#39;&#39;) #점(2,0)과 점(6,0) 위치에 점 추가, pch=19: 포인트 심볼, 파란색 points(c(2,6),c(0,0),pch=19,col=&#39;blue&#39;) #&#39;l&#39;은 (-0.5,0) 위치에 이탤릭체로 추가, &#39;A&#39;은 (2,-0.5) 위치에 추가 , &#39;B&#39;는 (6,-0.5) 위치에 추가 text(c(-0.5,2,6), c(0,-0.5,-0.5),c(expression(italic(&#39;l&#39;)),&#39;A&#39;,&#39;B&#39;)) 점 \\(A\\)에서 시작하여 점 \\(B\\) 쪽으로 끝없이 곧게 연장한 선 \\(m\\)을 반직선이라고 부르고 기호로는 \\(\\overrightarrow{AB}\\) 로 나타냅니다. 반대로 점 \\(B\\)에서 시작하여 점 \\(A\\) 쪽으로 끝없이 곧게 연장한 선 \\(n\\) 또한 반직선이라고 부르고 기호로는 \\(\\overrightarrow{BA}\\) 로 나타냅니다. 두 반직선 \\(m\\)과 \\(n\\)은 시작점과 연장 방향이 서로 다르기 때문에 아래의 공식이 성립합니다. \\[m = \\overleftrightarrow{AB}, \\quad n = \\overrightarrow{BA}, \\quad m \\neq n, \\quad \\overleftrightarrow{AB} \\neq \\overrightarrow{BA}\\] 아래의 소스코드를 이용하여 그림 5.7의 반직선 \\(m\\)과 반직선 \\(n\\)을 그려볼 수 있습니다. #(2,0) 좌표와 (8,0)좌표를 이용하여 선을 생성, &quot;l&quot;: 라인 타입, 축 정보 없이 plot(c(2,8),c(0,0),type=&quot;l&quot;,xlim=c(-0.5,8),ylim =c(-2,2),axes=FALSE,xlab=&#39;&#39;,ylab=&#39;&#39;) #점(2,0)과 점(6,0) 위치에 점 추가, pch=19: 포인트 심볼, 파란색 points(c(2,6),c(0,0),pch=19,col=&#39;blue&#39;) #&#39;m&#39;은 (-0.5,0) 위치에 이탤릭체로 추가, &#39;A&#39;은 (2,-0.5) 위치에 추가 , &#39;B&#39;는 (6,-0.5) 위치에 추가 text(c(1.5,2,6), c(0,-0.5,-0.5),c(expression(italic(&#39;m&#39;)),&#39;A&#39;,&#39;B&#39;)) #(0,0) 좌표와 (6,0)좌표를 이용하여 선을 생성, &quot;l&quot;: 라인 타입, 축 정보 없이 plot(c(0,6),c(0,0),type=&quot;l&quot;,xlim=c(-0.5,8),ylim =c(-2,2),axes=FALSE,xlab=&#39;&#39;,ylab=&#39;&#39;) #점(2,0)과 점(6,0) 위치에 점 추가, pch=19: 포인트 심볼, 파란색 points(c(2,6),c(0,0),pch=19,col=&#39;blue&#39;) #&#39;n&#39;은 (-0.5,0) 위치에 이탤릭체로 추가, &#39;A&#39;은 (2,-0.5) 위치에 추가 , &#39;B&#39;는 (6,-0.5) 위치에 추가 text(c(-0.5,2,6), c(0,-0.5,-0.5),c(expression(italic(&#39;n&#39;)),&#39;A&#39;,&#39;B&#39;)) 직선과 반직선이 끝없이 연장되는 것과는 달리, 점 \\(A\\)에서 \\(B\\) 까지 의 유한한 선 \\(o\\)를 선분이라고 하며 기호로는 \\(\\overline{AB}\\) 와 같이 나타냅니다. 선분의 시작점과 끝점을 서로 바꾸어도 동일한 선분이 생성되기 때문에 아래와 같이 공식이 성립합니다. \\[o = \\overline{AB} = \\overline{BA}\\] 두 점을 시작점, 끝점으로 하는 선은 곡선, 꺽은선 등 무수히 많을 수 있지만 두 점을 지나는 선 중에 가장 거리가 짧은 선은 선분 \\(\\overline{AB}\\) 이며 아래의 소스코드로 그려볼 수 있습니다 (그림 5.7의 선분 \\(o\\)). 두 점 \\(A\\)(\\(2\\),\\(0\\))와 \\(B\\)(\\(6\\),\\(0\\))의 단위가 \\(cm\\)일 경우 선분 \\(o\\)의 길이는 \\(4cm\\)가 되며 \\(\\overline{AB} = 4cm\\) 와 같이 나타냅니다. 선분의 기호는 선분의 길이를 나타낼 때에도 많이 사용되기 때문에 선분 \\(\\overline{AB}\\)와 \\(\\overline{CD}\\)의 길이가 동일할 때에도 \\(\\overline{AB} = \\overline{CD}\\) 와 같이 나타냅니다. #(2,0) 좌표와 (6,0)좌표를 이용하여 선을 생성, &quot;l&quot;: 라인 타입, 축 정보 없이 plot(c(2,6),c(0,0),type=&quot;l&quot;,xlim=c(-0.5,8),ylim =c(-2,2),axes=FALSE,xlab=&#39;&#39;,ylab=&#39;&#39;) #그림에 점(2,0)과 점(6,0) 위치에 점 추가, pch=19: 포인트 심볼, 파란색 points(c(2,6),c(0,0),pch=19,col=&#39;blue&#39;) #&#39;o&#39;는 (-0.5,0) 위치에 이탤릭체로 추가, &#39;A&#39;은 (2,-0.5) 위치에 추가 , &#39;B&#39;는 (6,-0.5) 위치에 추가 text(c(1.5,2,6), c(0,-0.5,-0.5),c(expression(italic(&#39;o&#39;)),&#39;A&#39;,&#39;B&#39;)) 그림 5.7: 직선 \\(l\\), 반직선 \\(m\\)과 \\(n\\), 그리고 선분 \\(o\\) 선분 \\(AB\\)를 반으로 나누는 지점을 \\(M\\)이라 하면 선분 \\(AM\\)의 거리와 선분 \\(BM\\)의 거리는 같고 아래와 같은 공식이 성립합니다. \\[\\overline{AM} = \\overline{BM} = \\frac{1}{2} \\overline{AB}\\] 선분 \\(AB\\)의 중점 \\(M\\)을 그림으로 표현해보기 위하여 그림 5.7의 선분 \\(o\\)를 그리는 소스코드에 거리를 표현하는 점선과 거리가 동일하다는 기호를 추가하면 아래와 같습니다. 이 소스코드를 실행하여 그림 5.8와 같은 결과가 나오는지 확인해보세요. #(2,0) 좌표와 (6,0)좌표를 이용하여 선을 생성, &quot;l&quot;: 라인 타입, 축 정보 없이 plot(c(2,6),c(0,0),type=&quot;l&quot;,xlim=c(-0.5,8),ylim =c(-2,2),axes=FALSE,xlab=&#39;&#39;,ylab=&#39;&#39;) #그림에 점(2,0)과 점(6,0) 위치에 점 추가, pch=19: 포인트 심볼, 파란색 points(c(2,4,6),c(0,0,0),pch=19,col=c(&#39;blue&#39;,&#39;green&#39;,&#39;blue&#39;)) #&#39;o&#39;는 (-0.5,0) 위치에 이탤릭체로 추가, &#39;A&#39;은 (2,-0.5) 위치에 추가 , &#39;B&#39;는 (6,-0.5) 위치에 추가 text(c(1.5,2,4,6), c(0,-0.3,-0.3,-0.3),c(expression(italic(&#39;o&#39;)),&#39;A&#39;,&#39;M&#39;,&#39;B&#39;)) #선분 AM의 거리 표시 점선 s1 &lt;- smooth.spline(c(2,2.5,3.5,4),c(0,0.15,0.15,0), spar = 0.2) x1 &lt;- seq(2,4,by=0.1) lines(predict(s1, x1),lty=3,col=&#39;dimgray&#39;) #lty=3, line type = 점선 #선분 BM의 거리 표시 점선 s2 &lt;- smooth.spline(c(4,4.5,5.5,6),c(0,0.15,0.15,0), spar = 0.2) x2 &lt;- seq(4,6,by=0.1) lines(predict(s2, x2),lty=3,col=&#39;dimgray&#39;) #lty=3, line type = 점선 #선분 AM과 선분 BM의 거리가 동일하다는 기호 표현 text(c(3,5), c(0.2,0.2),c(&#39;||&#39;,&#39;||&#39;),cex=0.7) 그림 5.8: 선분 \\(AB\\)의 중점 \\(M\\) 위의 그림에서 선분의 거리 표시 점선을 생성하는 곡선 좌표를 얻기 위하여 predict(s1, x1)과 predict(s2, x2)를 사용하였습니다. 그래프를 그려본 후에 콘솔창에 predict()부분을 실행하여 결과값을 확인하고 lines(predict(s1, x1),lty=3,col='dimgray')부분을 lines(s1,lty=3,col='dimgray')로 변경하여 다시 실행해 보면서, s1이 그리는 점선과 predict(s1, x1)이 그리는 점선의 차이점을 찾아보세요. 특정 부분의 소스코드가 이해가 되지 않을 때에는 그 부분의 코드가 어떤 결과를 만들어내는 지만 알고 넘어가도 충분합니다. 코드 한 줄 한 줄이 어떤 결과를 만들어내는지 이해하는 것은 전체 소스코드의 흐름을 이해하는데 큰 도움을 줍니다. 소스코드의 일부분은 완벽히 이해했지만 전체 코드의 흐름을 파악하지 못했다면 나무만 보고 숲은 보지 못한 것과 같습니다. 5.1.2 각의 성질 이제 두 선이 만드는 각 (angle)과 관련된 다양한 개념들에 대해서 알아보겠습니다. 한 점 \\(O\\)에서 시작하는 두 반직선 \\(OA\\)와 \\(OB\\)가 이루는 각 \\(AOB\\)를 기호로 \\(\\angle AOB\\), \\(\\angle BOA\\), 또는 \\(\\angle O\\)와 같이 나타냅니다. 아래 소스코드와 같이 점 \\(A\\)(\\(1\\),\\(0\\)), \\(O\\)(\\(0\\),\\(0\\)), \\(B\\)(\\(0.8\\),\\(1.5\\))의 좌표를 이용하여 \\(\\angle AOB\\)의 크기도 구해보고 그림으로 그려보았습니다. 그림 5.9에서 볼 수 있듯이 각의 크기를 나타낼 때에는 \\(\\angle a\\)로 표현하기도 합니다. 두 반직선의 시작점인 점 \\(O\\)를 각의 꼭짓점이라고 하고 두 반직선 \\(OA\\)와 \\(OB\\)를 각의 변이라고 합니다. 아래 소스코드에서 각의 크기는 \\(OB\\)와 \\(x\\)축이 이루는 각인 a_angle2와 \\(OA\\)와 \\(x\\)축이 이루는 각인 a_angle1의 차로 구하였습니다. 두 반직선의 각도 크기를 한번에 구하는 공식도 있으나 DrawArc()함수에 호(arc)를 그리기 시작하는 각도와 끝나는 각도를 입력값으로 넣어 주어야 하기 때문입니다. 각의 크기를 구하는 공식 부분의 코드가 DrawArc()함수에 어떻게 사용되는지 정도만 파악하고 복붙해서 콘솔창에 실행해 보세요. #install.packages(&quot;DescTools&quot;) #패키지를 처음 사용할 때 설치 library(DescTools) #DrawArc()함수를 위한 패키지 로딩 #점 A, O, B의 좌표 A &lt;- c(1,0) O &lt;- c(0,0) B &lt;- c(0.8,1.5) #반직선 OA와 OB를 그래프에 그리기 plot(c(A[1]*1.3,O[1],B[1]*1.3),c(A[2]*1.3,O[2],B[2]*1.3),type=&quot;l&quot;, xlim=c(-0.5,2),ylim=c(-0.5,2),axes=FALSE,xlab=&quot;&quot;,ylab=&quot;&quot;) #점 A, B 추가 points(c(A[1],B[1]),c(A[2],B[2]),pch=19,col=&#39;blue&#39;,cex=1) #텍스트 &#39;A&#39;, &#39;O&#39;, &#39;B&#39; 추가 text(c(A[1],O[1]-0.1,B[1]),c(A[2]-0.2,O[2],B[2]+0.25),c(&#39;A&#39;,&#39;O&#39;,&#39;B&#39;),cex=1) #각도 계산 #a_angle= acos((x2%*%x1)/(sqrt(x2%*%x2)*sqrt(x1%*%x1))) #두 반직선의 각도 a_angle1 &lt;- atan2(A[2],A[1]) #반직선 OA와 x축과의 각도 a_angle2 &lt;- atan2(B[2],B[1]) #반직선 OB와 x축과의 각도 a_angle &lt;- a_angle2 - a_angle1 #두 각도 차이를 이용한 두 반직선의 각도 구하기 a_angle_degree &lt;- a_angle*180/pi #radian 각도를 degree(°)로 변환 #theta.1 부터 theta.2 까지 각도 선호 그리기 DrawArc(x=0,y=0,rx=0.2,theta.1=a_angle1,theta.2=a_angle2,col=&#39;blue&#39;) #DrawArc(x=0,y=0,rx=0.3,theta.1=a_angle2,theta.2=a_angle1,col=&#39;red&#39;) #텍스트 &#39;a&#39; 추가 text(0.25,0.15,expression(italic(&#39;a&#39;)),cex=1) #text(0.4,0.15,paste0(sprintf(&#39;%1.1f&#39;,a_angle_degree),&#39;°&#39;),cex=1) print(paste0(&#39;두 반직선 OA와 OB로 이루어진 각 A0B의 크기는 &#39;, sprintf(&#39;%1.1f&#39;,a_angle_degree),&#39;°입니다.&#39;)) ## &quot;두 반직선 OA와 OB로 이루어진 각 A0B의 크기는 61.9°입니다.&quot; 그림 5.9: 각 \\(AOB\\) \\(M\\) 점\\(O\\)를 중심으로 각 \\(AOB\\)를 이루는 두 변이 서로 반대 방향을 향하고 직선을 이룰 때, 각 \\(AOB\\)를 평각 (straight angle)이라고 하고 평각의 크기는 \\(180°\\)입니다. 평각의 크기의 절반 (\\(\\frac{1}{2}\\))인 \\(90°\\)의 크기를 가지는 각을 직각 (right angle)이라고 합니다. 아래의 소스코드를 이용하여 그림 5.10와 같이 평각을 그려보세요. #점 A, O, B의 좌표 A &lt;- c(-1,0) O &lt;- c(0,0) B &lt;- c(1,0) #반직선 OA와 OB를 그래프에 그리기 plot(c(A[1]*1.3,O[1],B[1]*1.3),c(A[2]*1.3,O[2],B[2]*1.3),type=&quot;l&quot;, xlim=c(-2,2),ylim=c(-0.5,2),axes=FALSE,xlab=&quot;&quot;,ylab=&quot;&quot;) #점 A, O, B 추가 points(c(A[1],O[1],B[1]),c(A[2],O[2],B[2]),pch=19,col=c(&#39;blue&#39;,&#39;green&#39;,&#39;blue&#39;),cex=1) #텍스트 &#39;A&#39;, &#39;O&#39;, &#39;B&#39; 추가 text(c(A[1],O[1],B[1]),c(A[2]-0.2,O[2]-0.2,B[2]-0.2),c(&#39;A&#39;,&#39;O&#39;,&#39;B&#39;),cex=1) #각도 계산 #a_angle= acos((x2%*%x1)/(sqrt(x2%*%x2)*sqrt(x1%*%x1))) #두 반직선의 각도 a_angle1 &lt;- atan2(A[2],A[1]) #반직선 OA와 x축과의 각도 a_angle2 &lt;- atan2(B[2],B[1]) #반직선 OB와 x축과의 각도 a_angle &lt;- a_angle1 - a_angle2 #두 각도 차이를 이용한 두 반직선의 각도 구하기 a_angle_degree &lt;- a_angle*180/pi #radian 각도를 degree(°)로 변환 #theta.1 부터 theta.2 까지 각도 선호 그리기 DrawArc(x=0,y=0,rx=0.3,theta.1=a_angle2,theta.2=a_angle1,col=&#39;blue&#39;) #DrawArc(x=0,y=0,rx=0.4,theta.1=a_angle1,theta.2=a_angle2,col=&#39;red&#39;) #각의 크기 텍스트로 추가 text(-0.35,0.35,paste0(sprintf(&#39;%1.0f&#39;,a_angle_degree),&#39;°&#39;),cex=1,col=&#39;blue&#39;) 그림 5.10: 평각 그림정보창에 평각 그림이 그려진 상태에서, 아래의 소스코드를 추가로 실행하면 직각의 그림이 추가로 그려 집니다. #점 P의 좌표 P &lt;- c(0,1) #직각 lines(c(O[1],P[1]),c(O[2],P[2]),lty=1,col=&#39;dimgray&#39;) #직각 기호 lines(c(0,0.15,0.15),c(0.15,0.15,0),lty=1,col=&#39;dimgray&#39;) #각도 계산 a_angle1 &lt;- atan2(P[2],P[1]) #반직선 OA와 x축과의 각도 a_angle2 &lt;- atan2(B[2],B[1]) #반직선 OB와 x축과의 각도 a_angle &lt;- a_angle1 - a_angle2 #두 각도 차이를 이용한 두 반직선의 각도 구하기 a_angle_degree &lt;- a_angle*180/pi #radian 각도를 degree(°)로 변환 #각의 크기 텍스트로 추가 text(0.45,0.2,paste0(sprintf(&#39;%1.0f&#39;,a_angle_degree),&#39;°&#39;),cex=1,col=&#39;dimgray&#39;) 여러분이 그려낸 평각과 직각 그림에서도 볼 수 있듯이 평각과 직각은 크기는 각각 \\(180°\\), \\(90°\\)입니다. 그리고, 직각보다 크기가 작은 각을 예각 (acute angle), 직각보다 크기가 큰 각을 둔각 (obtuse angle)이라고 합니다. 아래의 소스코드를 이용하여 예각인 \\(\\angle APB\\)와 둔각인 \\(\\angle COD\\)를 그려볼 수 있습니다 (그림 5.11). #예각을 그리기 위한 점 A, P, B의 좌표 A &lt;- c(-2,0.2) P &lt;- c(-1,0) B &lt;- c(-1.2,1) #반직선 PA와 PB를 그래프에 그리기 plot(c(A[1],P[1],B[1]),c(A[2],P[2],B[2]),type=&quot;l&quot;, axes=FALSE,xlim=c(-2,2),ylim=c(-0.5,2),xlab=&quot;&quot;,ylab=&quot;&quot;) #각도 계산 #a_angle= acos((x2%*%x1)/(sqrt(x2%*%x2)*sqrt(x1%*%x1))) #두 반직선의 각도 a_angle1 &lt;- atan2(A[2]-P[2],A[1]-P[1]) #반직선 PA와 x축과의 각도 atan2(y,x) a_angle2 &lt;- atan2(B[2]-P[2],B[1]-P[1]) #반직선 PB와 x축과의 각도 atan2(y,x) a_angle &lt;- a_angle1 - a_angle2 #두 각도 차이를 이용한 두 반직선의 각도 구하기 a_angle_degree &lt;- a_angle*180/pi #radian 각도를 degree(°)로 변환 #점 P를 중심으로 theta.1 부터 theta.2 까지 각도 선호 그리기 DrawArc(x=P[1],y=P[2],rx=0.3,theta.1=a_angle2,theta.2=a_angle1,col=&#39;blue&#39;) #각의 크기 텍스트로 추가 text(-1.45,0.25,paste0(sprintf(&#39;%1.0f&#39;,a_angle_degree),&#39;°&#39;),cex=1,col=&#39;blue&#39;) #둔각을 그리기 위한 점 C, O, D의 좌표 C &lt;- c(1,0) O &lt;- c(0,0) D &lt;- c(-0.2,1) #옵션1: 반직선 OC와 OD를 그래프에 그리기, 기존 그래프에 둔각의 변 추가 lines(c(C[1],O[1],D[1]),c(C[2],O[2],D[2])) #옵션2: 반직선 OC와 OD를 그래프에 그리기, 새로운 그래프 그리기 시작 #plot(c(C[1],O[1],D[1]),c(C[2],O[2],D[2]),type=&quot;l&quot;, # axes=F,xlim=c(-2,2),ylim=c(-0.5,2),xlab=&quot;&quot;,ylab=&quot;&quot;) #각도 계산 #a_angle= acos((x2%*%x1)/(sqrt(x2%*%x2)*sqrt(x1%*%x1))) #두 반직선의 각도 b_angle1 &lt;- atan2(C[2]-O[2],C[1]-O[1]) #반직선 OC와 x축과의 각도 atan2(y,x) b_angle2 &lt;- atan2(D[2]-O[2],D[1]-O[1]) #반직선 OD와 x축과의 각도 atan2(y,x) b_angle &lt;- b_angle2 - b_angle1 #두 각도 차이를 이용한 두 반직선의 각도 구하기 b_angle_degree &lt;- b_angle*180/pi #radian 각도를 degree(°)로 변환 #점 O를 중심으로 theta.1 부터 theta.2 까지 각도 선호 그리기 DrawArc(x=O[1],y=O[2],rx=0.3,theta.1=b_angle1,theta.2=b_angle2,col=&#39;blue&#39;) #각의 크기 텍스트로 추가 text(0.45,0.25,paste0(sprintf(&#39;%1.0f&#39;,b_angle_degree),&#39;°&#39;),cex=1,col=&#39;blue&#39;) 그림 5.11: 예각과 둔각 두 직선 \\(\\overline{AB}\\)와 \\(\\overline{CD}\\)가 한 점에서 만나면 네 개의 각이 생성되고 이 각들 간의 관계를 알아보기 위해 여섯 단계로 구분된 아래의 소스코드를 이용하여 그림을 그려보겠습니다. 각도 계산 및 각호 그리기가 여러 번 반복되기 때문에 이를 위한 함수 my_draw_arc()를 생성합니다. 함수를 생성할 때 특정 입력값이 주어지지 않은 경우에 사용할 기본값을 설정할 수 있습니다. 아래의 함수의 경우 \\(8\\)개의 입력값 중 \\(3\\)개의 입력값에 기본값이 설정되었습니다. library(DescTools) #DrawArc()함수를 위한 패키지 로딩 my_draw_arc &lt;- function(p1,po,p2,r,color,lty=1,lwd=1,over=0) { #각도 계산 angle1 &lt;- atan2(p1[2]-po[2],p1[1]-po[1]) #선분1과 x축과의 각도 atan2(y,x) angle2 &lt;- atan2(p2[2]-po[2],p2[1]-po[1]) #선분2와 x축과의 각도 atan2(y,x) if(angle1 &lt;0) angle1 = angle1 + 2*pi #각도가 음수로 표현되는 경우 양수로 변경 if(angle2 &lt;0) angle2 = angle2 + 2*pi #각도가 음수로 표현되는 경우 양수로 변경 angle &lt;- angle2 - angle1 #두 각도 차이를 이용한 두 반직선의 각도 구하기 if(angle &lt;0) angle = angle + 2*pi #각도가 음수로 표현되는 경우 양수로 변경 angle_degree &lt;- angle*180/pi #radian 각도를 degree(°)로 변환 #점 P를 중심으로 theta.1 부터 theta.2 까지 각도 선호 그리기 over &lt;- over *pi/180 #degree(°) 각도를 radian 각도로 변환 DrawArc(x=po[1],y=po[2],rx=r,theta.1=angle1-over,theta.2=angle2+over, col=color,lty=lty,lwd=lwd) print(paste0(&#39;angle = &#39;,sprintf(&#39;%1.0f&#39;,angle_degree),&#39;°&#39;)) return (c(angle1*180/pi, angle2*180/pi, angle_degree)) #계산 결과값이 필요한 경우에만 사용 } 두 직선의 교각을 그리기 위한 점 \\(A\\), \\(B\\), \\(C\\), \\(D\\)와 원점 \\(O\\)의 좌표를 입력합니다. A &lt;- c(-2,-1.5) B &lt;- c(2,1.5) C &lt;- c(-2,1.5) D &lt;- c(2,-1.5) O &lt;- c(0,0) 선분 \\(AB\\)와 \\(CD\\)를 그래프에 그립니다. plot(c(A[1],B[1]),c(A[2],B[2]),type=&quot;l&quot;, axes=FALSE,xlim=c(-2,2),ylim=c(-2,2),xlab=&quot;&quot;,ylab=&quot;&quot;) lines(c(C[1],D[1]),c(C[2],D[2])) my_draw_arc() 함수를 이용하여 네 개의 교각의 각호를 그립니다. 함수의 입력값이 여러 개인 경우 입력값의 이름을 사용하지 않으면 함수를 선언할 때의 순서를 그대로 따라야 합니다. 함수를 사용할 때 입력값이름=입력값의 형식으로 입력값을 주면 함수를 선언할 때의 순서를 따르지 않고 입력값 들을 사용할 수 있습니다. 그리고, 함수 선언 시에 기본값이 주어진 입력값은, 함수 사용 시에 생략하여도 주어진 기본값이 자동으로 사용되어 집니다. 아래 소스코드의 주석문 부분을 참고하세요. #my_draw_arc(po=O,p1=C,p2=A,color=&#39;blue&#39;,r=0.3,over=0,lty=1,lwd=1) #my_draw_arc(p1=C,po=O,p2=A,r=0.3,color=&#39;blue&#39;,lty=1,lwd=1,over=0) my_draw_arc(C,O,A,0.3,&#39;blue&#39;) my_draw_arc(A,O,D,0.2,&#39;red&#39;) my_draw_arc(D,O,B,0.3,&#39;blue&#39;) my_draw_arc(B,O,C,0.2,&#39;red&#39;) 네 개의 각 이름 \\(a\\),\\(b\\),\\(c\\),\\(d\\)를 추가합니다. text(O[1]-0.4,O[2],expression(italic(&#39;a&#39;)),cex=1,col=&#39;blue&#39;) text(O[1],O[2]-0.4,expression(italic(&#39;b&#39;)),cex=1,col=&#39;red&#39;) text(O[1]+0.4,O[2],expression(italic(&#39;c&#39;)),cex=1,col=&#39;blue&#39;) text(O[1],O[2]+0.4,expression(italic(&#39;d&#39;)),cex=1,col=&#39;red&#39;) 두 개의 평각을 추가로 그립니다. my_draw_arc(C,O,D,0.7,&#39;gray&#39;) my_draw_arc(A,O,B,0.8,&#39;gray&#39;) text(O[1]-1.0,O[2],&#39;180°&#39;,cex=1,col=&#39;gray&#39;) text(O[1],O[2]-1.0,&#39;180°&#39;,cex=1,col=&#39;gray&#39;) 두 직선 또는 선분이 서로 교차하는 지점에 생기는 네 각 \\(\\angle a\\), \\(\\angle b\\), \\(\\angle c\\), \\(\\angle d\\)를 교각 (angle of intersection)이라고 합니다 (그림 5.12). 교각 중에서 서로 마주 보는 두 각 \\(\\angle a\\)와 \\(\\angle c\\)를 맞꼭지각 (vertical angle, vertically oopposite angle)이라 하고 두 각의 크기는 같습니다. 이를 수식으로 확인해보면, \\(\\angle a = 180° - \\angle b, \\quad \\angle c = 180° - \\angle b\\)이므로 \\(\\angle a = \\angle c\\)임을 알 수 있습니다. 서로 맞꼭지각인 두 각 \\(\\angle b\\)와 \\(\\angle d\\)도 수식으로 확인해 보면, \\(\\angle d = 180° - \\angle c, \\quad \\angle b = 180° - \\angle c\\)이므로 \\(\\angle b = \\angle d\\)임을 알 수 있습니다. 그림 5.12: 맞꼭지각 두 직선이 교차해서 생기는 교각이 직각일 경우 두 직선은 직교 (수직으로 교차, orthogonality)한다고 하고 기호로는 \\(\\overleftrightarrow{AB} \\perp \\overleftrightarrow{CD}\\)로 나타냅니다. 두 직선이 직교할 경우 한 직선을 다른 직선의 수선이라고 합니다. 아래의 소스코드를 이용하여 두 직선이 직교하는 그림을 그려볼 수 있습니다 (그림 5.13). A &lt;- c(-2,0) B &lt;- c(2,0) C &lt;- c(0,2) D &lt;- c(0,-2) #두 직선 추가 plot(c(A[1]*1.3,B[1]*1.3),c(A[2]*1.3,B[2]*1.3),type=&quot;l&quot;, axes=FALSE,xlim=c(-3,3),ylim=c(-3,3),xlab=&quot;&quot;,ylab=&quot;&quot;) lines(c(C[1]*1.3,D[1]*1.3),c(C[2]*1.3,D[2]*1.3)) #점 A, B, C, D 추가 points(c(A[1],B[1],C[1],D[1]),c(A[2],B[2],C[2],D[2]),pch=19,col=&#39;blue&#39;) #텍스트 &#39;A&#39;, B&#39;, &#39;C&#39;, &#39;D&#39; 추가 text(c(A[1],B[1],C[1]+0.3,D[1]+0.3),c(A[2]+0.4,B[2]+0.4,C[2],D[2]),c(&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;)) #직각 기호 lines(c(0,0.2,0.2),c(0.2,0.2,0),lty=1,col=&#39;dimgray&#39;) 그림 5.13: 두 직선의 직교 관계 선분 \\(AB\\)의 중점 \\(M\\)을 지나고 선분에 수직인 직선 \\(l\\)을 선분 \\(AB\\)의 수직이등분선 (perpendicular bisector)이라고 하고 기호로는 \\(\\overline{AB} \\perp l\\)로 표현합니다. 또한, 선분 \\(AM\\)과 선분 \\(BM\\)의 길이는 같고 기호로는 \\(\\overline{AM} = \\overline{BM}\\)와 같이 나타냅니다. 아래의 소스코드로 선분 \\(AB\\)의 수직이등분선 \\(l\\)을 그려볼 수 있습니다 (그림 5.14). #세미콜론 (;)으로 구분해서 여러 라인을 한 라인에 표현 A &lt;- c(-2,0); B &lt;- c(2,0); C &lt;- c(0,2); D &lt;- c(0,-2) #두 직선 추가 plot(c(A[1],B[1]),c(A[2],B[2]),type=&quot;l&quot;, axes=FALSE,xlim=c(-3,3),ylim=c(-3,3),xlab=&quot;&quot;,ylab=&quot;&quot;) lines(c(C[1],D[1]),c(C[2],D[2])) #점 A, B 추가 points(c(A[1],B[1]),c(A[2],B[2]),pch=19,col=&#39;blue&#39;) #텍스트 &#39;A&#39;, B&#39;, &#39;M&#39;, &#39;l&#39; 추가 text(c(A[1],B[1],0.3,C[1]),c(A[2]-0.4,B[2]-0.4,-0.3,C[2]+0.3), c(&#39;A&#39;,&#39;B&#39;,&#39;M&#39;,expression(italic(&#39;l&#39;)))) #직각 기호 lines(c(0,0.2,0.2),c(0.2,0.2,0),lty=1,col=&#39;gray&#39;) #등거리 기호 text(c(A[1]/2,B[1]/2),c(A[2],B[2]),c(&#39;||&#39;,&#39;||&#39;),cex=0.7,col=&#39;gray&#39;) 그림 5.14: 선분 AB의 수직이등분선 \\(l\\) 직선 \\(l\\) 위에 있지 않은 점 \\(P\\)에서 직선 \\(l\\)에 수선을 그려 생긴 교점 \\(H\\)을 점 \\(P\\)에서 직선 \\(l\\)에 내린 수선의 발 (foot of perpendicular)이라고 합니다. 점 \\(P\\)와 교점 \\(H\\)가 만드는 선분 \\(PH\\)는 점 \\(P\\)와 직선 \\(l\\)위의 점을 잇는 선분 중에서 가장 짧기 때문에 선분 \\(PH\\)의 길이를 점 \\(P\\)와 직선 \\(l\\)사이의 거리라고 합니다. 수선의 발 \\(H\\)와 점 \\(P\\)와 직선 \\(l\\)사이의 거리 (perpendicular distance)는 아래의 소소코드로 그려볼 수 있습니다 (그림 5.15). #세미콜론 (;)으로 구분해서 여러 라인을 한 라인에 표현 A &lt;- c(-2,0); B &lt;- c(2,0); P &lt;- c(0,2); H &lt;- c(0,0) #두 직선 추가 plot(c(A[1],B[1]),c(A[2],B[2]),type=&quot;l&quot;, axes=FALSE,xlim=c(-3,3),ylim=c(-1,3),xlab=&quot;&quot;,ylab=&quot;&quot;) lines(c(P[1],H[1]),c(P[2],H[2])) #점 P 추가 points(c(P[1]),c(P[2]),pch=19,col=&#39;blue&#39;) #텍스트 &#39;l&#39;, P&#39;, H&#39; 추가 text(c(A[1]-0.4,P[1],H[1]),c(A[2],P[2]+0.3,H[2]-0.3), c(expression(italic(&#39;l&#39;)),&#39;P&#39;,&#39;H&#39;)) #직각 기호 lines(c(0,-0.2,-0.2),c(0.2,0.2,0),lty=1,col=&#39;dimgray&#39;) #선분 PH의 거리 표시 점선, 위에서 만든 my_draw_arc() 함수 이용 my_draw_arc(H,c(-2,1),P,sqrt(5),&#39;dimgray&#39;,lty=3) 그림 5.15: 수선의 발과 점 P와 직선 \\(l\\)사이의 거리 지금까지 두 선이 만드는 다양한 각의 형태인 예각, 직각, 둔각, 평각, 교각, 맞꼭지각, 직교, 수선 등의 개념을 살펴보았습니다. 이제 점, 직선, 평면의 위치 관계에 대해서 알아봅시다. 5.1.3 점, 직선, 평면의 위치 관계 5.1.1절에서 이미 점, 선, 면의 교점과 교선에 대해서 잠깐 다루었던 걸 떠올려보면서, 점, 직선, 평면의 위치 관계에 대해서 자세히 알아봅시다. 점과 직선의 위치 관계에는 아래와 같이 두 가지로 나뉩니다 (그림 5.16). 점이 직선 위에 있다. 점이 직선 위에 있지 않다. 그림 5.16: 점과 직선의 위치 관계 점과 직선의 두 가지 위치 관계를 그림으로 그려보기 위하여 그림 5.3에 사용하였던 소스코드를 아래와 같이 간단히 정리하였습니다. library(sf) #선 l l &lt;- st_linestring(cbind(c(0,10),c(0,0))) #점 A, B A &lt;- st_point(c(5,0)); B &lt;- st_point(c(5,2)) #두 개의 그림을 옆으로 나란히 opar &lt;- par(mfrow = c(1, 2)) # 1. 점이 직선 위에 있다. plot(l, xlim=c(-1,10),ylim =c(-2,2)) plot(A, add = TRUE, pch = 19, col=&#39;blue&#39;) #점들은 파란색 text(-0.5,0, expression(italic(&#39;l&#39;))) # 2. 점이 직선 위에 있지 않다. plot(l, xlim=c(-1,10),ylim =c(-2,2)) plot(B, add = TRUE, pch = 19, col=&#39;blue&#39;) text(-0.5,0, expression(italic(&#39;l&#39;))) #원래 설정으로 돌아가기, 한 번에 한 개의 그림만 opar &lt;- par(mfrow = c(1, 1)) st_intersection()함수를 이용하여 점과 직선의 위치 관계를 확인 해 볼 수도 있습니다. i1 &lt;- st_intersection(l,A) i1 #교차 정보 확인 i2 &lt;- st_intersection(l,B) i2 #교차 정보 확인 한 평면 위에서 두 직선의 위치 관계는 아래와 같이 세가지로 나뉩니다 (그림 5.17). 두 직선이 일치한다. 두 직선이 한 점에서 만난다. 두 직선이 평행하다. 그림 5.17: 두 직선의 위치 관계 두 직선의 세가지 위치 관계를 그림으로 그려보기 위하여 아래의 소스코드를 생성하였습니다. 두 직선이 일치하는 경우, 선 \\(l\\)을 반투명으로 표현하기 위해 scales패키지의 alpha('blue',0.5)함수가 사용되었습니다. 선 \\(l\\)과 선 \\(m\\)의 이름을 추가할 때에 text()함수를 두 번 사용할 수도 있고, 입력값을 벡터 처리하여 한번 만 사용할 수도 있습니다. opar &lt;- par(mfrow = c(1, 3)) #세 개의 그림을 옆으로 나란히 library(sf) library(scales) # 1. 두 직선이 일치한다. l1 &lt;- st_linestring(cbind(c(0,10),c(0,2))) m1 &lt;- st_linestring(cbind(c(0,10),c(0,2))) plot(l1, col=alpha(&#39;blue&#39;,0.5), lwd=3, xlim=c(-1,10),ylim =c(-1,2)) plot(m1, col =&#39;red&#39;, add = TRUE) text(-0.5,-0.5, expression(italic(&#39;l, m&#39;)),cex=2) # 2. 두 직선이 한 점에서 만난다. l2 &lt;- st_linestring(cbind(c(0,10),c(2,0))) m2 &lt;- st_linestring(cbind(c(0,10),c(0,2))) plot(l2, col=&#39;blue&#39;, xlim=c(-1,10),ylim =c(-1,2)) plot(m2, col =&#39;red&#39;, add = TRUE) text(-0.5, 2, expression(italic(&#39;l&#39;)),cex=2) text(-0.5, 0, expression(italic(&#39;m&#39;)),cex=2) # 3. 두 직선이 평행하다. l3 &lt;- st_linestring(cbind(c(0,10),c(2,2))) m3 &lt;- st_linestring(cbind(c(0,10),c(0,0))) plot(l3, col=&#39;blue&#39;, xlim=c(-1,10),ylim =c(-1,2)) plot(m3, col =&#39;red&#39;, add = TRUE) text(c(-0.5,-0.5),c(2,0),c(expression(italic(&#39;l&#39;)),expression(italic(&#39;m&#39;))),cex=2) #원래 설정으로 돌아가기, 한 번에 한 개의 그림만 opar &lt;- par(mfrow = c(1, 1)) st_intersection()함수를 이용하여 한 평면 위에 존재하는 두 직선의 위치 관계를 확인 해 볼 수도 있습니다. i1 &lt;- st_intersection(l1,m1) i1 #교차 정보 확인 i2 &lt;- st_intersection(l2,m2) i2 #교차 정보 확인 i3 &lt;- st_intersection(l3,m3) i3 #교차 정보 확인 두 직선 \\(l\\), \\(m\\)이 한 평면 위에 있고 두 직선의 교점이나 교선이 없는 경우 두 선은 서로 만나지 않으며 이러한 경우 두 직선이 평행 (parallel)하다고 하고 기호로는 \\(l ⫽ m\\) 와 같이 표현합니다. 무한히 연장되는 두 직선 \\(n\\), \\(o\\) 사이에 교점이나 교선이 없고 서로 평행하지도 않는 경우 두 직선은 한 평면 위에 있지 않고 꼬인 위치 (skew position)에 있다고 합니다. 아래의 소스코드를 이용하여 한 평면 위에 존재하는 직선 (파란색)과 꼬인 위치에 있는 직선 (빨간색)을 그려 볼 수 있습니다 (그림 5.18). 맥킨토시 환경 (Mac OS)을 사용하는 경우, rgl패키지의 그래프 그리기 함수들이 XQuartz를 기반으로 구현되었기 때문에 Mac에 XQuartz를 설치한 후에 rgl패키지를 로딩하여야 정상 작동합니다. https://www.xquartz.org/에서 XQuartz-2.7.11.dmg를 다운로드한 후에, 다운로드 폴더에서 dmg 파일을 더블 클릭하여 설치 파일을 엽니다. XQuartz.pkg가 보이면 이를 다시 더블 클릭하여 해당 패키지를 Mac에 설치해 줍니다. 설치가 완료된 후에, Mac을 로그아웃하고 다시 로그인 한 후에 아래 소스코드를 실행합니다. #install.packages(&quot;rgl&quot;) library(rgl) #plot3d() 함수를 사용하기 위한 패키지 로딩 #x,y,z 좌표를 가지는 직선 l,m l4 &lt;- st_linestring(cbind(c(-5,5),c(0,0),c(0,0))) m4 &lt;- st_linestring(cbind(c(0,0),c(2,2),c(-10,5))) #직선 l 3차원 공간에 그리기 plot3d(l4,type=&#39;l&#39;,lwd=2,col=&#39;blue&#39;, axes=FALSE,xlim=c(-10,10),ylim =c(-10,10),zlim =c(-10,10),xlab=&#39;&#39;,ylab=&#39;&#39;,zlab=&#39;&#39;) #axes=F,xlim=c(-6,6),ylim =c(-1,2),zlim =c(-10,5),xlab=&#39;&#39;,ylab=&#39;&#39;,zlab=&#39;&#39;) #직선 m 3차원 공간에 그리기 plot3d(m4,type=&#39;l&#39;,lwd=2,col=&#39;red&#39;, add = TRUE) #직선 l이 속한 평면 P, z=0인 평면, xy 평면 planes3d(0,0,1,0,col=&#39;gray100&#39;,alpha=0.9) #교차 정보 확인 i4 &lt;- st_intersection(l4,m4) i4 그림 5.18: 꼬인 위치에 있는 두 직선 삼차원 공간에서 직선과 평면 사이의 위치 관계는 아래와 같이 세 가지로 나뉩니다. 직선이 평면에 포함된다. 직선과 평면이 한 점에서 만난다. 직선과 평면이 평행하다. 직선이 평면에 포함되는 경우와 직선이 평면과 한 점에서 만나는 경우는 위의 그림 5.18에서 확인할 수 있습니다. 그림의 직선 \\(m\\) (빨간색)의 경우, 직선과 평면이 한 점에서 만나는 다양한 경우 중에서 직선 \\(m\\)과 평면 \\(P\\)가 서로 수직인 경우를 보여주고 있습니다. 이러한 경우 직선 \\(m\\)과 평면 \\(P\\)는 직교한다고 하고 기호로는 \\(m \\perp P\\)와 같이 나타냅니다. 직선 \\(m\\)과 평면 \\(P\\)가 만나는 점을 \\(O\\)라고 할 때, 평면 \\(P\\)와 서로 수직인 직선 \\(m\\)은 점 \\(O\\)를 지나는 평면 위의 모든 직선들과도 서로 수직인 관계를 가집니다. 그림 5.18의 소스코드를 실행하여 그림창이 열려있는 상태에서 아래의 소스코드를 추가로 콘솔창에 입력하고 실행하면 점 \\(O\\)를 지나는 평면 위의 직선 네 개를 추가로 그려볼 수 있습니다. n1 &lt;- st_linestring(cbind(c(-1,1),c(1,3),c(0,0))) plot3d(n1,type=&#39;l&#39;,lwd=2,col=&#39;green&#39;, add = TRUE) n2 &lt;- st_linestring(cbind(c(-1,1),c(3,1),c(0,0))) plot3d(n2,type=&#39;l&#39;,lwd=2,col=&#39;green&#39;, add = TRUE) n3 &lt;- st_linestring(cbind(c(-1,1),c(2,2),c(0,0))) plot3d(n3,type=&#39;l&#39;,lwd=2,col=&#39;green&#39;, add = TRUE) n4 &lt;- st_linestring(cbind(c(0,0),c(1,3),c(0,0))) plot3d(n4,type=&#39;l&#39;,lwd=2,col=&#39;green&#39;, add = TRUE) 직선과 평면이 평행한 위치 관계를 그림으로 그려보기 위하여 아래의 소스코드를 생성하였습니다 (그림 5.19). 직선 \\(l\\)과 평면 \\(P\\)가 평행할 때, 기호로 \\(l ⫽ P\\)와 같이 나타냅니다. library(sf) #직선 도형을 위한 패키지 로딩 library(rgl) #plot3d() 함수를 사용하기 위한 패키지 로딩 #x,y,z 좌표를 가지는 직선 l l &lt;- st_linestring(cbind(c(-5,5),c(0,0),c(3,3))) #직선 l 3차원 공간에 그리기 plot3d(l,type=&#39;l&#39;,lwd=2,col=&#39;blue&#39;, axes=FALSE,xlim=c(-6,6),ylim =c(-6,6),zlim =c(-6,6),xlab=&#39;&#39;,ylab=&#39;&#39;,zlab=&#39;&#39;) #직선 l가 평행인 평면 P, z=0인 평면, xy 평면 planes3d(0,0,1,0,col=&#39;gray100&#39;,alpha=0.9) 그림 5.19: 평면과 평행한 직선 직선을 생성하기 위해서 두 점의 좌표를 st_linestring()함수에 입력값으로 넣어야 하는데 주로 cbind()를 사용하였으나, 아래의 소스코드와 같이 rbind ()를 사용하여도 동일한 결과를 얻을 수 있습니다. #x 벡터, y 벡터, z 벡터 컬럼들을 합침 cbind(c(-5,5),c(0,0),c(3,3)) #(x,y,z) 좌표를 가지는 각 행들을 합침 rbind(c(-5,0,3),c(5,0,3)) 5.1.4 평행선의 성질 지금까지 두 개의 도형들 간의 위치 관계에 대하여 알아보았습니다. 이제 두 직선이 다른 한 직선과 만나서 만드는 교각의 성질에 대해서 살펴봅시다. 한 평면 위에서 두 직선 \\(l\\), \\(m\\)이 다른 한 직선 \\(n\\)과 만나면 여덟 개의 각이 생깁니다. 아래의 소스코드를 이용하여 그림을 먼저 그린 후에, 그림을 이용하여 여덟 개의 각들이 가지는 관계를 설명해 보겠습니다. 세 직선 \\(l\\), \\(m\\), \\(n\\)과 두 교점 \\(O\\), \\(P\\)의 좌표를 입력합니다. A &lt;- c(0,2); B &lt;- c(10,4) #직선 l C &lt;- c(0,0); D &lt;- c(10,0) #직선 m E &lt;- c(4,6); F &lt;- c(7,-3) #직선 n O &lt;- c(5,3) #직선 l과 직선 n의 교점 P &lt;- c(6,0) #직선 m과 직선 n의 교점 직선 \\(l\\), \\(m\\), \\(n\\)을 그래프에 그립니다. plot(c(A[1],B[1]),c(A[2],B[2]),type=&quot;l&quot;, axes=FALSE,xlim=c(-5,10),ylim=c(-5,10),xlab=&quot;&quot;,ylab=&quot;&quot;) lines(c(C[1],D[1]),c(C[2],D[2])) lines(c(E[1],F[1]),c(E[2],F[2])) 위에서 그림 5.12을 그리는데 사용되었던 my_draw_arc()함수를 이용하여 여덟 개 교각의 각호를 그립니다. my_draw_arc(E,O,A,0.5,&#39;blue&#39;) #각 a my_draw_arc(A,O,F,0.6,&#39;red&#39;) #각 b my_draw_arc(F,O,B,0.5,&#39;green&#39;) #각 c my_draw_arc(B,O,E,0.6,&#39;gray&#39;) #각 d my_draw_arc(E,P,C,0.5,&#39;blue&#39;) #각 e my_draw_arc(C,P,F,0.6,&#39;red&#39;) #각 f my_draw_arc(F,P,D,0.5,&#39;green&#39;) #각 g my_draw_arc(D,P,E,0.6,&#39;gray&#39;) #각 h 여덟 개의 각이름 \\(a\\),\\(b\\),\\(c\\),\\(d\\),\\(e\\),\\(f\\),\\(g\\),\\(h\\)와 세 개의 직선 이름 \\(l\\),\\(m\\),\\(n\\)을 추가합니다. 아래와 같이 두 개의 다른 함수를 생성하였습니다. my_text1()함수는 두 직선의 교점에서 생성되는 교각의 이름을 그래프에 추가하기 위해서 작성되었습니다. my_text2()함수는 벡터 형태의 입력값을 이용하도록 작성되었기 때문에, 교점 \\(O\\), \\(P\\)를 위한 코드가 한 줄에 작성되었습니다. 뿐만 아니라, 직선의 이름을 추가하는 데에도 사용되었습니다. 둘 중에 하나를 선택해서 사용하세요. library(rlang) #expr()안에서 변수를 사용하기 위한 패키지 로딩 my_text1 &lt;- function(p,ptext,shift,color,size=1) { text(p[1]-shift,p[2]+shift,expr(italic(!!ptext[1])),col=color[1],cex=size) text(p[1]-shift,p[2]-shift,expr(italic(!!ptext[2])),col=color[2],cex=size) text(p[1]+shift,p[2]-shift,expr(italic(!!ptext[3])),col=color[3],cex=size) text(p[1]+shift,p[2]+shift,expr(italic(!!ptext[4])),col=color[4],cex=size) } my_text1(O,ptext=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;),shift=0.7,color=c(&#39;blue&#39;,&#39;red&#39;,&#39;green&#39;,&#39;gray&#39;)) my_text1(P,ptext=c(&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;),shift=0.7,color=c(&#39;blue&#39;,&#39;red&#39;,&#39;green&#39;,&#39;gray&#39;)) text(A[1]-0.5,A[2],expr(italic(&#39;l&#39;))) text(C[1]-0.5,C[2],expr(italic(&#39;m&#39;))) text(E[1]-0.25,E[2]+0.5,expr(italic(&#39;n&#39;))) library(rlang) #expr()안에서 변수를 사용하기 위한 패키지 로딩 my_text2 &lt;- function(p,ptext,dx,dy,color,size=1,useItalic=TRUE) { for(i in 1:length(ptext)) { myp=p[[i]] if(useItalic) text(myp[1]+dx[i],myp[2]+dy[i], expr(italic(!!ptext[i])),col=color[i],cex=size) else text(myp[1]+dx[i],myp[2]+dy[i],ptext[i],col=color[i],cex=size) } } my_text2(list(O,O,O,O,P,P,P,P),ptext=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;), dx=rep(c(-0.7,-0.7,0.7,0.7),2),dy=rep(c(0.7,-0.7,-0.7,0.7),2), color=rep(c(&#39;blue&#39;,&#39;red&#39;,&#39;green&#39;,&#39;dimgray&#39;),2)) my_text2(list(A,C,E),ptext=c(&#39;l&#39;,&#39;m&#39;,&#39;n&#39;), dx=c(-0.5,-0.5,-0.25),dy=c(0,0,0.5),color=rep(&#39;black&#39;,3)) 그림 5.20와 같이 두 직선 \\(l\\), \\(m\\)과 또 하나의 직선 \\(n\\)이 만나서 생기는 여덟 개의 각을 그려보면, 여덟 개의 각들 중 두 개의 각은 서로 상대적으로 같은 위치에 놓이게 됩니다. 이때, \\(\\angle a\\)와 \\(\\angle e\\), \\(\\angle b\\)와 \\(\\angle f\\), \\(\\angle c\\)와 \\(\\angle g\\), \\(\\angle d\\)와 \\(\\angle h\\)와 같이 상대적으로 같은 위치에 있는 각을 각각 서로 동위각 (corresponding angle)이라고 합니다. 또한, \\(\\angle b\\)와 \\(\\angle h\\), \\(\\angle c\\)와 \\(\\angle e\\)와 같이 엇갈린 위치에서 서로 마주보는 각을 각각 서로 엇각 (alternative angle)이라고 합니다. 그림 5.20: 동위각과 엇각 위의 두 직선 \\(l\\), \\(m\\)이 평행한 경우의 동위각과 엇각을 살펴보기 위해 아래의 소스코드를 이용하여 그림을 그려봅시다. # 1. 세 직선 $l$, $m$, $n$과 두 교점 $O$, $P$의 좌표를 입력합니다. A &lt;- c(0,2); B &lt;- c(10,2) #직선 l C &lt;- c(0,0); D &lt;- c(10,0) #직선 m E &lt;- c(4,4); F &lt;- c(7,-2) #직선 n O &lt;- c(5,2) #직선 l과 직선 n의 교점 P &lt;- c(6,0) #직선 m과 직선 n의 교점 # 2. 직선 $l$, $m$, $n$을 그래프에 그립니다. plot(c(A[1],B[1]),c(A[2],B[2]),type=&quot;l&quot;, axes=FALSE,xlim=c(-5,10),ylim=c(-5,10),xlab=&quot;&quot;,ylab=&quot;&quot;) lines(c(C[1],D[1]),c(C[2],D[2])) lines(c(E[1],F[1]),c(E[2],F[2])) # 3. my_draw_arc() 함수를 이용하여 세 개의 교각의 각호를 그립니다. my_draw_arc(F,O,B,0.5,&#39;green&#39;) #각 a my_draw_arc(F,P,D,0.5,&#39;green&#39;) #각 b my_draw_arc(E,P,C,0.5,&#39;blue&#39;) #각 c # 4. my_text2() 함수를 이용하여 각 이름 $a$,$b$,$c$와 직선 이름 $l$,$m$을 추가합니다. my_text2(list(O,P,P),ptext=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;),dx=c(0.7,0.7,-0.7),dy=c(-0.7,-0.7,0.7), color=c(&#39;green&#39;,&#39;green&#39;,&#39;blue&#39;)) my_text2(list(A,C),ptext=c(&#39;l&#39;,&#39;m&#39;),dx=c(-0.5,-0.5),dy=c(0,0),color=rep(&#39;black&#39;,2)) 그림 5.21에서 볼 수 있듯이, 두 직선 \\(l\\), \\(m\\)이 평행하면 다른 한 직선과 만나서 생기는 동위각 \\(\\angle a\\)와 \\(\\angle b\\)의 크기는 서로 같으며, 평행선과 동위각은 다음과 같은 성질이 있습니다. 두 직선이 평행하면 동위각의 크기는 서로 같다. 동위각의 크기가 같으면 두 직선은 평행하다. \\(l ⫽ m\\)이면 \\(\\angle a\\)와 \\(\\angle b\\)는 동위각이므로 \\(\\angle a = \\angle b\\)이고, \\(\\angle b\\)와 \\(\\angle c\\)는 맞꼭지각이므로 \\(\\angle b = \\angle c\\)입니다. 따라서, 엇각인 \\(\\angle a\\)와\\(\\angle c\\)의 크기도 같으며 ( \\(\\angle a = \\angle c\\)), 평행선과 엇각은 다음과 같은 성질이 있습니다. 두 직선이 평행하면 엇각의 크기는 서로 같다. 엇각의 크기가 같으면 두 직선은 평행하다. 그림 5.21: 평행선과 동위각, 평행선과 엇각 지금까지 점, 직선, 평면을 이해하고 이 도형들 사이의 위치 관계에 대하여 알아보았습니다. 또한, 두 반직선 또는 직선이 만드는 각의 성질과 평행선의 성질에 대해서도 알아보았습니다. 이제, 작도와 합동에 대하여 살펴봅시다. 5.2 작도와 합동 간단한 도형과 삼각형을 작도 (construction)하여 보고 삼각형의 합동조건 (conditions of congruence)에 대하여 알아봅니다. 5.2.1 간단한 도형의 작도 눈금이 없는 자 (ruler)와 컴퍼스 (compass)만을 이용하여 도형을 그리는 것을 작도라고 합니다. 자는 두 점을 연결하는 선분, 반직선, 직선을 그리는데 사용하고, 컴퍼스는 원을 그리거나 주어진 선분의 길이를 재어서 옮기는데 사용합니다. 먼저, 선분 AB와 길이가 같은 선분 CD를 그려보겠습니다. 소스코드로 그림을 그리는 일은 눈금이 없는 자와 컴퍼스로 작도하는 것과는 다르지만, 작도하는 순서와 비슷한 그림이 나오도록 아래와 순서로 소스코드를 실행해 봅시다. 도형을 그리는 데 필요한 패키지들을 로딩하고, 선분 \\(AB\\)를 그립니다. library(sf) #공간 도형을 사용하기 위한 패키지 로딩 library(DescTools) #DrawArc()함수를 위한 패키지 로딩 library(scales) #color의 입력값에 alpha를 직접 사용하기 위한 패키지 로딩 A &lt;- c(0,2); B &lt;- c(5,2) #선분 AB 추가 plot(c(A[1],B[1]),c(A[2],B[2]),type=&quot;l&quot;, axes=FALSE,xlim=c(-2,7),ylim=c(-2,4),xlab=&quot;&quot;,ylab=&quot;&quot;) #점 A,B 추가 points(c(A[1],B[1]),c(A[2],B[2]),pch=19,col=&#39;black&#39;) 직선 \\(l\\)을 그리고 그 위에 한 점 \\(C\\)를 추가합니다. #직선 l 추가 C &lt;- c(0,0) abline(h=C[2], col=alpha(&#39;blue&#39;,0.3)) #점 C 추가 points(c(C[1]),c(C[2]),pch=19,col=&#39;blue&#39;) 선분 \\(AB\\)의 길이를 구합니다. #선분 AB의 거리 측정 length_AB &lt;- st_distance(st_point(A), st_point(B)) 점 \\(C\\)를 중심으로 반지름 (radius)의 길이가 \\(\\overline{AB}\\)인 원을 그립니다. #점 C를 중심으로 반지름의 길이가 선분 AB인 원을 그려 직선 l과의 교점 D를 구함 DrawArc(x=C[1],y=C[2],rx=length_AB,theta.1=-20/180*pi,theta.2=20/180*pi, col=alpha(&#39;red&#39;,0.5)) 그리진 원과 직선 \\(l\\)의 교점을 \\(D\\)라고 하면, 이제 여러분은 교점 \\(D\\)의 위치를 눈으로 확인할 수 있습니다. 하지만, 선분 \\(CD\\)을 소스코드로 그리기 위해서는 교점 \\(D\\)의 좌표 정보가 필요합니다. 교점 \\(D\\)의 좌표를 구한 후, 선분 \\(CD\\)를 그립니다. 교점 \\(D\\)의 좌표를 구하기 위해서 아래와 같이 두 개의 함수가 만들어졌습니다. getPoint1()함수는 직선과 원의 교점을 구하는 방식으로 작성되었고, getPoint2()함수는 한 점에서의 거리와 각도를 이용하여 좌표를 구하는 방식으로 작성되었습니다. 둘 중에 하나를 선택해서 사용하세요. #직선과 원의 작도를 이용한 함수 (교점구하기) getPoint1 &lt;- function(P, length, angle_degree, times=5,draw=TRUE) { myline &lt;- st_linestring(cbind(c(P[1],P[1]+length*times*cos(angle_degree*pi/180)), c(P[2],P[2]+length*times*sin(angle_degree*pi/180)))) myarc = st_cast(st_buffer(st_point(P), length),&quot;LINESTRING&quot;) mypoint &lt;- st_intersection(myline,myarc) return (mypoint) } D &lt;- getPoint1(C, length_AB, 0) points(c(D[1]),c(D[2]),pch=19,col=&#39;dimgray&#39;) lines(c(C[1],D[1]),c(C[2],D[2]),lwd=2,col=&#39;dimgray&#39;) #한 점에서의 거리와 각도를 이용하여 좌표를 구하는 함수 (삼각함수) getPoint2 &lt;- function(P, length, angle_degree, draw=TRUE) { mypoint &lt;- c(P[1]+length*cos(angle_degree*pi/180), P[2]+length*sin(angle_degree*pi/180)) return (mypoint) } D &lt;- getPoint2(P=C, length_AB, 0) points(c(D[1]),c(D[2]),pch=19,col=&#39;green&#39;) lines(c(C[1],D[1]),c(C[2],D[2]),lwd=2,col=&#39;green&#39;) 위의 다섯 단계를 거쳐서 그림 5.22이 생성되었습니다. 그림 5.22: 선분 AB와 길이가 같은 선분 CD 이제, 선분 \\(AB\\)를 점 \\(B\\)의 방향으로 연장하여 길이가 선분 \\(AB\\)의 \\(2\\)배인 선분 \\(BC\\)를 그려봅시다. 아래 소스코드의 주석문을 참고하여 한 줄 한 줄 실행해보세요. A &lt;- c(0,2); B &lt;- c(5,2) #선분 AB 추가 plot(c(A[1],B[1]),c(A[2],B[2]),type=&quot;l&quot;, axes=FASLE,xlim=c(-2,17),ylim=c(-2,6),xlab=&quot;&quot;,ylab=&quot;&quot;) #점 A,B 추가 points(c(A[1],B[1]),c(A[2],B[2]),pch=19,col=&#39;black&#39;) #직선 l 추가 abline(h=A[2], col=alpha(&#39;blue&#39;,0.5)) #선분 AB의 거리 측정 length_AB &lt;- st_distance(st_point(A), st_point(B)) #점 C를 중심으로 반지름의 길이가 선분 AB의 2배인 원을 그려 직선 l과의 교점 C를 구함 DrawArc(x=B[1],y=B[2],rx=length_AB*2,theta.1=-15/180*pi,theta.2=15/180*pi, col=alpha(&#39;red&#39;,0.5)) #점 C 추가 C &lt;- getPoint1(B, length_AB*2, 0) points(C[1],C[2],pch=19,col=&#39;dimgray&#39;) #선분 BC 추가 lines(c(B[1],C[1]),c(B[2],C[2]),col=&#39;dimgray&#39;) 위의 소스코드를 실행해서 원하는 결과가 나왔을 경우, 선분 \\(AB\\)를 추가하는 plot()함수의 axes 입력값을 FALSE로 변경해주고 난 후에(axes=FALSE), 다시 소스코드를 실행하면 그림 5.23과 같이 좌표축 없는 그림을 그려볼 수 있습니다. 그림 5.23: 길이가 선분 AB 길이의 2배인 선분 BC 선분 \\(AB\\)와 선분 \\(CD\\)를 이용하여 길이가 \\(\\overline{AB}\\) + \\(\\overline{CD}\\)인 선분 \\(EF\\)도 그려봅시다. 다섯 단계로 구분된 아래의 소스코드를 각 단계 별로 실행하면서 결과를 확인해 보세요. 선분 \\(AB\\)와 선분 \\(CD\\)를 추가합니다. A &lt;- c(1,4); B &lt;- c(5,4) C &lt;- c(0,2); D &lt;- c(6,2) #점 A,B와 선분 AB 추가 plot(c(A[1],B[1]),c(A[2],B[2]),type=&quot;l&quot;, axes=FALSE,xlim=c(-2,15),ylim=c(-2,15),xlab=&quot;&quot;,ylab=&quot;&quot;) points(c(A[1],B[1]),c(A[2],B[2]),pch=19,col=&#39;black&#39;) my_text2(list(A,B),ptext=c(&#39;A&#39;,&#39;B&#39;),dx=c(0,0),dy=c(-0.7,-0.7), color=c(&#39;black&#39;,&#39;black&#39;)) #점 C,D와 선분 CD 추가 lines(c(C[1],D[1]),c(C[2],D[2])) points(c(C[1],D[1]),c(C[2],D[2]),pch=19,col=&#39;black&#39;) my_text2(list(C,D),ptext=c(&#39;C&#39;,&#39;D&#39;),dx=c(0,0),dy=c(-0.7,-0.7), color=c(&#39;black&#39;,&#39;black&#39;),useItalic=FALSE) 직선 \\(l\\)을 그리고 그 위에 한 점 \\(E\\)를 추가합니다. E &lt;- c(0,0) #직선 l 추가 abline(h=E[2], col=alpha(&quot;blue&quot;,0.3)) #점 E 추가 points(E[1],E[2],pch=19,col=&#39;dimgray&#39;) 점 \\(E\\)로 부터 선분 \\(AB\\)의 거리를 반지름으로 하는 원을 그려 직선 \\(l\\)과의 교점 \\(G\\)를 구합니다. length_AB &lt;- st_distance(st_point(A), st_point(B)) DrawArc(x=E[1],y=E[2],rx=length_AB,theta.1=-20/180*pi,theta.2=20/180*pi, col=alpha(&#39;red&#39;,0.5)) G &lt;- getPoint1(E, length_AB, 0) points(G[1],G[2],pch=19,col=alpha(&#39;dimgray&#39;,0.5)) 점 \\(G\\)로 부터 선분 \\(CD\\)의 거리를 반지름으로 하는 원을 그려 직선 \\(l\\)과의 교점 \\(F\\)를 구합니다. length_CD &lt;- st_distance(st_point(C), st_point(D)) DrawArc(x=G[1],y=G[2],rx=length_CD,theta.1=-20/180*pi,theta.2=20/180*pi, col=alpha(&#39;red&#39;,0.5)) F &lt;- getPoint1(G, length_CD, 0) points(F[1],F[2],pch=19,col=&#39;dimgray&#39;) 점 \\(E\\)와 점 \\(F\\) 사이를 잇는 선분 \\(EF\\)를 추가합니다. lines(c(E[1],F[1]),c(E[2],F[2]),lwd=2,col=&#39;dimgray&#39;) my_text2(list(E,G,F),ptext=c(&#39;E&#39;,&#39;G&#39;,&#39;F&#39;),dx=c(0,0,0),dy=c(-0.7,-0.7,-0.7), color=c(&#39;black&#39;,&#39;gray&#39;,&#39;black&#39;),useItalic=FALSE) 위의 소스코드를 단계 별로 실행하면 그림 5.24와 같은 그림을 그려볼 수 있습니다. 그림 5.24: 길이가 선분 AB + 선분 CD인 선분 EF 위에서 선분의 거리를 이용한 작도가 가능한 것처럼, 두 선분이 이루는 각을 이용한 작도 또한 가능합니다. 아래의 소스코드를 이용하여 주어진 두 선분이 이루는 각과 동일한 크기를 가지는 각을 그려보도록 합시다. 각 \\(O\\)와 동일한 각을 가지는 각 \\(A\\)를 그리기 위하여 점 \\(A\\)를 지나는 선분을 추가합니다. O &lt;- c(0,0); A &lt;- c(10,0); #점 A,B 추가 plot(c(O[1],A[1]),c(O[2],A[2]),type=&quot;p&quot;,pch=19,cex=0.7, axes=FALSE,xlim=c(-3,20),ylim=c(-3,20),xlab=&quot;&quot;,ylab=&quot;&quot;) #직선 l 추가 abline(h=O[2], col=alpha(&quot;blue&quot;,0.3)) #선분 OM0 추가 angle &lt;- 45 #각도 degree M0 &lt;- getPoint1(O, 8, angle) lines(c(O[1],M0[1]),c(O[2],M0[2])) #선분 ON0 추가 N0 &lt;- getPoint1(O, 8, 0) lines(c(O[1],N0[1]),c(O[2],N0[2])) #선분 AB0 추가 B0 &lt;- getPoint1(A, 8, 0) lines(c(A[1],B0[1]),c(A[2],B0[2])) my_text2(list(O,A),ptext=c(&#39;O&#39;,&#39;A&#39;),dx=c(0,0),dy=c(-1,-1), color=c(&#39;black&#39;,&#39;black&#39;),useItalic=FALSE) 점 \\(O\\)를 중심으로 하는 원을 그려 각 \\(O\\)의 두 변과의 교점 \\(M\\), \\(N\\)을 추가합니다. length &lt;- 3 DrawArc(x=O[1],y=O[2],rx=length,theta.1=-30/180*pi,theta.2=(angle+30)/180*pi, col=alpha(&#39;red&#39;,0.5)) M &lt;- getPoint1(O, length, angle) points(M[1],M[2],pch=19,col=&#39;gray&#39;,cex=0.7) N &lt;- getPoint1(O, length, 0) points(N[1],N[2],pch=19,col=&#39;gray&#39;,cex=0.7) my_text2(list(M,N),ptext=c(&#39;M&#39;,&#39;N&#39;),dx=c(0,0),dy=c(1,-1), color=c(&#39;gray&#39;,&#39;gray&#39;),useItalic=FALSE) 점 \\(A\\)를 중심으로 반지름의 길이가 선분 \\(ON\\)인 원을 그려 주어진 반직선과의 교점 \\(B\\)를 추가합니다. length_ON &lt;- st_distance(st_point(O), st_point(N)) DrawArc(x=A[1],y=A[2],rx=length_ON,theta.1=-30/180*pi,theta.2=(angle+30)/180*pi, col=alpha(&#39;red&#39;,0.5)) B &lt;- getPoint1(A, length_ON, 0) points(B[1],B[2],pch=19,col=&#39;gray&#39;,cex=0.7) 선분 \\(MN\\)의 길이를 구합니다. length_MN &lt;- st_distance(st_point(M), st_point(N)) angle_MNO &lt;- 90 + angle/2 DrawArc(x=N[1],y=N[2],rx=length_MN,theta.1=(angle_MNO-30)/180*pi, theta.2=(angle_MNO+30)/180*pi,col=alpha(&#39;red&#39;,0.5)) 점 \\(B\\)를 중심으로 반지름의 길이가 선분 \\(MN\\)인 원을 그려 두 번째 단계에서 그린 원과의 교점 \\(C\\)를 추가합니다. DrawArc(x=B[1],y=B[2],rx=length_MN,theta.1=(angle_MNO-30)/180*pi, theta.2=(angle_MNO+30)/180*pi,col=alpha(&#39;red&#39;,0.5)) C &lt;- getPoint1(A, length_ON, angle) points(C[1],C[2],pch=19,col=&#39;gray&#39;,cex=0.7) my_text2(list(B,C),ptext=c(&#39;B&#39;,&#39;C&#39;),dx=c(0,0),dy=c(-1,1), color=c(&#39;gray&#39;,&#39;gray&#39;),useItalic=FALSE) 두 점 \\(A\\)와 \\(C\\)를 잇는 반직선을 그려서 각 \\(O\\)와 동일한 각 \\(A\\)를 구합니다. C0 &lt;- getPoint1(A, 8, angle) lines(c(A[1],C0[1]),c(A[2],C0[2]),col=&#39;dimgray&#39;) 위의 소스코드를 단계 별로 실행하면 그림 5.25가 생성됩니다. 그림 5.25: 각 O와 크기가 같은 각 A 위의 소스코드의 각 \\(O\\)의 크기를 angle &lt;- 45에서 angle &lt;- 115로 변경하고 소스코드를 단계 별로 다시 실행해 보세요. 이제 앞에서 배운 평행선에서의 동위각 성질을 이용하여 점 \\(P\\)를 지나고 직선 \\(l\\)에 평행한 직선을 그려보도록 하겠습니다. 일곱 단계로 작성된 아래의 소스코드를 단계 별로 실행해보면서 결과를 확인해 보세요. 점 \\(A\\), \\(B\\)를 지나는 직선 \\(l\\)과 점 \\(P\\)를 추가합니다. A &lt;- c(3,2); B &lt;- c(7,1) P &lt;- c(5,6) #점 A, B 추가 plot(c(A[1],B[1]),c(A[2],B[2]),type=&quot;p&quot;,pch=19,cex=0.7,col=alpha(&#39;dimgray&#39;,0.5), axes=FALSE,xlim=c(-1,10),ylim=c(-1,10),xlab=&quot;&quot;,ylab=&quot;&quot;) my_text2(list(A,B),ptext=c(&#39;A&#39;,&#39;B&#39;), dx=c(0,0),dy=c(-0.5,-0.5),color=rep(alpha(&#39;dimgray&#39;,0.5),2),useItalic=FALSE) #점 A, B를 지나는 직선 l 구함; lm(y좌표 벡터 ~ x좌표 벡터) l &lt;- lm(c(A[2],B[2])~c(A[1],B[1])) #직선 l의 일차방정식 y=a+bx la &lt;- as.numeric(l[[1]][1]) lb &lt;- as.numeric(l[[1]][2]) getly &lt;- function(lx) {return (la + lb*lx)} #직선 l 추가 abline(l) #점 P 추가 points(P[1],P[2],pch=19,col=&#39;black&#39;,cex=0.7) my_text2(list(P),ptext=c(&#39;P&#39;),dx=c(0),dy=c(0.5),color=&#39;black&#39;,useItalic=FALSE) 점 \\(P\\)를 지나고 직선 \\(l\\)과 만나는 직선을 그립니다. #직선을 그리기 위하여 직선 l 위의 점 C 생성 cx &lt;- 2; cy &lt;- getly(cx) C &lt;- c(cx,cy) #점 C 추가 points(C[1],C[2],pch=19,col=alpha(&#39;blue&#39;,0.5),cex=0.7) my_text2(list(C),ptext=c(&#39;C&#39;),dx=c(0),dy=c(-0.5), color=alpha(&#39;blue&#39;,0.5),useItalic=FALSE) #점 P, C를 지나는 직선 m 구함; lm(y좌표 벡터 ~ x좌표 벡터) m &lt;- lm(c(P[2],C[2])~c(P[1],C[1])) #직선 m 추가 abline(m,col=alpha(&#39;blue&#39;,0.5)) 점 \\(C\\)를 중심으로 하는 원을 그려 각 \\(C\\)의 윗변 교점 \\(D\\)와 아랫변 교점 \\(E\\)를 추가합니다. length &lt;- 2 angle_C_vector &lt;- my_draw_arc(B,C,P,r=length,color=alpha(&#39;red&#39;,0.5),over=20) D &lt;- getPoint1(C, length, angle_C_vector[2]) points(D[1],D[2],pch=19,col=alpha(&#39;red&#39;,0.5),cex=0.7) E &lt;- getPoint1(C, length, angle_C_vector[1]) points(E[1],E[2],pch=19,col=alpha(&#39;red&#39;,0.5),cex=0.7) my_text2(list(D,E),ptext=c(&#39;D&#39;,&#39;E&#39;), dx=c(0,0),dy=c(-0.5,-0.5),color=rep(alpha(&#39;red&#39;,0.5),2),useItalic=FALSE) 점 \\(P\\)를 중심으로 반지름의 길이가 선분 \\(CD\\)인 원을 그려 주어진 직선과의 교점 \\(F\\)를 추가합니다. length_CD &lt;- st_distance(st_point(C), st_point(D)) DrawArc(x=P[1],y=P[2],rx=length_CD,theta.1=(angle_C_vector[1]-20)/180*pi, theta.2=(angle_C_vector[2]+20)/180*pi,col=alpha(&#39;red&#39;,0.5)) F &lt;- getPoint1(P, length_CD, angle_C_vector[2]) points(F[1],F[2],pch=19,col=alpha(&#39;red&#39;,0.5),cex=0.7) my_text2(list(F),ptext=c(&#39;F&#39;),dx=c(0),dy=c(0.5), color=alpha(&#39;red&#39;,0.5),useItalic=FALSE) 선분 \\(DE\\)의 길이를 구합니다. length_DE &lt;- st_distance(st_point(D), st_point(E)) angle_DE &lt;- -1 * (90 - angle_C_vector[2] + angle_C_vector[3]/2) DrawArc(x=D[1],y=D[2],rx=length_DE,theta.1=(angle_DE-30)/180*pi, theta.2=(angle_DE+30)/180*pi,col=alpha(&#39;red&#39;,0.5)) 점 \\(F\\)를 중심으로 선분 \\(DE\\)의 길이를 반지름으로 하는 원을 그려 두 번째 단계에서 그린 원과의 교점 \\(Q\\)를 추가합니다. DrawArc(x=F[1],y=F[2],rx=length_DE,theta.1=(angle_DE-30)/180*pi, theta.2=(angle_DE+30)/180*pi,col=alpha(&#39;red&#39;,0.5)) Q &lt;- getPoint1(F, length_DE, angle_DE) points(Q[1],Q[2],pch=19,col=&#39;black&#39;,cex=0.7) my_text2(list(Q),ptext=c(&#39;Q&#39;),dx=c(0),dy=c(0.5),color=&#39;black&#39;,useItalic=FALSE) 두 점 \\(P\\)와 \\(Q\\)를 잇는 직선 \\(n\\)을 그려서 점 \\(A\\)와 점 \\(B\\)를 지나는 직선 \\(l\\)과 평행한 직선을 구합니다. n &lt;- lm(c(P[2],Q[2])~c(P[1],Q[1])) abline(n) 위의 소스코드를 단계 별로 실행하면 그림 5.26이 생성됩니다. 그림 5.26: 점 P를 지나고 직선 l과 평행한 직선 지금까지 직선의 길이과 각을 이용한 각도에 대하여 알아보았습니다. 이제 삼각형의 작도로 넘어가 봅시다. 5.2.2 삼각형의 작도 삼각형 \\(ABC\\)를 기호로 \\(\\triangle ABC\\)로 나타내고, \\(\\angle A\\)와 마주 보는 변 \\(BC\\)를 \\(\\angle A\\)의 대변 (opposite side, opposite edge)이라 하고 \\(\\angle A\\)를 변 \\(BC\\)의 대각 (opposite angle)이라고 합니다. 이를 아래의 소스코드를 이용하여 그려보면 그림 5.27과 같습니다. A &lt;- c(2,5); B &lt;- c(0,0); C &lt;- c(5,1) #선분 AB, 선분 BC, 선분 CA 추가 plot(c(A[1],B[1]),c(A[2],B[2]),type=&quot;l&quot;, axes=FALSE,xlim=c(-2,7),ylim=c(-2,7),xlab=&quot;&quot;,ylab=&quot;&quot;) lines(c(B[1],C[1]),c(B[2],C[2]),col=&#39;blue&#39;) lines(c(C[1],A[1]),c(C[2],A[2])) #점 A, B C 추가 points(c(A[1],B[1],C[1]),c(A[2],B[2],C[2]),pch=19,col=c(&#39;red&#39;,&#39;blue&#39;,&#39;blue&#39;),cex=0.7) my_text2(list(A,B,C),ptext=c(&#39;A&#39;,&#39;B&#39;,&#39;C&#39;), dx=c(0,-0.5,0.5),dy=c(0.5,0,0),color=c(&#39;red&#39;,&#39;blue&#39;,&#39;blue&#39;),useItalic=FALSE) #각 A의 호 추가 my_draw_arc(B,A,C,0.7,&#39;red&#39;) 그림 5.27: 각 A의 대변 BC, 변 BC의 대각 A \\(\\triangle ABC\\)에서 \\(\\angle A\\), \\(\\angle B\\), \\(\\angle C\\)의 대변의 길이를 \\(a\\), \\(b\\), \\(c\\)로 나타내 볼 수 있습니다. 아래의 소스코드를 실행하면, 그림 5.27에서 그린 \\(\\triangle ABC\\)의 세 대변의 길이 \\(a\\), \\(b\\), \\(c\\)를 그려볼 수 있습니다. 소스코드 중 get_center_mid_point(p1,p2,r)함수가 사용되었는데, 이 함수는 두 점 \\(p1\\), \\(p2\\)를 지나는 원의 중심 좌표 (\\(x4\\),\\(y4\\))와 두 점의 중간 지점 (\\(x0\\),\\(y0\\))을 반환합니다. 함수의 반환값 (리턴값)은 함수 작성자의 필요에 따라 다양한 값을 가질 수 있습니다. 이 함수의 리턴값은 \\(4\\)개의 숫자값을 가진 벡터로 이루어져 있으며, 첫 두 값은 두 점 \\(p1\\), \\(p2\\)를 지나는 원의 중심점 좌표 (\\(x4\\),\\(y4\\))를, 마지막 두 값은 두 점 \\(p1\\), \\(p2\\)의 중간 지점(\\(x0\\),\\(y0\\))을 반환하게 됩니다. 예를 들어, a &lt;- get_center_mid_point(B,C,5)와 같은 코드가 실행되면, a는 \\(4\\)개의 숫자를 가지는 벡터를 리턴받게 되고, 두 점 \\(B\\), \\(C\\)를 지나는 원의 중심점 좌표는 c(a[1],a[2]), 두 점 \\(B\\), \\(C\\)의 중간 지점의 좌표는 c(a[3],a[4])와 같은 방식으로 얻을 수 있습니다. library(DescTools) #DrawArc()함수를 위한 패키지 로딩 #두 점 p1, p2를 지나는 원의 중심 좌표 (x4,y4)와 두 점의 중간 지점 (x0,y0)을 구하는 함수 get_center_mid_point &lt;- function(p1,p2,r) { xa &lt;- 1/2*(p2[1]-p1[1]); ya &lt;- 1/2 *(p2[2]-p1[2]) x0 &lt;- p1[1]+xa; y0 &lt;- p1[2]+ya a &lt;- sqrt(xa*xa + ya*ya); b &lt;- sqrt(r*r - a*a) #x3 &lt;- x0 + b*ya/a; y3 &lt;- y0 - b*xa/a x4 &lt;- x0 - b*ya/a; y4 &lt;- y0 + b*xa/a #두 점을 지나는 원의 중심점과 두 점의 중간점을 반환함 return (c(x4,y4,x0,y0)) } #삼각형의 세 대변의 (x4,y4)와 (x0,y0)을 구함 a &lt;- get_center_mid_point(B,C,5) b &lt;- get_center_mid_point(C,A,5) c &lt;- get_center_mid_point(A,B,5) #두 점을 지나는 원의 중심 좌표를 이용하여 변의 길이 호를 추가 my_draw_arc(B,c(a[1],a[2]),C,5,&#39;black&#39;,lty=3) my_draw_arc(C,c(b[1],b[2]),A,5,&#39;black&#39;,lty=3) my_draw_arc(A,c(c[1],c[2]),B,5,&#39;black&#39;,lty=3) #두 점의 중간 점 좌표를 이용하여 변의 길이 이름 a, b, c 추가 my_text2(list(c(a[3],a[4]),c(b[3],b[4]),c(c[3],c[4])),ptext=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;), dx=c(0.5,1,-1),dy=c(-1,0.5,0.5),color=rep(&#39;black&#39;,3)) 하나의 삼각형은 세 변의 길이와 세 각의 크기를 가집니다. 삼각형의 총 여섯 가지 특성 중에서 다음과 같이 특정한 세가지 특성 정보가 주어지면 그 삼각형을 작도해 볼 수 있습니다. 세 변의 길이가 주어질 때 (그림 5.28) 그림 5.28: 세 변의 길이가 주어질 때 a_length &lt;- 5; b_length &lt;- 3; c_length &lt;- 4 # 1. 길이가 a인 선분 BC를 작도한다. #점 B 추가 B &lt;- c(0,0); plot(c(B[1]),c(B[2]),type=&quot;p&quot;,pch=19,cex=0.7,col=&#39;black&#39;, axes=FALSE,xlim=c(-2,7),ylim=c(-2,7),xlab=&quot;&quot;,ylab=&quot;&quot;) DrawArc(x=B[1],y=B[2],rx=a_length,theta.1=-20/180*pi, theta.2=20/180*pi,col=alpha(&#39;red&#39;,0.5)) #점 B와 C를 지나는 직선 l의 일차방정식 y = 0 + 0.1 * x la &lt;- 0; lb &lt;- 0.1 #ly = la + lb * lx get_ly &lt;- function(lx) { return (la + lb*lx)} lx &lt;- 7; ly &lt;- get_ly(lx) #직선 l 추가 abline(a=la,b=lb,col=alpha(&#39;dimgray&#39;,0.5)) #직선 l의 각도 구하기 angle_l &lt;- atan2(ly,lx) * 180 / pi #점 C 추가 C &lt;- getPoint1(B, a_length, angle_l) points(C[1],C[2],pch=19,col=&#39;red&#39;,cex=0.7) #선분 BC 추가 lines(c(B[1],C[1]),c(B[2],C[2])) my_text2(list(B,C),ptext=c(&#39;B&#39;,&#39;C&#39;), dx=c(0,0),dy=c(-0.5,-0.5),color=rep(&#39;black&#39;,2),useItalic=FALSE) # 2. 점 B를 중심으로 반지름의 길이가 c인 원을 그린다. DrawArc(x=B[1],y=B[2],rx=c_length,theta.1=20/180*pi, theta.2=80/180*pi,col=alpha(&#39;red&#39;,0.5)) # 3. 점 C를 중심으로 반지름의 길이가 b인 원을 그린다. DrawArc(x=C[1],y=C[2],rx=b_length,theta.1=100/180*pi, theta.2=160/180*pi,col=alpha(&#39;red&#39;,0.5)) # 4. #2와 #3에서 그린 두 원의 교점을 A라고 한다. arc_C = st_cast(st_buffer(st_point(C), b_length),&quot;LINESTRING&quot;) arc_B = st_cast(st_buffer(st_point(B), c_length),&quot;LINESTRING&quot;) point_A &lt;- st_intersection(arc_C,arc_B) A &lt;- c(point_A[1,1],point_A[1,2]) points(A[1],A[2],pch=19,col=&#39;red&#39;,cex=0.7) my_text2(list(A),ptext=c(&#39;A&#39;), dx=c(0),dy=c(0.5),color=&#39;black&#39;,useItalic=FALSE) # 5. 길이가 c인 선분 AB와 길이가 b인 선분 AC를 작도한다. #선분 AB 추가 lines(c(A[1],B[1]),c(A[2],B[2])) #선분 AC 추가 lines(c(A[1],C[1]),c(A[2],C[2])) 두 변의 길이와 그 끼인각의 크기가 주어질 때 (그림 5.29) 그림 5.29: 두 변의 길이와 그 끼인각의 크기가 주어질 때 A_angle &lt;- 50; b_length &lt;- 5; c_length &lt;- 4 # 1. 각 A를 이루는 두 개의 반직선을 작도한다. #점 A 추가 A &lt;- c(0,0); plot(c(A[1]),c(A[2]),type=&quot;p&quot;,pch=19,cex=0.7,col=&#39;black&#39;, axes=FALSE,xlim=c(-2,7),ylim=c(-2,7),xlab=&quot;&quot;,ylab=&quot;&quot;) my_text2(list(A),ptext=&#39;A&#39;,dx=0,dy=-0.5,color=&#39;black&#39;,useItalic=FALSE) #직선 l 추가, y = a + b*x la &lt;- 0; lb &lt;- 0 get_ly &lt;- function(lx) {return (0)} abline(a=la,b=lb,col=alpha(&#39;dimgray&#39;,0.5)) #반직선 AP 추가 lx &lt;- 6; ly &lt;- get_ly(lx); P &lt;- c(lx,ly) lines(c(A[1],P[1]),c(A[2],P[2])) #직선 m 추가, y = a + b*x ma &lt;- 0; mb &lt;- tan(A_angle*pi/180) get_my &lt;- function(mx) {return (ma + mb*mx)} abline(a=ma,b=mb,col=alpha(&#39;dimgray&#39;,0.5)) #반직선 AQ 추가 mx &lt;- 5; my &lt;- get_my(mx); Q &lt;- c(mx,my) lines(c(A[1],Q[1]),c(A[2],Q[2])) my_text2(list(P,Q),ptext=c(&#39;l&#39;,&#39;m&#39;),dx=c(0.5,0.5),dy=c(0,0.5), color=rep(&#39;black&#39;,2)) # 2. 주어진 각도를 작도하여 확인한다 (생략 가능). #점A에서 반지름 2인 원 추가 A_r &lt;- 2 DrawArc(x=A[1],y=A[2],rx=A_r,theta.1=-20/180*pi, theta.2=(A_angle+20)/180*pi,col=alpha(&#39;gray&#39;,0.5)) #각 변과 원을 이용하여 교점 M과 N의 좌표를 구함 l_line &lt;- st_linestring(cbind(c(A[1],P[1]),c(A[2],P[2]))) m_line &lt;- st_linestring(cbind(c(A[1],Q[1]),c(A[2],Q[2]))) A_arc = st_cast(st_buffer(st_point(A), A_r),&quot;LINESTRING&quot;) M_point &lt;- st_intersection(l_line,A_arc) N_point &lt;- st_intersection(m_line,A_arc) M &lt;- c(M_point[1],M_point[2]) N &lt;- c(N_point[1],N_point[2]) #교점 M과 N 추가 points(M[1],M[2],pch=19,col=alpha(&#39;gray&#39;,0.5),cex=0.7) my_text2(list(M),ptext=&#39;M&#39;,dx=0,dy=-0.5,color=alpha(&#39;gray&#39;,0.5),useItalic=FALSE) points(N[1],N[2],pch=19,col=alpha(&#39;gray&#39;,0.5),cex=0.7) my_text2(list(N),ptext=&#39;N&#39;,dx=0,dy=0.5,color=alpha(&#39;gray&#39;,0.5),useItalic=FALSE) #선분 MN의 거리 측정 length_MN &lt;- st_distance(st_point(M), st_point(N)) #점 M를 중심으로 반지름의 길이가 선분 MN인 원을 그림 DrawArc(x=M[1],y=M[2],rx=length_MN,theta.1=90/180*pi,theta.2=130/180*pi, col=alpha(&#39;gray&#39;,0.5)) # 3. 점 A를 중심으로 반지름의 길이가 c인 원을 그려 각 A의 한 변과의 교점을 B라고 한다. DrawArc(x=A[1],y=A[2],rx=c_length,theta.1=-20/180*pi, theta.2=20/180*pi,col=alpha(&#39;red&#39;,0.5)) B &lt;- getPoint1(A, c_length, 0) points(B[1],B[2],pch=19,col=&#39;red&#39;,cex=0.7) my_text2(list(B),ptext=&#39;B&#39;,dx=0,dy=-0.5,color=&#39;black&#39;,useItalic=FALSE) # 4. 점 A를 중심으로 반지름의 길이가 b인 원을 그려 각 A의 다른 한 변과의 교점을 C라고 한다. DrawArc(x=A[1],y=A[2],rx=b_length,theta.1=(A_angle-20)/180*pi, theta.2=(A_angle+20)/180*pi,col=alpha(&#39;red&#39;,0.5)) C &lt;- getPoint1(A, b_length, A_angle) points(C[1],C[2],pch=19,col=&#39;red&#39;,cex=0.7) my_text2(list(C),ptext=&#39;C&#39;,dx=0,dy=0.5,color=&#39;black&#39;,useItalic=FALSE) # 5. 두 점 B와 C를 이어서 만든 삼각형 ABC를 완성한다. lines(c(B[1],C[1]),c(B[2],C[2])) 한 변의 길이와 그 양 끝 각의 크기가 주어질 때 (그림 5.30) 그림 5.30: 한 변의 길이와 그 양 끝 각의 크기가 주어질 때 a_length &lt;- 5; B_angle &lt;- 30; C_angle &lt;- 60 # 1. 길이가 a인 선분 BC를 작도한다. #점 B 추가 B &lt;- c(0,0); plot(c(B[1]),c(B[2]),type=&quot;p&quot;,pch=19,cex=0.7,col=&#39;black&#39;, axes=FALSE,xlim=c(-2,7),ylim=c(-2,7),xlab=&quot;&quot;,ylab=&quot;&quot;) DrawArc(x=B[1],y=B[2],rx=a_length,theta.1=-20/180*pi, theta.2=20/180*pi,col=alpha(&#39;red&#39;,0.5)) #점 B와 C를 지나는 직선 l의 일차방정식 y = a + b*x la &lt;- 0; lb &lt;- 0 #ly = la + lb * lx get_ly &lt;- function(lx) { return (la + lb*lx)} lx &lt;- 7; ly &lt;- get_ly(lx) #직선 l 추가 abline(a=la,b=lb,col=alpha(&#39;dimgray&#39;,0.5)) my_text2(list(c(lx,ly)),ptext=&#39;l&#39;,dx=0,dy=-0.5,color=alpha(&#39;dimgray&#39;,0.5)) #직선 l의 각도 구하기 angle_l &lt;- atan2(ly,lx) * 180 / pi #점 C 추가 C &lt;- getPoint1(B, a_length, angle_l) points(C[1],C[2],pch=19,col=&#39;red&#39;,cex=0.7) #선분 BC 추가 lines(c(B[1],C[1]),c(B[2],C[2])) my_text2(list(B,C),ptext=c(&#39;B&#39;,&#39;C&#39;), dx=c(0,0),dy=c(-0.5,-0.5),color=rep(&#39;black&#39;,2),useItalic=FALSE) # 2. 각 B를 위한 직선 m을 작도한다. #각 B를 위한 직선 m의 일차방정식, y = a + b*x ma &lt;- 0; mb &lt;- tan(B_angle*pi/180) #my = ma + mb*mx get_my &lt;- function(mx) {return (ma + mb*mx)} mx &lt;- 7; my &lt;- get_my(mx) abline(a=ma,b=mb,col=alpha(&#39;dimgray&#39;,0.5)) my_text2(list(c(mx,my)),ptext=&#39;m&#39;,dx=0,dy=-0.5,color=alpha(&#39;dimgray&#39;,0.5)) # 3. 각 B를 작도하여 확인한다 (생략 가능). #점B에서 반지름 2인 원 추가 B_r &lt;- 2 DrawArc(x=B[1],y=B[2],rx=B_r,theta.1=-20/180*pi, theta.2=(B_angle+20)/180*pi,col=alpha(&#39;gray&#39;,0.5)) #각 변과 원을 이용하여 교점 M과 N의 좌표를 구함 l_line &lt;- st_linestring(cbind(c(B[1],lx),c(B[2],ly))) m_line &lt;- st_linestring(cbind(c(B[1],mx),c(B[2],my))) B_arc = st_cast(st_buffer(st_point(B), B_r),&quot;LINESTRING&quot;) M_point &lt;- st_intersection(l_line,B_arc) N_point &lt;- st_intersection(m_line,B_arc) M &lt;- c(M_point[1],M_point[2]) N &lt;- c(N_point[1],N_point[2]) #교점 M과 N 추가 points(M[1],M[2],pch=19,col=alpha(&#39;gray&#39;,0.5),cex=0.7) my_text2(list(M),ptext=&#39;M&#39;,dx=0,dy=-0.5,color=alpha(&#39;gray&#39;,0.5),useItalic=FALSE) points(N[1],N[2],pch=19,col=alpha(&#39;gray&#39;,0.5),cex=0.7) my_text2(list(N),ptext=&#39;N&#39;,dx=0,dy=0.5,color=alpha(&#39;gray&#39;,0.5),useItalic=FALSE) #선분 MN의 거리 측정 length_MN &lt;- st_distance(st_point(M), st_point(N)) #점 M를 중심으로 반지름의 길이가 선분 MN인 원을 그림 DrawArc(x=M[1],y=M[2],rx=length_MN,theta.1=80/180*pi,theta.2=130/180*pi, col=alpha(&#39;gray&#39;,0.5)) # 4. 각 C를 위한 직선 n을 작도한다. #각 C를 위한 직선 n의 일차방정식, y = a + b*x C_angle &lt;- 180 - C_angle #반대 방향으로 작도하므로 nb &lt;- tan(C_angle*pi/180) #ny = na + nb*nx na &lt;- C[2] - nb * C[1] #na = ny - nb*nx get_ny &lt;- function(nx) {return (na + nb*nx)} nx &lt;- 1; ny &lt;- get_ny(nx) abline(a=na,b=nb,col=alpha(&#39;dimgray&#39;,0.5)) my_text2(list(c(nx,ny)),ptext=&#39;n&#39;,dx=0,dy=-0.5,color=alpha(&#39;dimgray&#39;,0.5)) # 5. 각 C를 작도하여 확인한다 (생략 가능). #점C에서 반지름 2인 원 추가 C_r &lt;- 1.5 DrawArc(x=C[1],y=C[2],rx=C_r,theta.1=(C_angle-20)/180*pi, theta.2=(180+20)/180*pi,col=alpha(&#39;gray&#39;,0.5)) #각 변과 원을 이용하여 교점 O과 P의 좌표를 구함 l_line2 &lt;- st_linestring(cbind(c(C[1],B[1]),c(C[2],B[2]))) n_line &lt;- st_linestring(cbind(c(C[1],nx),c(C[2],ny))) C_arc = st_cast(st_buffer(st_point(C), C_r),&quot;LINESTRING&quot;) O_point &lt;- st_intersection(l_line2,C_arc) P_point &lt;- st_intersection(n_line,C_arc) O &lt;- c(O_point[1],O_point[2]) P &lt;- c(P_point[1],P_point[2]) #교점 O와 P 추가 points(O[1],O[2],pch=19,col=alpha(&#39;gray&#39;,0.5),cex=0.7) my_text2(list(O),ptext=&#39;O&#39;,dx=0,dy=-0.5,color=alpha(&#39;gray&#39;,0.5),useItalic=FALSE) points(P[1],P[2],pch=19,col=alpha(&#39;gray&#39;,0.5),cex=0.7) my_text2(list(P),ptext=&#39;P&#39;,dx=0,dy=0.5,color=alpha(&#39;gray&#39;,0.5),useItalic=FALSE) #선분 OP의 거리 측정 length_OP &lt;- st_distance(st_point(O), st_point(P)) #점 O를 중심으로 반지름의 길이가 선분 OP인 원을 그림 DrawArc(x=O[1],y=O[2],rx=length_OP,theta.1=40/180*pi,theta.2=100/180*pi, col=alpha(&#39;gray&#39;,0.5)) # 6. 두 반직선의 교점을 A라고 한다. m_line &lt;- st_linestring(cbind(c(B[1],mx),c(B[2],my))) n_line &lt;- st_linestring(cbind(c(C[1],nx),c(C[2],ny))) A_point &lt;- st_intersection(m_line,n_line) A &lt;- c(A_point[1],A_point[2]) points(A[1],A[2],pch=19,col=&#39;black&#39;,cex=0.7) my_text2(list(A),ptext=&#39;A&#39;,dx=0,dy=0.5,color=&#39;black&#39;,useItalic=FALSE) # 7. 선분 AB와 선분 AC를 작도한다. #선분 AB 추가 lines(c(A[1],B[1]),c(A[2],B[2])) #선분 AC 추가 lines(c(A[1],C[1]),c(A[2],C[2])) 5.2.3 삼각형의 합동 조건 두 개의 도형이 모양 (shape)과 크기 (size)가 같아서 완전히 겹쳐질 때 서로 합동 (congruence) 이라고 합니다. 두 개의 삼각형을 똑같은 조건으로 작도하였을 경우, 두 삼각형은 모양과 크기가 같기 때문에 두 삼각형은 합동입니다. 아래의 소스코드를 이용하여 모양과 크기가 같은 \\(\\triangle ABC\\)와 \\(\\triangle DEF\\)를 그려볼 수 있습니다 (그림 5.31). #점 A, B, C의 좌표 A &lt;- c(3,3); B &lt;- c(0,0); C &lt;- c(4,0) #점 D, E, F의 좌표 D &lt;- c(9,3); E &lt;- c(6,0); F &lt;- c(10,0) #선분 AB, 선분 BC, 선분 CA 추가 plot(c(A[1],B[1]),c(A[2],B[2]),type=&quot;l&quot;, axes=FALSE,xlim=c(-1,11),ylim=c(-1,11),xlab=&quot;&quot;,ylab=&quot;&quot;) lines(c(B[1],C[1]),c(B[2],C[2])) lines(c(C[1],A[1]),c(C[2],A[2])) my_text2(list(A,B,C),ptext=c(&#39;A&#39;,&#39;B&#39;,&#39;C&#39;),dx=c(0,0,0),dy=c(0.5,-0.5,-0.5), color=rep(&#39;black&#39;,3),useItalic=FALSE) #선분 DE, 선분 EF, 선분 FD 추가 lines(c(D[1],E[1]),c(D[2],E[2])) lines(c(E[1],F[1]),c(E[2],F[2])) lines(c(F[1],D[1]),c(F[2],D[2])) my_text2(list(D,E,F),ptext=c(&#39;D&#39;,&#39;E&#39;,&#39;F&#39;),dx=c(0,0,0),dy=c(0.5,-0.5,-0.5), color=rep(&#39;black&#39;,3),useItalic=FALSE) #각 기호 추가 my_draw_arc(B,A,C,0.5,&#39;red&#39;); my_draw_arc(E,D,F,0.5,&#39;red&#39;) my_draw_arc(C,B,A,0.5,&#39;green&#39;); my_draw_arc(F,E,D,0.5,&#39;green&#39;) my_draw_arc(A,C,B,0.5,&#39;blue&#39;); my_draw_arc(D,F,E,0.5,&#39;blue&#39;) #변 기호 추가 my_text2(list(c((A[1]+B[1])/2,(A[2]+B[2])/2),c((D[1]+E[1])/2,(D[2]+E[2])/2), c((B[1]+C[1])/2,(B[2]+C[2])/2),c((E[1]+F[1])/2,(E[2]+F[2])/2), c((C[1]+A[1])/2,(C[2]+A[2])/2),c((F[1]+D[1])/2,(F[2]+D[2])/2)), ptext=rep(c(&#39;|&#39;,&#39;||&#39;,&#39;o&#39;),each=2), dx=rep(0,6),dy=rep(0,6),color=rep(&#39;black&#39;,6),useItalic=FALSE) 그림 5.31: 서로 합동인 삼각형 ABC$와 삼각형 DEF \\(\\triangle ABC\\)와 \\(\\triangle DEF\\)가 아래 세가지 조건 중 하나를 만족시킬 때, 두 삼각형은 서로 합동이라고 하고, 기호로는 \\(\\triangle ABC \\equiv \\triangle DEF\\)와 같이 나타냅니다. S는 변 (Side), A는 각 (Angle)을 의미합니다. 대응하는 세 변의 길이가 각각 같을 때 (SSS 합동) \\[\\overline{AB} = \\overline{DE}, \\quad \\overline{BC} = \\overline{EF}, \\quad \\overline{CA} = \\overline{FD}\\] 대응하는 두 변의 길이가 각각 같고, 그 끼인각의 크기가 같을 때 (SAS 합동) \\[\\overline{AB} = \\overline{DE}, \\quad \\angle B = \\angle E, \\quad \\overline{BC} = \\overline{EF}\\] 대응하는 한 변의 길이가 같고, 그 양 끝 각의 크기가 각각 같을 때 (ASA 합동) \\[\\angle B = \\angle E, \\quad \\overline{BC} = \\overline{EF}, \\quad \\angle C = \\angle F\\] 이번 장에서는 점, 선, 면에 대해서 알아보고, 점, 직선, 평면의 위치 관계도 살펴보았습니다. 각, 평행선, 삼각형의 성질을 알아보고 직접 그려보았습니다. 이러한 각 과정들이 소스코드로 어떻게 구현되는지도 알아보았습니다. 이제 6장 도형의 성질에 대하여 본격적으로 알아봅시다. "],
["features-characteristics.html", "6 도형의 성질 6.1 평면도형의 성질 6.2 입체도형의 성질", " 6 도형의 성질 평면도형이나 입체도형에서 성립하는 각, 넓이, 부피와 관련된 성질을 알아봅니다. RStudio가 열려 있지 않으면 RStudio를 실행하고 메뉴에서 File &gt;&gt; Open Project…를 클릭하여 이전에 저장한 R 프로젝트 파일인 rmath01.Rproj을 찾아서 선택하고 Open 버튼을 클릭하여 이전에 작업하던 프로젝트 환경을 로딩합니다. 파일탐색기나 파인더에서 rmath01.Rproj 파일을 찾아서 더블 클릭하여도 RStudio가 실행되면서 작업하던 프로젝트 환경이 로딩됩니다. 프로젝트 환경이 로딩된 후에 RStudio 콘솔창에 getwd()를 실행하여 작업 환경이 제대로 로딩되었는지 확인합니다. RStudio 환경이 잘 로딩되었으면, 이제 본격적으로 시작해 봅시다. 6.1 평면도형의 성질 다각형, 원, 부채꼴과 같은 평면도형 (plane figure)의 성질에 대하여 알아봅니다. 6.1.1 다각형의 대각선 삼각형, 사각형, 오각형, 육각형, 칠각형 등과 같이 여러 개의 선분으로 둘러싸인 평면도형을 다각형 (polygon)이라고 하고, 선분의 개수가 \\(3\\)개, \\(4\\)개, \\(5\\)개, \\(6\\)개, \\(7\\)개, \\(…\\), \\(n\\)개인 다각형을 각각 삼각형, 사각형, 오각형, 육각형, 칠각형, \\(…\\), \\(n\\)각형이라고 합니다. 꼭짓점이 \\(4\\)개 이상인 다각형은 서로 이웃하지 않는 꼭짓점을 가지게 되고 이 두 꼭짓점을 이은 선분을 대각선 (diagonal or diagonal line)이라고 합니다. 아래의 소스코드를 이용하여 삼각형, 사각형, 오각형, 육각형의 대각선을 그려볼 수 있습니다. 오각형의 대각선을 하나 그립니다. library(sf) A &lt;- c(2,5); B &lt;- c(6,8); C &lt;- c(10,4); D &lt;- c(8,0); E &lt;- c(5,0) #점 A, B, C, D, E를 꼭짓점으로 하는 오각형 pentagon &lt;- st_polygon(list(cbind(c(A[1],B[1],C[1],D[1],E[1],A[1]), c(A[2],B[2],C[2],D[2],E[2],A[2])))) plot(pentagon,col=&#39;lightgray&#39;) line_segment_AC &lt;- st_linestring(cbind(c(A[1],C[1]),c(A[2],C[2]))) plot(line_segment_AC,add=TRUE,col=&#39;darkblue&#39;,lty=2) 대각선을 그리는 fn_add_diagonal()함수를 이용하여 오각형의 나머지 대각선도 전부 그립니다. fn_add_diagonal &lt;- function(p1, p2, color=&#39;black&#39;,linetype=2,linewidth=1) { a_line_segment &lt;- st_linestring(cbind(c(p1[1],p2[1]),c(p1[2],p2[2]))) plot(a_line_segment,add=TRUE,col=color,lty=linetype,lwd=linewidth) } fn_add_diagonal(A,D,color=&#39;blue&#39;) fn_add_diagonal(B,D,color=&#39;dimgray&#39;) fn_add_diagonal(B,E,color=&#39;purple&#39;) fn_add_diagonal(C,E,color=&#39;darkgreen&#39;) 오각형의 다섯 개의 꼭짓점 중에서 네 개 만을 이용하여 사각형을 그리고 사각형의 대각선을 그립니다. #점 A, B, C, D를 꼭짓점으로 하는 사각형 rectangle &lt;- st_polygon(list(cbind(c(A[1],B[1],C[1],D[1],A[1]), c(A[2],B[2],C[2],D[2],A[2])))) plot(rectangle,col=&#39;lightgray&#39;) fn_add_diagonal(A,C,color=&#39;blue&#39;) fn_add_diagonal(B,D,color=&#39;dimgray&#39;) 삼각형을 그려보면 각 꼭짓점이 서로 이웃하므로 대각선을 그릴 수 없다는 걸 확인할 수 있습니다. #점 A, B, C를 꼭짓점으로 하는 삼각형 triangle &lt;- st_polygon(list(cbind(c(A[1],B[1],C[1],A[1]),c(A[2],B[2],C[2],A[2])))) plot(triangle,col=&#39;lightgray&#39;) 오각형의 꼭짓점에 한 점을 추가하여 육각형을 생성하고 대각선을 그립니다. F &lt;- c(2,2) #점 A, B, C, D, E, F를 꼭짓점으로 하는 육각형 hexagon &lt;- st_polygon(list(cbind(c(A[1],B[1],C[1],D[1],E[1],F[1],A[1]), c(A[2],B[2],C[2],D[2],E[2],F[2],A[2])))) plot(hexagon,col=&#39;lightgray&#39;) fn_add_diagonal(A,C,color=&#39;darkblue&#39;) fn_add_diagonal(A,D,color=&#39;blue&#39;) fn_add_diagonal(A,E,color=&#39;darkorange&#39;) fn_add_diagonal(B,D,color=&#39;dimgray&#39;) fn_add_diagonal(B,E,color=&#39;purple&#39;) fn_add_diagonal(B,F,color=&#39;brown&#39;) fn_add_diagonal(C,E,color=&#39;darkgreen&#39;) fn_add_diagonal(C,F,color=&#39;darkviolet&#39;) fn_add_diagonal(D,F,color=&#39;violet&#39;) 각 꼭짓점에서 그을 수 있는 대각선의 개수는 삼각형의 경우 \\(0\\)개, 사각형의 경우 \\(1\\)개, 오각형의 경우 \\(2\\)개, 육각형의 경우 \\(3\\)개입니다 (그림 6.1). \\(n\\)각형의 각 꼭짓점에서 그을 수 있는 대각선의 개수는 \\(n - 3\\)이고, \\(n\\)각형의 모든 꼭짓점에서 그을 수 있는 대각선의 개수는 \\(n(n-3)\\)가 됩니다. 이 중에서 양 끝 꼭짓점에서 중복되는 대각선을 제외하면 \\(n\\)각형의 실제 대각선의 개수는 \\(\\frac{n(n-3)}{2}\\)입니다. 그림 6.1: 다각형의 대각선 대각선의 개수를 구하는 공식 \\(\\frac{n(n-3)}{2}\\)을 이용하면 표 6.1과 같은 정보를 얻을 수 있습니다. 표를 생성하는 데 사용된 소스코드는 아래와 같습니다. library(dplyr) library(kableExtra) sides &lt;- 3:20 diagonals &lt;- sides*(sides-3)/2 #diagonal_df &lt;- data.frame(sides,diagonals) #두 개의 컬럼을 가지는 세로로 긴 데이터 프레임 생성 diagonal_df2 &lt;- data.frame(sides[1:9],diagonals[1:9], sides[10:18],diagonals[10:18]) #네 개의 컬럼을 가지는 데이터 프레임 생성 knitr::kable( diagonal_df2, col.names = rep(c(&#39;변의 개수 (n각형)&#39;, &#39;대각선의 개수&#39;),2), #표 컬럼 이름 설정 booktabs = TRUE, align = &quot;c&quot;, #표 위치 설정 caption = &#39;n각형의 대각선의 개수&#39;) %&gt;% #표 제목 설정 kable_styling(full_width=FALSE,font_size=15) %&gt;% #표 컬럼 간격 설정 column_spec(2, border_right=TRUE, include_thead=TRUE, extra_css=&quot;border-right:double lightgrey;&quot;) 표 6.1: n각형의 대각선의 개수 변의 개수 (n각형) 대각선의 개수 변의 개수 (n각형) 대각선의 개수 3 0 12 54 4 2 13 65 5 5 14 77 6 9 15 90 7 14 16 104 8 20 17 119 9 27 18 135 10 35 19 152 11 44 20 170 6.1.2 다각형의 내각과 외각 다각형에서 이웃한 두 변으로 이루어지는 내부의 각을 그 다각형의 내각 (internal angle, interior angle)이라고 합니다. 5.1.2절 각의 성질에서 생성한 my_draw_arc()함수를 이용하여 아래와 같이 삼각형, 사각형, 오각형, 육각형의 내각을 그려봅시다. my_draw_arc()함수의 이름을 fn_add_diagonal()와 같은 패턴인 fn_draw_arc()로 변경하고 실행하여 R 환경에 함수를 로딩합니다. library(DescTools) #DrawArc()함수를 위한 패키지 로딩 my_draw_arc &lt;- function(p1,po,p2,r,color,lty=1,lwd=1,over=0) { #각도 계산 angle1 &lt;- atan2(p1[2]-po[2],p1[1]-po[1]) #선분1과 x축과의 각도 atan2(y,x) angle2 &lt;- atan2(p2[2]-po[2],p2[1]-po[1]) #선분2와 x축과의 각도 atan2(y,x) if(angle1 &lt;0) angle1 = angle1 + 2*pi #각도가 음수로 표현되는 경우 양수로 변경 if(angle2 &lt;0) angle2 = angle2 + 2*pi #각도가 음수로 표현되는 경우 양수로 변경 angle &lt;- angle2 - angle1 #두 각도 차이를 이용한 두 반직선의 각도 구하기 if(angle &lt;0) angle = angle + 2*pi #각도가 음수로 표현되는 경우 양수로 변경 angle_degree &lt;- angle*180/pi #radian 각도를 degree(°)로 변환 #점 P를 중심으로 theta.1 부터 theta.2 까지 각도 선호 그리기 over &lt;- over *pi/180 #degree(°) 각도를 radian 각도로 변환 DrawArc(x=po[1],y=po[2],rx=r,theta.1=angle1-over,theta.2=angle2+over, col=color,lty=lty,lwd=lwd) print(paste0(&#39;angle = &#39;,sprintf(&#39;%1.0f&#39;,angle_degree),&#39;°&#39;)) return (c(angle1*180/pi, angle2*180/pi, angle_degree)) #계산 결과값이 필요한 경우에만 사용 } fn_draw_arc &lt;- my_draw_arc 삼각형의 내각의 크기의 합은 \\(180° \\times 1 = 180°\\)을 확인합니다. library(sf) library(scales) A &lt;- c(2,5); B &lt;- c(6,8); C &lt;- c(10,4); D &lt;- c(8,0); E &lt;- c(5,0); F &lt;- c(2,2) triangle &lt;- st_polygon(list(cbind(c(A[1],B[1],C[1],A[1]),c(A[2],B[2],C[2],A[2])))) plot(triangle,col=alpha(&#39;red&#39;,0.1),border=&#39;dimgray&#39;) fn_draw_arc(C,A,B,1,&#39;red&#39;) fn_draw_arc(A,B,C,1,&#39;red&#39;) fn_draw_arc(B,C,A,1,&#39;red&#39;) 사각형의 내각의 크기의 합은 \\(180° \\times 2 = 360°\\)을 확인합니다. triangle1 &lt;- st_polygon(list(cbind(c(A[1],B[1],D[1],A[1]),c(A[2],B[2],D[2],A[2])))) plot(triangle1,col=alpha(&#39;red&#39;,0.1),border=&#39;dimgray&#39;,xlim=c(A[1],C[1]),ylim=c(D[2],B[2])) B2 &lt;- c(B[1]+0.1,B[2]); C2 &lt;- c(C[1]+0.1,C[2]); D2 &lt;- c(D[1]+0.1,D[2]) triangle2 &lt;- st_polygon(list(cbind(c(B2[1],C2[1],D2[1],B2[1]),c(B2[2],C2[2],D2[2],B2[2])))) plot(triangle2,col=alpha(&#39;blue&#39;,0.1),,border=&#39;dimgray&#39;,add=TRUE) fn_draw_arc(D,A,B,1,&#39;red&#39;) fn_draw_arc(A,B,D,1,&#39;red&#39;) fn_draw_arc(B,D,A,1,&#39;red&#39;) fn_draw_arc(D2,B2,C2,1,&#39;blue&#39;) fn_draw_arc(B2,C2,D2,1,&#39;blue&#39;) fn_draw_arc(C2,D2,B2,1,&#39;blue&#39;) 오각형의 내각의 크기의 합은 \\(180° \\times 3 = 540°\\)을 확인합니다. triangle1 &lt;- st_polygon(list(cbind(c(A[1],B[1],E[1],A[1]),c(A[2],B[2],E[2],A[2])))) plot(triangle1,col=alpha(&#39;red&#39;,0.1),border=&#39;dimgray&#39;,xlim=c(A[1],C[1]),ylim=c(E[2],B[2])) B2 &lt;- c(B[1]+0.1,B[2]); D2 &lt;- c(D[1]+0.1,D[2]); E2 &lt;- c(E[1]+0.1,E[2]) triangle2 &lt;- st_polygon(list(cbind(c(B2[1],D2[1],E2[1],B2[1]),c(B2[2],D2[2],E2[2],B2[2])))) plot(triangle2,col=alpha(&#39;blue&#39;,0.1),,border=&#39;dimgray&#39;,add=TRUE) B3 &lt;- c(B[1]+0.2,B[2]); C3 &lt;- c(C[1]+0.2,C[2]); D3 &lt;- c(D[1]+0.2,D[2]) triangle3 &lt;- st_polygon(list(cbind(c(B3[1],C3[1],D3[1],B3[1]),c(B3[2],C3[2],D3[2],B3[2])))) plot(triangle3,col=alpha(&#39;green&#39;,0.1),,border=&#39;dimgray&#39;,add=TRUE) fn_draw_arc(E,A,B,1,&#39;red&#39;) fn_draw_arc(A,B,E,1,&#39;red&#39;) fn_draw_arc(B,E,A,1,&#39;red&#39;) fn_draw_arc(E2,B2,D2,1,&#39;blue&#39;) fn_draw_arc(B2,D2,E2,1,&#39;blue&#39;) fn_draw_arc(D2,E2,B2,1,&#39;blue&#39;) fn_draw_arc(D3,B3,C3,1,&#39;green&#39;) fn_draw_arc(B3,C3,D3,1,&#39;green&#39;) fn_draw_arc(C3,D3,B3,1,&#39;green&#39;) 육각형의 내각 크기의 합이 \\(180° \\times 4 = 720°\\)인 것을 확인합니다. fn_draw_arc()함수의 입력값은 좌표, 좌표, 좌표, 숫자, 문자열과 같이 서로 다른 다섯 개의 데이터 객체로 이루어져 있습니다. 육각형을 \\(4\\)개의 삼각형으로 나누고 각 삼각형의 내각을 표현하기 위해서 fn_draw_arc()함수를 \\(12\\)번 사용하고, 각 함수는 \\(5\\)개의 입력값을 사용하였습니다. 각 입력값의 데이터 객체를 유지하기 위하여 벡터 대신에 리스트를 사용하였습니다. li &lt;- list(F,A,B,1,'red')와 같이 리스트를 생성하면 li[[1]], li[[5]]와 같이 리스트의 각 객체에 접근할 수 있습니다. 아래의 코드에서는, \\(12 \\times 5\\) 크기의 \\(2\\)차원 리스트 (리스트의 리스트)를 생성한 후, for루프를 이용하여 fn_draw_arc()함수를 반복 호출하는 형식으로 내각을 그렸습니다. triangle1 &lt;- st_polygon(list(cbind(c(A[1],B[1],F[1],A[1]),c(A[2],B[2],F[2],A[2])))) plot(triangle1,col=alpha(&#39;red&#39;,0.1),border=&#39;dimgray&#39;,xlim=c(F[1],C[1]),ylim=c(E[2],B[2])) B2 &lt;- c(B[1]+0.1,B[2]); E2 &lt;- c(E[1]+0.1,E[2]); F2 &lt;- c(F[1]+0.1,F[2]) triangle2 &lt;- st_polygon(list(cbind(c(B2[1],E2[1],F2[1],B2[1]),c(B2[2],E2[2],F2[2],B2[2])))) plot(triangle2,col=alpha(&#39;blue&#39;,0.1),,border=&#39;dimgray&#39;,add=TRUE) B3 &lt;- c(B[1]+0.2,B[2]); D3 &lt;- c(D[1]+0.2,D[2]); E3 &lt;- c(E[1]+0.2,E[2]) triangle3 &lt;- st_polygon(list(cbind(c(B3[1],D3[1],E3[1],B3[1]),c(B3[2],D3[2],E3[2],B3[2])))) plot(triangle3,col=alpha(&#39;green&#39;,0.1),,border=&#39;dimgray&#39;,add=TRUE) B4 &lt;- c(B[1]+0.3,B[2]); C4 &lt;- c(C[1]+0.3,C[2]); D4 &lt;- c(D[1]+0.3,D[2]) triangle4 &lt;- st_polygon(list(cbind(c(B4[1],C4[1],D4[1],B4[1]),c(B4[2],C4[2],D4[2],B4[2])))) plot(triangle4,col=alpha(&#39;orange&#39;,0.1),,border=&#39;dimgray&#39;,add=TRUE) #fn_draw_arc()의 5개의 입력값을 12번 반복하기 위한 12x5 크기의 2차원 리스트 생성 input_list &lt;- list(list(F,A,B,1,&#39;red&#39;), list(A,B,F,1,&#39;red&#39;), list(B,F,A,1,&#39;red&#39;), list(F2,B2,E2,1,&#39;blue&#39;), list(B2,E2,F2,1,&#39;blue&#39;), list(E2,F2,B2,1,&#39;blue&#39;), list(E3,B3,D3,1,&#39;green&#39;), list(B3,D3,E3,1,&#39;green&#39;), list(D3,E3,B3,1,&#39;green&#39;), list(D4,B4,C4,1,&#39;orange&#39;), list(B4,C4,D4,1,&#39;orange&#39;), list(C4,D4,B4,1,&#39;orange&#39;)) for(i in 1:length(input_list)) { li &lt;- input_list[[i]] #li[[1]] = input_list[[i]][[1]] fn_draw_arc(li[[1]],li[[2]],li[[3]],li[[4]],li[[5]]) } 한 꼭짓점에서 그은 대각선은 사각형, 오각형, 육각형을 각각 \\(2\\)개, \\(3\\)개, \\(4\\)개의 삼각형으로 나눕니다 (그림 6.2). 삼각형의 내각의 크기의 합은 \\(180°\\)이므로 \\(n\\)각형의 내각의 크기의 합은 \\(180° \\times (n-2)\\)입니다. 그림 6.2: 다각형의 내각의 크기의 합 다각형에서 한 내각의 꼭짓점에서 한 변과 그 변에 이웃한 변의 연장선이 이루는 각을 그 내각의 외각 (exterior angle)이라고 합니다. 다각형에서 한 내각의 외각은 두 개이지만 서로 크기가 같은 맞꼭지각이므로 둘 중 하나만 생각하면 됩니다 (그림 6.3). 그림 6.3: 삼각형의 내각과 외각 아래의 소스코드를 이용하면, 삼각형의 내각 (빨간색 실선)과 외각 (파란색 점선)을 그려볼 수 있습니다. # 1. 점 A, B, C를 꼭짓점으로 하는 삼각형을 그립니다. triangle &lt;- st_polygon(list(cbind(c(A[1],B[1],C[1],A[1]),c(A[2],B[2],C[2],A[2])))) plot(triangle,col=&#39;lightgray&#39;,xlim=c(A[1]-1,C[1]+1),ylim=c(C[2]-1,B[2]+1)) # 2. 두 점 p1, p2을 지나는 선분의 연장선의 두 끝점 벡터를 구하는 함수를 생성합니다. 시작점 c(x1,y1), 끝점 c(x2,y2) fn_get_two_extension_points &lt;- function (p1,p2,fromExt=TRUE,toExt=TRUE) { #점 p1, p2를 지나는 직선 ext_line 구함; lm(y좌표 벡터 ~ x좌표 벡터) ext_line &lt;- lm(c(p1[2],p2[2])~c(p1[1],p2[1])) #직선 ext_line의 일차방정식 y=a+bx a &lt;- as.numeric(ext_line[[1]][1]); b &lt;- as.numeric(ext_line[[1]][2]) #직선 ext_line 추가 abline(ext_line,col=alpha(&#39;lightgray&#39;,0.5)) x1 &lt;- p1[1]-1; y1 &lt;- a + b*x1 x2 &lt;- p2[1]+1; y2 &lt;- a + b*x2 if(fromExt) lines(c(x1,p1[1]),c(y1,p1[2]),col=&#39;darkblue&#39;) if(toExt) lines(c(p2[1],x2),c(p2[2],y2),col=&#39;darkblue&#39;) return (c(x1,y1,x2,y2)) } # 3. 변 AB와 변BC의 연장선 시작점, 끝점 좌표를 얻고 시작점 방향 연장선과 끝점 방향 연장선을 그립니다. AB_extension &lt;- fn_get_two_extension_points(A,B,fromExt=FALSE,toExt=TRUE) BC_extension &lt;- fn_get_two_extension_points(B,C,fromExt=TRUE,toExt=FALSE) # 4. 내각을 그립니다. fn_draw_arc(A,B,C,1,&#39;red&#39;) # 5. 변 AB 연장선의 끝점 좌표을 얻고 외각을 그립니다. AB_to &lt;- c(AB_extension[3],AB_extension[4]) fn_draw_arc(C,B,AB_to,1,&#39;blue&#39;,lty=2) # 6. 변 BC 연장선의 시작점 좌표를 얻고 외각을 그립니다. BC_from &lt;- c(BC_extension[1],BC_extension[2]) fn_draw_arc(BC_from,B,A,1,&#39;blue&#39;,lty=2) 이제, 오각형의 외각을 그려보고 \\(n\\)각형의 외각의 크기의 합을 구하는 방법을 알아봅시다. 점 \\(A\\), \\(B\\), \\(C\\), \\(D\\), \\(E\\)를 꼭짓점으로 하는 오각형을 그립니다. pentagon &lt;- st_polygon(list(cbind(c(A[1],B[1],C[1],D[1],E[1],A[1]), c(A[2],B[2],C[2],D[2],E[2],A[2])))) plot(pentagon,col=&#39;lightgray&#39;,xlim=c(A[1]-1,C[1]+1),ylim=c(D[2]-1,B[2]+1)) 5.1.4절 평행선의 성질에서 생성한 my_text2()함수를 이용하여 꼭짓점의 이름을 추가합니다. my_text2()함수의 이름을 fn_draw_arc()와 같은 패턴인 fn_draw_text()로 변경하고 실행하여 R 환경에 함수를 로딩합니다. library(rlang) #expr()안에서 변수를 사용하기 위한 패키지 로딩 my_text2 &lt;- function(p,ptext,dx,dy,color,size=1,useItalic=TRUE) { for(i in 1:length(ptext)) { myp=p[[i]] if(useItalic) text(myp[1]+dx[i],myp[2]+dy[i], expr(italic(!!ptext[i])),col=color[i],cex=size) else text(myp[1]+dx[i],myp[2]+dy[i],ptext[i],col=color[i],cex=size) } } fn_draw_text &lt;- my_text2 fn_draw_text()를 이용하여 꼭짓점 \\(A\\), \\(B\\), \\(C\\), \\(D\\), \\(E\\)의 이름을 추가합니다. fn_draw_text(list(A,B,C,D,E),ptext=c(&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;), dx=c(-0.5,0,0.5,0,0),dy=c(0,0.5,0,-0.5,-0.5), color=rep(&#39;black&#39;,5),useItalic=FALSE) 각 변의 연장선 시작점, 끝점 좌표를 얻고 한쪽 방향 연장선만 그립니다. AB_extension &lt;- fn_get_two_extension_points(A,B,fromExt=TRUE,toExt=FALSE) BC_extension &lt;- fn_get_two_extension_points(B,C,fromExt=TRUE,toExt=FALSE) DC_extension &lt;- fn_get_two_extension_points(D,C,fromExt=FALSE,toExt=TRUE) ED_extension &lt;- fn_get_two_extension_points(E,D,fromExt=FALSE,toExt=TRUE) AE_extension &lt;- fn_get_two_extension_points(A,E,fromExt=FALSE,toExt=TRUE) 내각은 빨간색 실선으로 외각은 파란색 점선으로 그립니다. fn_draw_arc(E,A,B,1,&#39;red&#39;) fn_draw_arc(c(AB_extension[1],AB_extension[2]),A,E,1,&#39;blue&#39;,lty=2) fn_draw_arc(A,B,C,1,&#39;red&#39;) fn_draw_arc(c(BC_extension[1],BC_extension[2]),B,A,1,&#39;blue&#39;,lty=2) fn_draw_arc(B,C,D,1,&#39;red&#39;) fn_draw_arc(c(DC_extension[3],DC_extension[4]),C,B,1,&#39;blue&#39;,lty=2) fn_draw_arc(C,D,E,1,&#39;red&#39;) fn_draw_arc(c(ED_extension[3],ED_extension[4]),D,C,1,&#39;blue&#39;,lty=2) fn_draw_arc(D,E,A,1,&#39;red&#39;) fn_draw_arc(c(AE_extension[3],AE_extension[4]),E,D,1,&#39;blue&#39;,lty=2) \\(n\\)각형에서 외각의 크기의 합은 각 꼭짓점과 연장선이 이루는 평각 (\\(180°\\))의 합에서 내각의 크기의 합을 빼는 방법으로 구할 수 있습니다 (그림 6.4). \\(n\\)각형에서 외각의 크기의 합은 아래의 식으로 설명할 수 있으며, 다각형의 모양과 변의 개수에 관계없이 다각형의 외각의 크기의 합은 \\(360°\\)로 일정합니다. \\[\\small (외각의 \\: 크기의 \\: 합) \\normalsize = 180° \\times n - \\small (내각의 \\: 크기의 \\: 합) \\normalsize = 180° \\times n - 180° \\times (n - 2) = 360°\\] 그림 6.4: 다각형의 외각의 크기의 합 또한, 삼각형의 한 외각의 크기는 그와 이웃하지 않는 두 내각의 크기의 합과 같습니다 (그림 6.5). 삼각형의 한 꼭짓점에서 내각과 외각의 크기의 합은 \\(180°\\) (\\(\\angle BCD + \\angle C = 180°\\))이고, 세 내각의 크기의 합도 \\(180°\\) (\\(\\angle A + \\angle B + \\angle C = 180°\\))이기 때문에 \\(\\angle BCD = \\angle A + \\angle B\\)이 성립합니다. 그림 6.5: 삼각형의 한 외각의 크기와 이웃하는 않는 두 내각의 크기의 합 위의 그림은 아래의 소스코드를 이용하여 그려졌습니다. # 1. 점 A, B, C를 꼭짓점으로 하는 삼각형을 그립니다. triangle &lt;- st_polygon(list(cbind(c(A[1],B[1],C[1],A[1]),c(A[2],B[2],C[2],A[2])))) plot(triangle,col=&#39;lightgray&#39;,xlim=c(A[1]-1,C[1]+1),ylim=c(C[2]-1,B[2]+1)) # 2. 변BC의 연장선 시작점, 끝점 좌표를 얻고 끝점 방향 연장선을 그립니다. AC_extension &lt;- fn_get_two_extension_points(A,C,fromExt=FALSE,toExt=TRUE) # 3. 변BC의 연장선 상의 점 D를 그립니다. D &lt;- c(AC_extension[3],AC_extension[4]) points(D[1],D[2],pch=19,col=&#39;black&#39;,cex=0.5) # 4. 각 꼭짓점의 이름을 추가합니다. fn_draw_text(list(A,B,C,D),ptext=c(&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;), dx=c(0,0,0,0),dy=c(-0.5,0.5,-0.5,-0.5), color=rep(&#39;black&#39;,4),useItalic=FALSE) # 5. 내각을 그립니다. fn_draw_arc(C,A,B,0.8,&#39;blue&#39;) fn_draw_arc(A,B,C,0.8,&#39;blue&#39;) fn_draw_arc(B,C,A,0.8,&#39;red&#39;) # 6. 외각을 그립니다. fn_draw_arc(D,C,B,0.8,&#39;blue&#39;) 6.1.3 원과 부채꼴 호 (arc), 현 (chord), 부채꼴 (sector), 중심각 (central angle), 할선 (secant line), 활꼴 (segment, segment of a circle, cresent)에 대하여 알아봅시다. 원 \\(O\\) 위에 두 점 \\(A\\), \\(B\\)를 잡으면 원의 둘레는 두 부분으로 나뉘게 되는데 이 두 부분을 각각 호라고 합니다 (그림 6.6). 양 끝점이 \\(A\\), \\(B\\)인 호 \\(AB\\)를 기호로 \\(\\small \\overparen {AB}\\)로 나타내고, \\(\\small \\overparen {AB} = \\overparen {BA}\\)가 성립합니다. 보통 \\(\\small \\overparen {AB}\\)는 작은 쪽의 호를 나타내고 큰 쪽의 호를 나타낼 때에는 큰 호 위에 한 점 \\(C\\)를 잡아 \\(\\small \\overparen {ACB}\\)와 같이 나타냅니다. 그리고, 원 위의 두 점 \\(A\\), \\(B\\)를 이은 선분을 현이라 하고, 현 \\(AB\\)라고 부릅니다. 현이 원의 중심을 지나는 경우 현의 길이는 그 원의 지름 (diameter)이 됩니다. 그림에서는 작은 호는 파란색, 큰 호는 녹색, 현은 빨간색으로 표현되었으며, 아래의 소스코드로 그려볼 수 있습니다. 그림 6.6: 원의 호와 현 #점 A, B, O의 좌표 A &lt;- c(-3,3); B &lt;- c(3,3); O &lt;- c(0,0) #원의 반지름 r &lt;- sqrt(A[1]*A[1] + A[2]*A[2]) #원 추가 circle_O &lt;- st_buffer(st_point(O), r) plot(circle_O,col=alpha(&#39;gray&#39;,0.3),border=alpha(&#39;gray&#39;,0.3), xlim=c(O[1]-r-1,O[1]+r+1),ylim=c(O[2]-r-1,O[2]+r+1)) #원의 중심점 추가 points(O[1],O[2],pch=19,col=&#39;black&#39;,cex=0.5) fn_draw_text(list(O),ptext=c(&#39;O&#39;),dx=c(0),dy=c(-0.5),color=c(&#39;black&#39;),useItalic=FALSE) #현 AB 추가 lines(c(A[1],B[1]),c(A[2],B[2]),col=&#39;red&#39;,lwd=1) fn_draw_text(list(A,B),ptext=c(&#39;A&#39;,&#39;B&#39;),dx=c(-0.7,0.7),dy=c(0,0), color=rep(&#39;black&#39;,2),useItalic=FALSE) #호 AB 추가 fn_draw_arc(B,O,A,r,&#39;blue&#39;,lwd=1) #점 C 추가 Cx &lt;- 2; Cy &lt;- -1*sqrt(r*r-Cx*Cx); C &lt;- c(Cx,Cy) points(C[1],C[2],pch=19,col=&#39;black&#39;,cex=0.5) fn_draw_text(list(C),ptext=c(&#39;C&#39;),dx=c(0),dy=c(-0.5),color=c(&#39;black&#39;),useItalic=FALSE) #호 ACB 추가 fn_draw_arc(A,O,B,r,&#39;darkgreen&#39;,lwd=1) 원 \\(O\\)에서 두 반지름 \\(OA\\), \\(OB\\)와 \\(\\small \\overparen {AB}\\)로 이루어진 부채 모양의 도형을 부채꼴 \\(AOB\\)라고 하고, \\(\\angle AOB\\)를 부채꼴 \\(AOB\\)의 중심각 또는 호 \\(AB\\)의 중심각이라고 합니다 (그림 6.7). 그리고, 원 \\(O\\)와 직선 \\(l\\)이 서로 다른 두 점 \\(C\\), \\(D\\)에서 만날 때, 직선 \\(l\\)을 원 \\(O\\)의 할선이라고 하고, 현 \\(CD\\)와 \\(\\small \\overparen {CD}\\)로 이루어진 활 모양의 도형을 활꼴이라고 합니다. 그림에서는 부채꼴은 파란색, 부채꼴의 중심각은 빨간색, 할선과 활꼴은 녹색으로 표현되었으며, 아래의 소스코드로 그려볼 수 있습니다. 그림 6.7: 부채꼴과 활꼴 #점 A, B, O의 좌표 A &lt;- c(-3,3); B &lt;- c(3,3); O &lt;- c(0,0) #원의 반지름 r &lt;- sqrt(A[1]*A[1] + A[2]*A[2]) #원 추가 circle_O &lt;- st_buffer(st_point(O), r) plot(circle_O,col=alpha(&#39;gray&#39;,0.1),border=alpha(&#39;gray&#39;,1), xlim=c(O[1]-r-1,O[1]+r+1),ylim=c(O[2]-r-1,O[2]+r+1)) #원의 중심점 추가 points(O[1],O[2],pch=19,col=&#39;black&#39;,cex=0.5) fn_draw_text(list(O),ptext=c(&#39;O&#39;),dx=c(0),dy=c(-0.5),color=c(&#39;black&#39;),useItalic=FALSE) #부채꼴 추가 DrawCircle(O[1],O[2],r.out=r,theta.1=atan2(B[2],B[1]),theta.2=atan2(A[2],A[1]), col=alpha(&#39;blue&#39;,0.2),border=alpha(&#39;blue&#39;,0.5)) fn_draw_text(list(A,B),ptext=c(&#39;A&#39;,&#39;B&#39;),dx=c(-0.7,0.7),dy=c(0,0), color=rep(&#39;black&#39;,2),useItalic=FALSE) #중심각 추가 fn_draw_arc(B,O,A,0.5,&#39;red&#39;) #점 C, D와 두 점을 지나는 할선 추가 y &lt;- -2; Cx &lt;- -1*sqrt (r*r-y*y); Dx &lt;- -1*Cx; C &lt;- c(Cx,y); D &lt;- c(Dx,y) l &lt;- lm(c(C[2],D[2])~c(C[1],D[1])) abline(l,col=alpha(&#39;darkgreen&#39;,1)) fn_draw_text(list(C,D),ptext=c(&#39;C&#39;,&#39;D&#39;),dx=c(-0.2,0.2),dy=c(-0.5,-0.5), color=rep(&#39;black&#39;,2),useItalic=FALSE) fn_draw_text(list(c(O[1]-r-1,y)),ptext=c(&#39;l&#39;),dx=-1,dy=-0.5,color=&#39;darkgreen&#39;) #활꼴 추가 rect_CD &lt;- st_polygon(list(cbind(c(C[1],D[1],D[1],C[1],C[1]), c(C[2],D[2],D[2]-r,C[2]-r,C[2])))) i &lt;- st_intersection(circle_O,rect_CD) plot(i,col=alpha(&#39;green&#39;,0.2),border=alpha(&#39;green&#39;,0.5),add=TRUE) 6.1.4 부채꼴의 넓이와 호의 길이 한 원에서 두 부채꼴의 중심각이 같으면, 두 부채꼴의 넓이와 호의 길이도 각각 같습니다 (그림 6.8). 또한, 두 부채꼴의 넓이와 호의 길이가 각각 같으면 두 부채꼴의 중심각의 크기도 같습니다. 아래의 소스코드를 이용하면 중심각이 \\(45°\\)인 두 부채꼴 중 한 부채꼴을 엔터를 클릭할 때마다 \\(15°\\)씩 회전시켜 두 부채꼴을 중첩시킨 다음, 두 부채꼴의 중심각, 호의 길이, 넓이를 비교해 볼 수 있습니다. 그림 6.8: 중심각이 같은 두 부채꼴의 호의 길이과 넓이 O &lt;- c(0,0); r &lt;- 5 #원의 중심점과 반지름 정보 angle1 &lt;- 0; angle2 &lt;- 45 #부채꼴 중심각 정보 circle_O &lt;- st_buffer(st_point(O), r) #원 생성 color &lt;- colorspace::rainbow_hcl(7) #색상 벡터 생성 angle_shift &lt;- 225 #엔터를 눌러서 부채꼴을 움직여 중심각이 같은 또 하나의 부채꼴을 중첩시켜 두 부채꼴의 넓이와 호의 길이가 각각 같음을 확인 for (i in 1:10) { #원 추가 plot(circle_O,col=alpha(&#39;gray&#39;,0.1),border=alpha(&#39;gray&#39;,1), xlim=c(O[1]-r-1,O[1]+r+1),ylim=c(O[2]-r-1,O[2]+r+1)) #원의 중심점 추가 points(O[1],O[2],pch=19,col=&#39;black&#39;,cex=0.5) fn_draw_text(list(O),ptext=c(&#39;O&#39;),dx=c(0),dy=c(-0.7),color=c(&#39;black&#39;),useItalic=FALSE) #부채꼴1을 추가 DrawCircle(O[1],O[2],r.out=r,theta.1=angle1*pi/180,theta.2=angle2*pi/180, col=alpha(color[1],0.5),border=alpha(&#39;dimgray&#39;,0.5)) #부채꼴2을 angle_shift 만큼 회전 DrawCircle(O[1],O[2],r.out=r,theta.1=(angle1+angle_shift)*pi/180, theta.2=(angle2+angle_shift)*pi/180, col=alpha(color[1],0.5),border=alpha(&#39;dimgray&#39;,0.5)) #두 부채꼴이 완전히 중첩되면 루프문을 종료 if((angle1+angle_shift) %% 360 == 0) { print(&quot;두 부채꼴의 중심각이 같으면, 두 부채꼴의 넓이와 호의 길이도 각각 같습니다.&quot;) break #루프문을 멈춤 } #angle_shift를 15°씩 증가시킴 angle_shift &lt;- angle_shift + 15 #사용자가 엔터를 누르면 다음 루프로 넘어감 readline(prompt=paste0(&#39;중심각이 &#39;,angle2,&quot;°인 부채꼴을 회전시키려면 [enter]를 누르세요.&quot;)) } 부채꼴의 중심각이 변할 때 부채꼴의 호의 길이와 넓이는 어떻게 변할까요? 그림 6.9에서 확인할 수 있는 것 처럼, 부채꼴의 중심각이 반으로 줄어들 수록 호의 길이와 부채꼴의 넓이가 각각 반으로 줄어듭니다. 아래의 소스코드를 실행하여 부채꼴의 중심각이 변할 때 호의 길이와 넓이가 어떻게 변하는지 직접 실행해보세요. 그림 6.9: 한 원에서 부채꼴의 중심각과 호의 길이, 중심각과 넓이와의 정비례 관계 O &lt;- c(0,0); r &lt;- 5 #원의 중심점과 반지름 정보 angle1 &lt;- 0; angle2 &lt;- 360 #부채꼴 중심각 정보 #원 추가 circle_O &lt;- st_buffer(st_point(O), r) plot(circle_O,col=alpha(&#39;gray&#39;,0.1),border=alpha(&#39;gray&#39;,1), xlim=c(O[1]-r-1,O[1]+r+1),ylim=c(O[2]-r-1,O[2]+r+1)) #원의 중심점 추가 points(O[1],O[2],pch=19,col=&#39;black&#39;,cex=0.5) fn_draw_text(list(O),ptext=c(&#39;O&#39;),dx=c(0),dy=c(-0.7),color=c(&#39;black&#39;),useItalic=FALSE) #색상 벡터 생성 color &lt;- colorspace::rainbow_hcl(7) #엔터를 눌러서 현재 중심각의 1/2인 중심각을 가지는 부채꼴 그리기 for (i in 1:7) { DrawCircle(O[1],O[2],r.out=r,theta.1=angle1*pi/180,theta.2=angle2*pi/180, col=alpha(color[i],0.5),border=alpha(&#39;dimgray&#39;,0.5)) #중심각을 현재 중심각의 1/2로 변경 angle2 &lt;- angle2/2 #사용자가 엔터를 누르면 다음 루프로 넘어감 if (i &lt; 7) readline(prompt=paste0(&#39;중심각이 &#39;,angle2,&#39;°인 부채꼴을 그려보려면 [enter]를 누르세요.&#39;)) } 부채꼴의 중심각이 두배 씩 증가하는 경우를 확인하기 위해서는, 위의 소스코드 두 번째 줄에 있는 angle2 &lt;- 360를 angle2 &lt;- 45/8로, for 루프 안의 angle2 &lt;- angle2/2를 angle2 &lt;- angle2*2로 변경하고 소스코드를 실행해 보면 됩니다. 이를 위해서 RStudio 메뉴에서 File &gt;&gt; New File &gt;&gt; R Script를 클릭하여 새로운 R 스크립트 편집창을 엽니다. 그 다음에, 위의 소스코드를 복사하여 새로 열린 RStudio의 R 스크립트 편집창에 붙여 넣습니다. 그런 다음에 R 스크립트 편집창의 소스코드 중에서 위에서 언급한 두 부분 (소스코드 두 번째줄에 있는 angle2 &lt;- 360를 angle2 &lt;- 45/8로, for 루프 안의 angle2 &lt;- angle2/2를 angle2 &lt;- angle2*2로)을 변경하고 실행해보면 엔터키를 누를 때마다 부채꼴의 중심각이 두 배씩 증가하는 것을 볼 수 있습니다. 부채꼴의 중심각이 두 배 증가할 때마다 호의 길이와 부채꼴의 넓이가 각각 두 배로 증가하는 것을 확인할 수 있습니다. 따라서, 반지름이 동일한 원에서 부채꼴의 호의 길이와 중심각의 크기는 정비례하고, 부채꼴의 호의 길이와 부채꼴의 넓이도 정비례한다는 것을 알 수 있습니다. 부채꼴의 중심각과 호의 길이, 또는 부채꼴의 중심각과 넓이 사의의 정비례 관계를 이용하면, 두 부채꼴의 중심각과 한 부채꼴의 호의 길이만 주어졌을 때, 나머지 한 부채꼴의 호의 길이를 구할 수 있습니다. 두 부채꼴의 성질을 이용하여 아래와 같이 함수를 생성하고, 주어진 문제를 푸는데 사용할 수 있습니다. #비례식을 이용하여 부채꼴의 미지수를 구하는 함수, A:B = C:D fn_get_unknown_of_a_sector_using_proportions &lt;- function (A,B,C,D,unknown) { #A:B = C:D, A*D = B*C if(unknown == &#39;A&#39;) { result &lt;- B*C/D #A = B*C/D } else if(unknown == &#39;B&#39;) { result &lt;- A*D/C #B = A*D/C } else if(unknown == &#39;C&#39;) { result &lt;- A*D/B #C = A*D/B } else if(unknown == &#39;D&#39;) { result &lt;- B*C/A #D = B*C/A } return (result) } 위의 함수의 if()문과 else if()문을 switch-case문의 형태로 변경하면 아래와 같습니다. 함수의 입력값, 계산 로직, 리턴값이 동일하기 때문에 함수의 이름을 동일하게 사용하였습니다. 둘 중의 하나를 선택하여 사용하면 됩니다. #비례식을 이용하여 부채꼴의 미지수를 구하는 함수, A:B = C:D fn_get_unknown_of_a_sector_using_proportions &lt;- function (A,B,C,D,unknown) { #A:B = C:D, A*D = B*C result &lt;- switch(unknown, &#39;A&#39; = B*C/D, #if(unknown == &#39;A&#39;) result &lt;- B*C/D &#39;B&#39; = A*D/C, #if(unknown == &#39;B&#39;) result &lt;- A*D/C &#39;C&#39; = A*D/B, #if(unknown == &#39;C&#39;) result &lt;- A*D/B &#39;D&#39; = B*C/A) #if(unknown == &#39;D&#39;) result &lt;- B*C/A return (result) } 한 원에서 중심각이 \\(120°\\)인 부채꼴의 호의 길이가 \\(6 \\: cm\\)이고 중심각이 \\(80°\\)인 부채꼴의 호의 길이가 \\(x \\: cm\\)라고 할 때, fn_get_unknown_of_a_sector_using_proportions()함수를 이용하여 아래와 같이 \\(x\\)의 값을 구할 수 있습니다. central_angle_sector_A &lt;- 120; arc_length_sector_A &lt;- 6 central_angle_sector_B &lt;- 80 #A:B = C:D; A*D = B*C; D = B*C/A #120:6 = 80:x; 120*x = 6*80; x = 6*80/120 x &lt;- fn_get_unknown_of_a_sector_using_proportions( A=central_angle_sector_A, B=arc_length_sector_A, C=central_angle_sector_B, unknown=&#39;D&#39;) print(paste0(&#39;중심각이 &#39;,central_angle_sector_B,&#39;°인 부채꼴의 호의 길이 = &#39;,x,&#39; cm&#39;)) ## [1] &quot;중심각이 80°인 부채꼴의 호의 길이 = 4 cm&quot; 위의 비례식을 이용한 미지수 계산 함수를 중심각과 넓이의 비례 관계에 적용해 볼 수도 있습니다. 한 원에서 중심각이 \\(120°\\)인 부채꼴의 넓이가 \\(y \\: cm^2\\)이고 중심각이 \\(80°\\)인 부채꼴의 넓이가 \\(6 \\: cm^2\\)라고 할 때, 아래와 같이 \\(y\\)의 값을 구할 수 있습니다. central_angle_sector_A &lt;- 120 central_angle_sector_B &lt;- 80; area_sector_B &lt;- 6 #A:B = C:D; A*D = B*C; B = A*D/C #120:y = 80:6; 120*6 = y*80; y = 120*6/80 y &lt;- fn_get_unknown_of_a_sector_using_proportions( A=central_angle_sector_A, C=central_angle_sector_B, D=area_sector_B, unknown=&#39;B&#39;) print(paste0(&#39;중심각이 &#39;,central_angle_sector_A,&#39;°인 부채꼴의 넓이 = &#39;,y,&#39; cm²&#39;)) ## [1] &quot;중심각이 120°인 부채꼴의 넓이 = 9 cm²&quot; 호의 길이가 \\(l\\)인 부채꼴의 넓이 \\(S\\)를 구하는 공식을 유도할 때에도 중심각과 넓이의 비례 관계, 중심각과 호의 비례 관계가 사용됩니다. 부채꼴의 중심각을 \\(x°\\)라 할때, \\(360° : \\small (원의 \\: 넓이) \\normalsize = x° : \\small (부채꼴의 \\: 넓이)\\)와 같은 비례 관계가 성립합니다 (\\(360 : \\pi {r}^2 = x : S\\)). 또한, \\(360° : \\small (원의 \\: 둘레) \\normalsize = x° : \\small (호의 \\: 길이)\\)의 비례 관계가 성립합니다 (\\(360 : 2 \\pi r = x : l\\)). 이 두 비례식을 아래와 같이 정리해 볼 수 있습니다. \\[S = \\pi {r}^2 \\times \\frac{x}{360}\\] \\[l = 2 \\pi r \\times \\frac{x}{360}\\] \\(S\\)식을 전개한 후에 \\(l\\)을 대입하면 아래와 같이 호의 길이와 반지름을 이용한 부채꼴의 넓이 구하는 식을 유도할 수 있습니다. \\[ S = \\pi {r}^2 \\times \\frac{x}{360} = r \\times \\pi r \\times \\frac{x}{360} = r \\times \\frac{1}{2} \\times (2 \\pi r \\times \\frac{x}{360}) = r \\times \\frac{1}{2} \\times l = \\frac{1}{2} r l\\] 지금까지 다각형, 원, 부채꼴과 같은 평면도형에 대해서 알아보았습니다. 이제 입체도형에 대하여 알아봅시다. 6.2 입체도형의 성질 다면체 (polyhedron), 각기둥 (prism), 각뿔 (pyramid), 회전체 (body of rotation), 원기둥 (cylinder), 원뿔 (cone), 구 (sphere)와 같은 입체도형 (solid figure)에 대하여 알아봅니다. 6.2.1 다면체와 회전체 다각형인 면으로만 둘러싸인 입체도형을 다면체라고 합니다. 다면체을 둘러싸고 있는 다각형을 다면체의 면 (face), 다각형의 변을 다면체의 모서리 (edge), 다각형의 꼭짓점을 다면체의 꼭짓점이라고 합니다. 원기둥 (cylinder), 원뿔 (cone) 등은 다각형이 아닌 면으로 둘러싸여 있기 때문에 다면체에 속하지 않습니다. 정육면체 (cube, regular hexahedron)를 예로 들면 \\(x\\)축과 \\(y\\)축을 가지는 좌표평면 상에 존재하는 정사각형을 높이 방향으로 (\\(z\\)축 방향으로) 한 변의 길이만큼 무수히 많이 연속적으로 쌓으면 정육면체가 됩니다. 정육면체는 서로 직교하는 3개의 축을 가지기 때문에 정육면체를 이루는 여덟 개의 꼭짓점 좌표는 (\\(x\\),\\(y\\),\\(z\\))와 같은 형태가 됩니다. 각 변의 길이가 \\(1\\)인 정육면체를 원점으로 부터 그리려면 밑면 사각형의 4개의 꼭짓점 (\\(0\\),\\(0\\),\\(0\\)), (\\(0\\),\\(1\\),\\(0\\)), (\\(1\\),\\(1\\)\\(0\\)), (\\(1\\),\\(0\\),\\(0\\))과 윗면 사각형의 4개의 꼭짓점 (\\(0\\),\\(0\\),\\(1\\)), (\\(0\\),\\(1\\),\\(1\\)), (\\(1\\),\\(1\\),\\(1\\)), (\\(1\\),\\(0\\),\\(1\\))이 필요합니다. 정육면체를 그리기 위하여 plotly 패키지를 이용하는 소스코드를 아래와 같이 생성하였습니다. plot_ly()함수는 여덟 개의 입력값을 가지며 각 입력값의 내용은 아래와 같습니다. type: 그래프의 형태, 삼차원 도형 x: 여덟 개 꼭짓점의 \\(x\\)좌표 벡터 y: 여덟 개 꼭짓점의 \\(y\\)좌표 벡터 z: 여덟 개 꼭짓점의 \\(z\\)좌표 벡터 plotly 패키지는 도형의 효율적인 입체 면 처리를 위하여 삼각형을 사용합니다. 따라서 정육면체의 면 처리에 12개의 삼각형이 필요합니다. 각 삼각형은 세 개의 꼭짓점을 가지며 정육면체 여덟 개의 꼭짓점에 0번 (첫 번째 꼭짓점) 부터 7번 (여덟 번째 꼭짓점)까지 번호를 매겨서 입력하게 됩니다. 아래 \\(i\\), \\(j\\), \\(k\\) 벡터의 첫 번째 값은 각각 \\(7\\), \\(3\\), \\(0\\)이며, 이를 이용하여 정육면체의 여덟 번째 꼭짓점 (\\(7\\)), 네 번째 꼭짓점 (\\(3\\)), 첫 번째 꼭짓점 (\\(0\\))이 이루는 첫 번째 삼각형이 생성됩니다. 이를 \\(12\\)번 반복하면 총 \\(12\\)개의 삼각형이 생성되며, 두 개의 삼각형이 하나의 사각형을 이루어 총 \\(6\\)개의 정사각형 면이 생성됩니다. i: 열두 개 삼각형 면의 첫 번째 꼭짓점 번호 벡터 j: 열두 개 삼각형 면의 두 번째 꼭짓점 번호 벡터 k: 열두 개 삼각형 면의 세 번째 꼭짓점 번호 벡터 facecolor: 열두 개 삼각형 면의 색상 벡터 이렇게 여덟 개의 입력값을 가지는 함수 plot_ly()를 이용하여 그림 6.10이 생성되었습니다. plotly 패키지로 그래프를 생성한 그래프는 동적인 그래프이기 때문에 마우스를 이용하여 확대, 축소, 회전 등이 가능하고 꼭짓점에 마우스를 가까이 가져가면 꼭짓점의 좌표 정보도 볼 수 있습니다. #install.packages(&quot;plotly&quot;) library(plotly) cube &lt;- plot_ly(type = &#39;mesh3d&#39;, x = c(0, 0, 1, 1, 0, 0, 1, 1), y = c(0, 1, 1, 0, 0, 1, 1, 0), z = c(0, 0, 0, 0, 1, 1, 1, 1), i = c(7, 0, 0, 0, 4, 4, 2, 6, 4, 0, 3, 7), j = c(3, 4, 1, 2, 5, 6, 5, 5, 0, 1, 2, 2), k = c(0, 7, 2, 3, 6, 7, 1, 2, 5, 5, 7, 6), facecolor = rep(toRGB(viridisLite::viridis(6)),each=2) ) cube 그림 6.10: 여섯 개의 정사각형을 면으로 가지는 정육면체 여섯 개의 삼각형을 면으로 하는 다른 모양의 육면체 (hexahedron)도 그려볼 수 있습니다. 다섯 개의 꼭짓점 (\\(1\\),\\(0\\),\\(0\\)), (\\(0\\),\\(1\\),\\(0\\)), (\\(0\\),\\(0\\),\\(1\\)), (\\(1\\),\\(1\\),\\(1\\)), (\\(-1/3\\),\\(-1/3\\),\\(-1/3\\))을 가지는 육면체를 생성해 보면 아래와 같습니다 (그림 6.11). hexahedron &lt;- plot_ly(type = &#39;mesh3d&#39;, x = c(1, 0, 0, 1,-1/3), y = c(0, 1, 0, 1,-1/3), z = c(0, 0, 1, 1,-1/3), i = c(0, 0, 1, 0, 0, 1), j = c(2, 3, 2, 2, 4, 2), k = c(3, 1, 3, 4, 1, 4), facecolor = toRGB(viridisLite::viridis(6)) ) hexahedron 그림 6.11: 여섯 개의 삼각형을 면으로 가지는 육면체 삼각형 밑면과 윗면을 가지는 오면체 (Pentahedron)인 삼각기둥 (triangular prism)을 생성하려면 밑면 꼭짓점 세 개, 윗면 꼭지점 세 개, 총 여섯 개의 꼭지점이 필요합니다. 아래의 소스코드로 오면체 삼각기둥을 생성해 볼 수 있습니다 (그림 6.12). colors &lt;- viridisLite::viridis(5) triangular_prism &lt;- plot_ly(type = &#39;mesh3d&#39;, x = c(0, 1, 0, 0, 1, 0), y = c(0, 0, 1, 0, 0, 1), z = c(0, 0, 0, 1, 1, 1), i = c(0, 3, 4, 0, 5, 1, 5, 0), j = c(1, 4, 1, 3, 2, 4, 2, 3), k = c(2, 5, 0, 4, 1, 5, 0, 5), facecolor = toRGB(c(colors[1],colors[2], rep(c(colors[3],colors[4],colors[5]),each=2))) ) triangular_prism 그림 6.12: 삼각형 밑면 (아랫면과 윗면)을 가지는 오면체 삼각기둥 네 개의 꼭짓점 (\\(1\\),\\(0\\),\\(0\\)), (\\(0\\),\\(1\\),\\(0\\)), (\\(0\\),\\(0\\),\\(1\\)), (\\(1\\),\\(1\\),\\(1\\))을 가지는 네 개의 삼각형을 면으로 하는 정사면체 (tetrahedron)를 생성해 보면 아래와 같습니다 (그림 6.13). 이 사면체는 삼각형을 밑면 (base plane)으로 가지지만 윗면은 존재하지 않고 꼭지점을 이루는 각뿔 모양이므로 삼각뿔 (triangular pyramid)이라고도 부릅니다. triangular_pyramid &lt;- plot_ly(type = &#39;mesh3d&#39;, x = c(1, 0, 0, 1), y = c(0, 1, 0, 1), z = c(0, 0, 1, 1), i = c(0, 0, 0, 1), j = c(1, 2, 3, 2), k = c(2, 3, 1, 3), #facecolor = toRGB(viridisLite::viridis(4)) facecolor = toRGB(viridisLite::inferno(4)) ) triangular_pyramid 그림 6.13: 네 개의 정삼각형을 면으로 가지는 정사면체 각뿔을 밑면에 평행한 평면으로 잘라서 생기는 두 입체 도형 중 각 뿔이 아닌 쪽을 각뿔대 (truncated pyramid, frustum of pyramid)라고 합니다. 각뿔대에서 평행한 두 면을 밑면이라 하고, 밑면이 아닌 면을 옆면이라고 합니다. 각뿔대의 옆면은 모두 사다리꼴이 되고, 각뿔대의 두 밑면에 수직인 선분의 길이를 각뿔대의 높이라고 합니다. 아래의 소스코드를 이용하여 사각뿔대를 그려볼 수 있습니다 (그림 6.14). 각뿔대는 밑면의 모양이 삼각형이면 삼각뿔대, 밑면이 사각형이면 사각뿔대, 밑면이 오각형이면 오각뿔대가 됩니다. truncated_quadrangular_pyramid &lt;- plot_ly(type = &#39;mesh3d&#39;, x = c(0, 0, 4, 4, 1, 1, 3, 3), y = c(0, 4, 4, 0, 1, 3, 3, 1), z = c(0, 0, 0, 0, 2, 2, 2, 2), i = c(0, 2, 4, 6, 0, 7, 1, 4, 2, 5, 3, 6), j = c(1, 3, 5, 7, 4, 3, 5, 0, 6, 1, 7, 2), k = c(2, 0, 6, 4, 7, 0, 4, 1, 5, 2, 6, 3), #facecolor = toRGB(viridisLite::viridis(4)) facecolor = rep(toRGB(viridisLite::plasma(6)),each=2) ) truncated_quadrangular_pyramid 그림 6.14: 육면체인 사각뿔대 다면체 중에서 아래의 두 조건을 모두 만족시키는 다면체를 정다면체 (regular polyhedron, platonic solid)라고 합니다. 각 면이 모두 합동인 정다각형이다. 각 꼭짓점에 모인 면의 개수가 모두 같다. 정다면체는 정사면체 (tetrahedron, 그림 6.13), 정육면체 (Hexahedron, 그림 6.10), 정팔면체 (Octahedron), 정십이면체 (Dodecahedron), 정이십면체 (Icosahedron)의 다섯 가지만 존재하는 것으로 알려져 있습니다 (표 6.2). 표에 사용된 다면체의 꼭지점 좌표 중 \\(\\phi\\)는 황금비율로 \\(\\phi\\)의 값은 \\(\\frac {1+ \\sqrt {5}} {2} \\approx 1.618\\)입니다. 표 6.2: 정다면체의 성질 정사면체 정팔면체 정이십면체 정육면체 정십이면체 면의 모양 정삼각형 정삼각형 정삼각형 정사각형 정오각형 면의 개수 4 8 20 6 12 한 꼭짓점에 모인면의 개수 3 4 5 3 3 꼭짓점개수 4 6(2 x 3) 12(4 x 3) 8 20(8 + 4 x 3) 꼭짓점좌표 (1,1,1) (1,−1,−1)(−1,1,−1)(−1,−1,1) (±1,0,0)(0,±1,0)(0,0,±1) (0,±1,±𝜙)(±1,±𝜙,0)(±𝜙,0,±1) (±1,±1,±1) (±1,±1,±1)(0,±1/𝜙,±𝜙)(±1/𝜙,±𝜙,0)(±𝜙,0,±1/𝜙) 그림 움직이는그림 * 표에 포함된 그림의 출처 https://en.wikipedia.org/wiki/Platonic_solid 한 직선을 축으로 하여 직사각형, 직각삼각형, 반원을 한 바퀴 회전시키면 원기둥, 원뿔, 구와 같은 입체도형을 얻을 수 있는데 이러한 입체도형을 회전체라고 하고 축으로 사용된 직선을 회전축 (axis of rotation)이라고 합니다 (그림 6.15). 아래의 소스코드를 이용하여 원기둥, 원뿔, 구를 그려볼 수 있습니다. 원뿔의 꼭짓점과 밑면을 이루는 원의 한 점을 이은 거리가 가장 짧은 선을 모선 (generating line)이라 하고, 이 선을 밑변을 이루는 원을 따라 움직이면 원뿔이 생성됩니다. 원기둥의 경우, 위의 밑변을 이루는 원의 한 점과 아래의 밑변을 이루는 원의 한 점을 이은 거리가 가장 짧은 선이 모선이 됩니다. 그림 6.15: 원기둥, 원뿔, 그리고 구 library(rgl) #cylinder3d() 함수를 사용하기 위한 패키지 로딩 #cylinder3d()함수를 이용한 원기둥 그리기 open3d() #삼차원 도형을 위한 창 열기 #높이축 z값이 증가함에 따라 원기둥의 반지름은 1로 일정함 cylinder3d(center = cbind(0,0,seq(0,by=0.3,len=11)),radius=1,closed=-2,sides=100) %&gt;% shade3d(col = &quot;pink&quot;) #decorate3d() #좌표축 보이기 #cylinder3d()함수를 이용한 원뿔 그리기 open3d() #삼차원 도형을 위한 창 열기 #높이축 z값이 증가함에 따라 원기둥의 반지름을 2부터 0까지 일정하게 줄임 cylinder3d(center = cbind(0,0,c(seq(0,by=0.03,len=101))),radius=c(seq(2,by=-0.02,len=101)), closed = -2, sides = 100) %&gt;% shade3d(col = &quot;pink&quot;) #cylinder3d()함수를 이용한 구 그리기 open3d() #삼차원 도형을 위한 창 열기 #반지름이 pi/2인 원, z^2 + r^2 = (pi/2)^2, r^2 = (pi/2)^2 - z^2, r = sqrt((pi/2)^2 - z^2) z &lt;- round(seq(-pi/2,by=pi/180,len=181),2) r &lt;- round(sqrt((pi/2)^2 - z^2),2) #원기둥의 반지름을 반원의 모양으로 변화시킴, 높이축 z값이 증가함에 따라 r값이 반원의 궤적을 따라 변화함 cylinder3d(center = cbind(0,0,z),radius=r, closed = -1, sides = 100) %&gt;% shade3d(col = &quot;pink&quot;) #spheres3d()함수 이용하여 구 그리기, 반지름은 pi/2 open3d() spheres3d(0,0,0,radius=pi/2,color=&#39;pink&#39;) #persp3d()함수 이용하여 좀 더 매끄러운 구 그리기, 반지름은 pi/2 open3d() sphere.f &lt;- function(x0 = 0, y0 = 0, z0 = 0, r = 1, n = 101, ...){ #상하 방향 s = -90°~90°, 좌우 방향 t = 0°~360°의 값을 이용하여 구의 3차원 좌표 x,y,z를 얻는 함수 f &lt;- function(s,t){ cbind( r * cos(t)*cos(s) + x0, r * sin(s) + y0, r * sin(t)*cos(s) + z0) } #f() 함수와 s값 범위 slim, t값 범위 tlim을 persp3d()함수의 입력값으로 넘김 persp3d(f, slim = c(-pi/2,pi/2), tlim = c(0, 2*pi), n = n, add = T, ...) } #반지름이 pi/2인 구를 그림 sphere.f(r=pi/2,col = &#39;pink&#39;) 원뿔의 윗부분을 밑면에 평행한 평면으로 자르면 두 개의 입체도형이 생기는 데 이 둘 중 원뿔이 아닌 입체도형을 원뿔대 (truncated cone)라고 합니다. 아래의 소스코드를 이용하면 그림 6.16과 같은 원뿔대를 그려볼 수 있습니다. open3d() #삼차원 도형을 위한 창 열기 #원뿔대 그리기, 원기둥의 반지름을 1.8부터 0.8까지 일정하게 줄임 cylinder3d(center = cbind(0,0,c(seq(0,by=0.3,len=6))),radius=c(seq(1.8,by=-0.2,len=6)), closed = -2, sides = 100) %&gt;% shade3d(col = &quot;pink&quot;) 그림 6.16: 원뿔대 모든 회전체에 대하여 아래의 두가지 조건이 성립합니다. 회전축에 수직인 평면으로 화전체를 자르면 그 단면의 경계는 항상 원이 된다. 회전축을 포함하는 평면으로 회전체를 자르면 그 단면은 모두 합동이고 회전축을 대칭으로 하는 선대칭도형 (symmetric figure for a line)이 된다. 6.2.2 기둥의 겉넓이와 부피 삼각기둥 (그림 6.12)은 오면체로 서로 합동인 \\(2\\)개의 삼각형 모양 밑면 (base plane)과 \\(3\\)개의 사각형 모양 옆면 (lateral face, side face)으로 이루어져 있으며, 옆면을 모두 펼치면 직사각형 모양이 됩니다. 따라서, 삼각기둥의 전개도 (development figure)는 두 개의 밑면과 하나의 펼쳐진 옆면으로 이루어집니다 (그림 6.17). 삼각기둥의 전개도는 아래의 소스코드로 그려볼 수 있습니다. 그림 6.17: 삼각기둥의 전개도 library(sf) colors &lt;- viridisLite::viridis(5) #밑면 그리기 triangle1 &lt;- st_polygon(list(cbind(c(0,sqrt(2),sqrt(2)/2,0), c(0,0,-sqrt(2)/2,0)))) plot(triangle1,col=colors[1],xlim=c(-1,sqrt(2)+1),ylim=c(-1,sqrt(2)+1)) triangle2 &lt;- st_polygon(list(cbind(c(0,sqrt(2),sqrt(2)/2,0), c(1,1,1+sqrt(2)/2,1)))) plot(triangle2,add=TRUE,col=colors[2]) #옆면 그리기 rectangle1 &lt;- st_polygon(list(cbind(c(0,0,-1,-1,0), c(0,1,1,0,0)))) plot(rectangle1,add=TRUE,col=colors[3]) rectangle2 &lt;- st_polygon(list(cbind(c(0,0,sqrt(2),sqrt(2),0), c(0,1,1,0,0)))) plot(rectangle2,add=TRUE,col=colors[4]) rectangle3 &lt;- st_polygon(list(cbind(c(sqrt(2),sqrt(2),sqrt(2)+1,sqrt(2)+1,sqrt(2)), c(0,1,1,0,0)))) plot(rectangle3,add=TRUE,col=colors[5]) 원기둥 (그림 6.15의 왼쪽 첫 번째)의 전개도도 두 개의 원 모양 밑면과 한 개의 펼쳐진 사각형 모양 옆면으로 이루어집니다 (그림 6.18). 원기둥의 전개도는 아래의 소스코드로 그려볼 수 있습니다. 그림 6.18: 원기둥의 전개도 library(sf) r &lt;- 1; h &lt;- 3 #밑면 그리기 circle_1 &lt;- st_buffer(st_point(c(0,-r)), r) plot(circle_1,col=&#39;pink&#39;,xlim=c(-pi-2,pi+2),ylim=c(-pi-2,pi+2)) circle_2 &lt;- st_buffer(st_point(c(0,h+r)), r) plot(circle_2,add=TRUE,col=&#39;pink&#39;) #옆면 그리기 rectangle1 &lt;- st_polygon(list(cbind(c(pi,pi,-pi,-pi,pi), c(0,h,h,0,0)))) plot(rectangle1,add=TRUE,col=&#39;pink&#39;) 위의 삼각기둥과 원기둥의 전개도로 부터 기둥의 겉넓이는 서로 합동인 두 밑면의 넓이와 옆넓이 (옆면 전체의 넓이)의 합인 것을 알 수 있습니다. \\[\\small (기둥의 \\: 겉넓이) \\normalsize = 2 \\times \\small (밑넓이) \\normalsize + \\small (옆넓이)\\] 반지름이 \\(r\\)이고 높이가 \\(h\\)인 원기둥의 경우, 옆면의 가로의 길이는 원모양 밑면의 원주 (원의 둘레, circumference)인 \\(2 \\pi r\\)과 같고 세로의 길이는 높이 \\(h\\)이므로 옆면의 넓이는 \\(2 \\pi r h\\)이고, 밑면의 넓이는 \\(\\pi {r}^{2}\\)입니다. 따라서 원기둥의 겉넓이 \\(S\\)를 구하는 공식은 아래와 같습니다. 원기둥의 밑면 반지름과 높이의 단위가 \\(cm\\)이면 원기둥 겉넓이의 단위는 \\({cm}^{2}\\)가 됩니다. \\[S = 2 \\times (\\pi {r}^{2}) + (2 \\pi r h) = 2 \\pi {r}^{2} + 2 \\pi r h\\] 기둥이 밑면의 모양을 높이 방향으로 계속 쌓아서 만들었다고 생각해보면, 기둥의 부피를 아래와 같이 짐작할 수 있습니다. \\[\\small (기둥의 \\: 부피) \\normalsize = \\small (밑넓이) \\normalsize \\times \\small (높이)\\] 반지름이 \\(r\\)이고 높이가 \\(h\\)인 원기둥의 경우, 밑면의 넓이가 \\(\\pi {r}^{2}\\)이므로 원기둥의 부피 \\(V\\)를 구하는 공식은 아래와 같습니다. 원기둥의 밑면 반지름과 높이의 단위가 \\(cm\\)이면 원기둥 부피의 단위는 \\({cm}^{3}\\)가 됩니다. \\[V = (\\pi {r}^{2}) \\times h = \\pi {r}^{2} h\\] 6.2.3 뿔의 겉넓이와 부피 사각뿔의 전개도를 그려보면 사각뿔은 사각형 모양의 밑면 \\(1\\)개와 삼각형 모양의 옆면 \\(4\\)개로 이루어져 있습니다 (그림 6.19). 그림 6.19: 사각뿔과 사각뿔의 전개도 library(plotly) colors &lt;- viridisLite::plasma(5) quadrangular_pyramid &lt;- plot_ly(type = &#39;mesh3d&#39;, x = c(0, 0, 4, 4, 2), y = c(0, 4, 4, 0, 2), z = c(0, 0, 0, 0, 4), i = c(0, 3, 0, 0, 1, 2), j = c(3, 2, 3, 1, 2, 3), k = c(1, 1, 4, 4, 4, 4), facecolor = toRGB(c(rep(colors[1],2),colors[2],colors[3],colors[4],colors[5])) ) quadrangular_pyramid library(sf) colors &lt;- viridisLite::plasma(5) #밑면 그리기 rectangle1 &lt;- st_polygon(list(cbind(c(0,4,4,0,0),c(0,0,4,4,0)))) plot(rectangle1,col=colors[1],xlim=c(-4,8),ylim=c(-4,8)) #옆면 그리기 triangle1 &lt;- st_polygon(list(cbind(c(0,-4,0,0),c(0,2,4,0)))) plot(triangle1,add=TRUE,col=colors[2]) triangle2 &lt;- st_polygon(list(cbind(c(0,4,2,0),c(4,4,8,4)))) plot(triangle2,add=TRUE,col=colors[3]) triangle3 &lt;- st_polygon(list(cbind(c(4,4,8,4),c(0,4,2,0)))) plot(triangle3,add=TRUE,col=colors[4]) triangle4 &lt;- st_polygon(list(cbind(c(0,2,4,0),c(0,-4,0,0)))) plot(triangle4,add=TRUE,col=colors[5]) 뿔의 겉넓이는 밑넓이와 옆넓이 (옆면 전체의 넓이)의 합으로 아래의 공식이 성립합니다. \\[\\small (뿔의 \\: 겉넓이) \\normalsize = \\small (밑넓이) \\normalsize + \\small (옆넓이)\\] 사각뿔의 겉넓이를 구할때 사각뿔의 옆넓이는 옆면 전체의 넓이이므로 \\(4\\)개의 삼각형 모양 옆면의 넓이를 합한 넓이가 됩니다. 원뿔의 경우, 전개도를 그려보면 밑면은 원, 옆면은 부채꼴로 이루어져 있습니다. 따라서, 밑면의 반지름의 길이가 \\(r\\), 모선의 길이가 \\(l\\)인 원뿔의 밑넓이는 \\(\\pi {r}^2\\)이고 옆넓이는 \\(\\frac{1}{2} \\times 2 \\pi r \\times l = \\pi r l\\)이므로 원뿔의 겉넓이 \\(S\\)를 구하는 공식은 아래와 같습니다. \\[S = \\pi {r}^2 + \\pi rl\\] 뿔의 부피는 밑면이 합동이고 높이가 같은 기둥 부피의 \\(\\frac {1}{3}\\)이라고 알려져 있고, 공식으로 나타내면 아래와 같습니다. \\[\\small (뿔의 \\: 부피) \\normalsize = \\frac{1}{3} \\times \\small (밑넓이) \\normalsize \\times \\small (높이)\\] 밑면의 반지름이 \\(r\\)이고 높이가 \\(h\\)인 원뿔 (그림 6.15의 가운데)의 밑넓이는 \\(\\pi {r}^{2}\\)이므로 원뿔의 부피 \\(V\\)를 구하는 공식은 아래와 같습니다. \\[V = \\frac{1}{3} \\pi {r}^{2} h\\] 6.2.4 구의 겉넓이와 부피 구 (그림 6.15의 오른쪽 첫번째)의 겉넓이는 반지름의 길이가 같은 원 넓이의 \\(4\\)배라고 알려져 있습니다. 따라서, 반지름이 \\(r\\)인 구의 겉넓이 \\(S\\)를 구하는 공식은 아래와 같습니다. \\[S = 4 \\times \\pi {r}^{2} = 4 \\pi {r}^{2}\\] 구의 중심점을 꼭짓점으로 하는 한없이 많은 각뿔 모양으로 나누어 생각하면, 구의 부피는 모든 각뿔의 부피의 합과 같으며, 구의 겉넓이 또한 모든 각뿔의 밑넓이의 합과 같습니다 (그림 6.20). 아래의 소스코드를 이용하여 구를 한없이 많은 각뿔 모양으로 나누었을 때의 그림을 그려볼 수 있습니다. 코드 한 줄 한 줄을 이해하려 하기 보다는 흐름만 이해하고 복붙하세요. 그림 6.20: 구를 한없이 많은 각뿔 모양으로 분해 open3d() #삼차원 도형을 위한 창 열기 #구를 그리는 함수에 구를 한없이 많은 각뿔 모양으로 나누었을 때, 각뿔들의 밑면 그리는 옵션 추가 sphere.f &lt;- function(x0=0,y0=0,z0=0,r=1,n=101,n_line=101, srange=c(-pi/2,pi/2),trange=c(0, 2*pi),with_line=FALSE, ...){ #상하 방향 s = -90°~90°, 좌우 방향 t = 0°~360°의 값을 이용하여 구의 3차원 좌표 x,y,z를 얻는 함수 f &lt;- function(s,t){ cbind( r * cos(t)*cos(s) + x0, r * sin(s) + y0, r * sin(t)*cos(s) + z0) } #위의 f() 함수와 s값 범위 slim, t값 범위 tlim을 이용하여 구를 그림 persp3d(f, slim = srange, tlim = trange, n = n, add = T, ...) # 구를 수많은 사각형으로 나눔 if (with_line) persp3d(f, slim=srange,tlim=trange,n=n_line,col=&#39;dimgray&#39;, front = &quot;lines&quot;, back = &quot;lines&quot;, lit = FALSE, add = T) } #구를 한없이 많은 각뿔 모양으로 나누었을 때, 각뿔들의 밑면 sphere.f(r=pi/2,col=&#39;pink&#39;,with_line=TRUE) open3d() #삼차원 도형을 위한 창 열기 #구를 한없이 많은 각뿔 모양으로 나누었을 때, 한 각뿔의 밑면 그리기 sphere.f(r=pi/2,col=&#39;pink&#39;,srange = c(0,pi/18), trange = c(pi/18,pi/9)) #각뿔의 4개 모서리 그리기 s &lt;- seq(0,pi/18,length.out=2) t &lt;- seq(pi/18,pi/9,length.out=2) for (i in s) { for (j in t) { x &lt;- r * cos(j)*cos(i) y &lt;- r * sin(i) z &lt;- r * sin(j)*cos(i) lines3d(x=c(0,x),y=c(0,y),z=c(0,z), col = &quot;gray&quot;) } } 구의 반지름의 길이는 각 각뿔의 높이이고, 구의 부피는 모든 각뿔의 부피의 합이므로, 아래의 공식으로 구의 부피를 구할 수 있습니다. \\[\\small (구의 \\: 부피) \\normalsize = \\small (모든 \\: 각뿔의 \\: 부피의 \\: 합) \\normalsize = \\frac{1}{3} \\times \\small (모든 \\: 각뿔의 \\: 밑넓이의 \\: 합) \\normalsize \\times \\small (각뿔의 \\: 높이)\\] \\[\\qquad \\qquad \\qquad \\qquad \\qquad \\qquad = \\frac{1}{3} \\times \\small (구의 \\: 겉넓이) \\normalsize \\times \\small (구의 \\: 반지름의 \\: 길이) \\] 구의 반지름의 길이를 \\(r\\)이라고 하면 구의 겉넓이는 \\(4 \\pi {r}^{2}\\)이므로 구의 부피 \\(V\\)를 구하는 공식은 아래와 같습니다. \\[V = \\frac{1}{3} \\times 4 \\pi {r}^{2} \\times r = \\frac{4}{3} \\pi {r}^{3}\\] 6.2.5 그리고, 공간 입체도형에 대해서 살펴본 김에, 우리가 일상 생활에서 매일 경험하는 더 큰 공간인 우리가 사는 땅 (한반도)에 대한 삼차원 시각화에 도전해 봅시다. rayshader 패키지를 이용하면 2.1절의 그림 2.4 한반도 주변의 높이 정보 생성에 사용된 데이터를 삼차원으로 시각화할 수 있습니다. 데이터는 높이 정보를 가지고 있지만 보통 디지털 이미지와 동일한 구조를 가집니다. 하나의 디지털 이미지는 픽셀 (pixel; picture element) 또는 화소 (畵素)라고 부르는 작은 점들로 이루어 집니다. 하나의 이미지가 가지는 픽셀의 개수가 많을 수록 이미지의 파일 용량 (file size)은 커지게 됩니다. 이미지 파일이나 데이터 파일의 용량이 클수록 컴퓨터에서 처리하는 속도는 느려지게 됩니다. 아래의 소스코드에서는 기존의 소스코드에서 저장해 놓았던 데이터 파일을 읽어온 후 해상도 (resolution)를 조금 낮추어 사용하였으며, 여섯 단계로 나누어져 있습니다. 첫 번째 단계에서는 패키지를 로딩하고, 두 번째와 세 번째 단계에서 기존 데이터 파일의 해상도를 낮춥니다. 네 번째 단계에서 데이터 프레임을 생성하고 다섯번째 단계에서 ggplot() 그래프를 생성한 후에, 여섯 번째 단계에서 삼차원 시각화합니다. ## 1. 처음 사용하는 패키지를 설치하고 필요한 패키지들을 로딩합니다. #remotes::install_github(&quot;tylermorganwall/rayshader&quot;) library(rayshader) library(raster) library(scales) ## 2. 그림 2.5 생성 시 저장해둔 한반도 높이 데이터를 읽어오고 픽셀 개수와 해상도를 확인합니다. elevation &lt;- raster(&quot;korea_elevation.grd&quot;) #한반도 높이 자료 읽어오기 dim(elevation) #픽셀 차원 (dimension) 확인, rows(1114) x columns(987) x layers(1) res(elevation) #픽셀 해상도 (resolution) 확인, x축 해상도 (경도 0.01°), y축 해상도 (위도 0.01°) ## 3. raster 파일 해상도를 낮추어 파일 사이즈를 줄이고 난 후, 픽셀 개수와 해상도를 확인합니다. #raster 파일 해상도를 낮추어 파일 사이즈를 줄임 newraster &lt;- raster(extent(elevation), crs = crs(elevation), resolution = c(0.01,0.01)) newraster &lt;- resample(elevation,newraster,method=&#39;ngb&#39;) dim(newraster) res(newraster) #저해상도 raster를 ascii 파일로 저장 writeRaster(newraster, filename=&quot;korea_elevation2.grd&quot;, format=&quot;raster&quot;,overwrite=TRUE) ## 4. 저해상도 raster 파일을 이용하여 x, y, z 컬럼을 가지는 데이터 프레임을 생성합니다. elevation &lt;- raster(&quot;korea_elevation2.grd&quot;) e_df &lt;- as.data.frame(elevation,xy = TRUE) colnames(e_df)[3] =&#39;z&#39; str(e_df) ## 5. ggplot()을 이용하여 그림 2.5와 유사한 색상을 가지는 그래프를 생성합니다. #그림 2.5와 동일하도록 색상 단계 구분 my.at &lt;- c(seq(-3800, -100, 100), seq(-80, 80, 10), seq(100, 2700, 70)) # 그래프 생성 plot &lt;- ggplot(e_df, aes(x, y)) + geom_raster(aes(fill=z)) + scale_fill_distiller(palette = &quot;RdBu&quot;, direction = -1, values=rescale(my.at)) + coord_quickmap() ## 6. ggplot()으로 생성된 그래프를 rayshader 패키지의 plot_gg()으로 삼차원 시각화 합니다. #삼차원 그래프 생성, 높이를 250배 과장해서 표현함으로써 삼차원 효과를 극대화 함 plot_gg(plot,multicore=TRUE,width=5,height=5,scale=250, #높이의 250배로 과장 (과고감) windowsize=c(1400,866),zoom=0.55,theta=-30,phi=30) #화면크기, 확대, 카메라 각도 위의 소스코드를 단계 별로 실행하면 그림 6.21와 같은 결과를 얻을 수 있습니다. 마우스를 이용하여 삼차원 영상을 확대하거나 회전해 보면서 제주도의 한라산, 울릉도, 독도, 울릉도 윗부분 깊은 바다 그리고 그림의 제일 윗부분에 위치한 백두산을 찾아보세요. 그림 6.21: 한반도 주변의 높이 (고도) 정보를 이용한 삼차원 시각화 위의 정육면체와 정사면체를 생성하는 데 사용한 plotly 패키지로도 한반도 주변의 높이 정보를 이용한 삼차원 시각화가 가능합니다. 아래의 소스코드를 실행하여 생성되는 삼차원 그래프를 확인하세요. 코드의 세부적인 부분을 이해하려고 하기보다는 ‘이런 방법도 있구나’ 하는 느낌으로 실행해보세요. plot_gg()와는 달리, plot_ly()를 이용하면 그려낸 그래프 자체를 확대, 축소해 볼 수 있다는 장점이 있습니다. library(reshape2) library(RColorBrewer) library(plotly) mat &lt;- acast(e_df, y~x, value.var=&quot;z&quot;) nrow(mat) y &lt;- round(as.numeric(rownames(mat)),2) rownames(mat) &lt;- y ncol(mat) x &lt;- round(as.numeric(colnames(mat)),2) colnames(mat) &lt;- x colfunc&lt;-colorRampPalette(rev(brewer.pal(9, &quot;RdBu&quot;))) colfunc(93) plot &lt;- plot_ly(type = &quot;surface&quot;, x=x, y=y, z = mat, colorscale = list(rescale(my.at), colfunc(93)), contours = list(z = list(show=TRUE,usecolormap=TRUE,project=list(z=TRUE))) ) plot &lt;- plot %&gt;% layout(scene = list(camera=list( eye = list(x=-0.5, y=-1.5, z=1.5)))) plot 한반도에서 좀 더 공간을 확장하여 극동 아시아로 가볼까요? 지구는 평면이 아니라 구의 형태이기 때문에 넓은 공간을 이차원 평면에 표현하면 원래 모양대로 표현하기가 어려워 집니다. 컴퓨터가 없던 시절에는 삼차원 지구를 이차원 평면인 종이 위에 지도 형태로 주로 표현했기 때문에 이를 위한 다양한 방법 (투영법, projection)들이 개발되어 왔습니다. 하지만, 컴퓨터의 발전으로 삼차원 지구를 컴퓨터, 핸드폰, 가상현실 (virtual reality), 홀로그램(hologram) 등을 이용하여 구의 형태 그대로 시각화할 수 있습니다. 아래 소스코드를 이용하면 한반도와 주변 국가 (중국, 일본)들을 구의 형태로 시각화해 볼 수 있습니다. ## 1. 처음 사용하는 패키지를 설치하고 필요한 패키지들을 로딩합니다. #devtools::install_github(&quot;hypertidy/anglr&quot;) library(anglr) library(stringr) library(maptools) library(scales) library(plotly) data(wrld_simpl) ## 2. 시각화할 공간 다각형 데이터 프레임 (map1)을 가져옵니다. #아래 세 개의 지도 중 하나 선택하여 시각화, 나머지 두 개의 지도는 반드시 주석처리하여 실행되지 않도록 함 #map1 &lt;- wrld_simpl #세계 지도 map1 &lt;- subset(wrld_simpl, str_detect(NAME, &quot;Korea|China|Japan&quot;)) #극동아시아 지도 #map1 &lt;- subset(wrld_simpl, str_detect(NAME, &quot;Korea&quot;)) #한반도 지도 ## 3. 지구본 모양의 시각화를 위해 삼차원 삼각형 면 (mesh)을 생성합니다. #지구 중심을 원점으로 하는 삼차원 좌표계를 이용한 삼각형 면 정보 생성 delmesh &lt;- anglr::globe(anglr::DEL(map1, max_area = 0.5)) #삼차원좌표계에 삼각형 면 생성 mesh &lt;- as.mesh3d(delmesh) #TRI 객체를 mesh3d 객체로 변환 ## 4. mesh의 꼭짓점과 삼각형 면을 이용하여 plot_ly() 입력값을 생성합니다. #삼차원 삼각형 꼭짓점 (mesh$vb)을 이용하여 x, y, z 좌표 벡터를 생성 x &lt;- mesh$vb[1,] y &lt;- mesh$vb[2,] z &lt;- mesh$vb[3,] #삼차원 삼각형 면 (mesh$it)을 이용하여 i, j, k 면 벡터 생성 i &lt;- mesh$it[1,]-1 #시작이 0부터 이므로 1을 빼줌 j &lt;- mesh$it[2,]-1 #시작이 0부터 이므로 1을 빼줌 k &lt;- mesh$it[3,]-1 #시작이 0부터 이므로 1을 빼줌 #각 삼각형의 면 (mesh$it)의 위치정보를 이용한 색상 설정 facecolor (무지개색, 아래부분 빨간색, 윗부분 보라색) zmean &lt;- apply(t(mesh$it),MARGIN=1,function(i){mean(z[i])}) facecolor = colour_ramp(rainbow(9))(rescale(x=zmean)) ## 5. 정육면체, 정사면체 그래프와 마찬가지로 꼭짓점 정보 (x,y,z)와 면 정보 (i,j,k)로 삼차원 시각화 globe &lt;- plot_ly( type = &quot;mesh3d&quot;, x = x, y = y, z = z, i = mesh$it[1,]-1, j = mesh$it[2,]-1, k = mesh$it[3,]-1, facecolor = facecolor ) globe #삼차원 시각화 확인 위의 소스코드 ## 2. 시각화할 공간 다각형 데이터 프레임 (map1)을 가져오는 부분에서는 극동아시아 데이터를 사용했지만 아래와 같이 map1 부분을 #극동아시아 지도라인에서 #세계 지도 라인으로 변경하면 그림 6.22과 같이 지구본 형태의 세계 지도도 생성할 수 있습니다. map1 &lt;- wrld_simpl #세계 지도 #map1 &lt;- subset(wrld_simpl, str_detect(NAME, &quot;Korea|China|Japan&quot;)) #극동아시아 지도 #map1 &lt;- subset(wrld_simpl, str_detect(NAME, &quot;Korea&quot;)) #한반도 지도 그림 6.22: 지구 삼차원 시각화 이번 장에서는 다각형, 원, 부채꼴 등과 같은 평면도형과 다면체, 기둥, 뿔, 구 등과 같은 입체도형의 성질에 대해서 살펴보았습니다. 또한, 우리가 사는 한반도, 지구의 삼차원 시각화에 대해서도 다루었습니다. 이제 7장 통계에 대하여 본격적으로 알아봅시다. "],
["statistics.html", "7 통계 7.1 대푯값과 그림 상자 7.2 줄기와 잎 그림과 도수분포표 7.3 히스토그램과 도수분포다각형 7.4 상대도수 7.5 데이터 분석 심화 - 머신 러닝", " 7 통계 어떤 현상을 파악하거나 중요한 결정을 할 때에는 근거가 되는 자료가 필요합니다. 경제, 사회, 의학, 과학 등 다양한 분야에서 자료가 수집, 정리, 해석되어 여러 현상을 파악하고 중요한 의사 결정의 근거로 사용되고 있습니다. 자료의 수집 방법, 정리 방법, 해석 방법에 대하여 알아봅니다. RStudio가 열려 있지 않으면 RStudio를 실행하고 메뉴에서 File &gt;&gt; Open Project…를 클릭하여 이전에 저장한 R 프로젝트 파일인 rmath01.Rproj을 찾아서 선택하고 Open 버튼을 클릭하여 이전에 작업하던 프로젝트 환경을 로딩합니다. 파일탐색기나 파인더에서 rmath01.Rproj 파일을 찾아서 더블 클릭하여도 RStudio가 실행되면서 작업하던 프로젝트 환경이 로딩됩니다. 프로젝트 환경이 로딩된 후에 RStudio 콘솔창에 getwd()를 실행하여 작업 환경이 제대로 로딩되었는지 확인합니다. RStudio 환경이 잘 로딩되었으면, 이제 본격적으로 시작해 봅시다. 7.1 대푯값과 그림 상자 최근 미세먼지가 가장 심했던 \\(2019\\)년 \\(3\\)월의 일별 미세먼지 \\(PM_{10}\\) 농도 자료 (데이터)를 이용하여 평균 (mean), 중앙값 (median) 등의 대푯값 (representative value)들을 확인하고 데이터의 분포를 상자 그림 (박스 플롯, box plot)으로 그려봅시다. 변수 (variable)가 숫자를 값으로 취하는 반면, 변량 (variate)은 일별 미세먼지 농도와 같이 양을 값으로 취합니다. 따라서, 일별 미세먼지 농도 값을 변량이라고 하고 \\(2019\\)년 \\(3\\)월의 데이터는 \\(31\\)개의 변량을 가집니다. \\(PM_{10}\\) (particulate matter \\(10 micrometers\\))은 지름이 \\(10 \\mu m\\) 이하인 미세먼지를, \\(PM_{2.5}\\) (particulate matter \\(2.5 micrometers\\))는 지름이 \\(2.5 \\mu m\\) 이하인 초미세먼지를 말합니다. \\(1 \\mu m\\)는 \\(1 \\times {10}^{-6}m\\)의 크기이기 때문에, \\(10 \\mu m = \\frac{10}{1000000} m = 0.00001 m = 0.001cm = 0.01mm\\)이고 \\(2.5 \\mu m = 0.0025 mm\\)입니다. \\[1 km = 1 \\times {10}^{3}m = 1 \\times 1000 m\\] \\[1 cm = 1 \\times {10}^{-2}m = \\frac{1}{100} m\\] \\[1 mm = 1 \\times {10}^{-3}m = \\frac{1}{1000} m\\] \\[1 \\mu m = 1 \\times {10}^{-6}m = \\frac{1}{1000000} m = \\frac{1}{1000} mm\\] 이제, \\(2019\\)년 \\(3\\)월 시도별 미세먼지 농도 엑셀 파일을 다운로드해 봅시다. https://www.airkorea.or.kr &gt;&gt; 실시간 자료조회 &gt;&gt; 시도별 대기정보 &gt;&gt; 시도별 대기정보(\\(PM_{10}\\)) &gt;&gt; 월별 \\(2019\\)년 \\(3\\)월 &gt;&gt; 검색 클릭 &gt;&gt; 엑셀 클릭의 순서로 엑셀 파일을 다운로드할 수 있습니다. 엑셀 파일을 다운로드한 후, 파일명을 sidoAirInfo.xls에서 pm10.xls로 변경하여 사용합니다. https://www.airkorea.or.kr에서 \\(2019\\)년 \\(3\\)월의 미세먼지 현황 데이터를 검색할 수 없다면 https://rebrand.ly/201903pm10xls에서 다운로드한 후, 파일명을 pm10.xls로 변경하여 사용하세요. 다운로드한 엑셀 파일을 현재 작업 디렉토리로 이동합니다. 탐색기나 파인더에서 작업 디렉토리에 있는 rmath01.Rproj 파일을 더블클릭하여 RStudio를 실행합니다. RStudio의 콘솔창에서 getwd()를 실행하여 현재 작업 디렉토리를 확인하고, pm10.xls파일을 현재 작업 디렉토리로 옮깁니다. 엑셀 파일을 읽어서 티블 (tibble) 데이터 객체를 생성합니다. 티블은 tidyverse패키지가 제공하는 데이터 객체 형태로 데이터 프레임과 유사하지만 좀 더 편리한 기능을 추가한 형태로 생각하면 됩니다. 티블을 데이터 프레임 처럼 사용하여도 무방하고, 티블을 데이터 프레임의 형태로 변환하여 사용하여도 됩니다. #엑셀파일을 읽어오기 위하여 아래 둘 중 하나의 패키지를 로딩합니다. library(tidyverse) library(readxl) #엑셀 파일을 읽어서 티블 생성 #엑셀의 4번째행부터 35번째행까지 데이터가 존재 #4번째행은 컬럼명, 5번째행부터 35번째까지 31개행의 데이터가 존재함 pm10_tbl &lt;- read_excel(&#39;pm10.xls&#39;, sheet = 1, range = cell_rows(4:35)) pm10_tbl 각 컬럼 벡터는 미세먼지 \\(PM_{10}\\) 농도 변량을 벡터값으로 가지므로, 변량의 통계를 얻기 위해서는 컬럼의 데이터 형태가 숫자이어야만 합니다. 엑셀 파일로 부터 생성한 티블의 컬럼들이 모두 문자값을 가지는 것을 확인한 후, 각 시도 별 미세먼지 값을 가지는 컬럼들을 문자값에서 숫자값을 가지도록 변경합니다. str(pm10_tbl) #티블의 컬럼 구조 확인 #숫자값을 가진 컬럼을 숫자컬럼으로 변경 pm10_tbl &lt;- pm10_tbl %&gt;% mutate_all(type.convert) %&gt;% mutate_if(is.numeric, as.numeric) str(pm10_tbl) #티블의 컬럼 구조 다시 확인 colnames(pm10_tbl) #티블의 컬럼명 확인 티블 pm10_tbl의 경우 엑셀에서 \\(31\\)행의 데이터를 불러 들였기 때문에 NA (not assigned) 값을 가진 행이 존재하지 않습니다. 하지만, 월 데이터가 \\(31\\)행보다 적은데 \\(31\\)행의 데이터를 불러들인 경우에는 NA값을 가지는 행들이 존재하게 됩니다. 이런 경우 아래의 소스코드를 이용하여 NA값을 가진 행을 제거할 수 있습니다. 물론, read_excel()을 이용하여 엑셀을 불러들일 때, range 입력값을 정확히 하여 처음부터 불필요한 행이 없도록 티블 (데이터 프레임)을 생성하는 것이 가장 좋습니다. dim(pm10_tbl) #티블의 행과 열의 개수 확인 tail(pm10_tbl) #티블의 마지막 6행 값을 확인 pm10_tbl &lt;- na.omit(pm10_tbl) #NA값을 가지는 행을 제거 dim(pm10_tbl) #티블의 행과 열의 개수 다시 확인 tail(pm10_tbl) #티블의 마지막 6행 값을 다시 확인 티블에 저장된 시도별 일 데이터의 평균, 중앙값, 최소값 (min), 최대값 (max) 등의 대푯값들을 확인하고 상자 그림 (박스 플롯, box plot)을 그려봅시다. 중앙값은 전체 변량을 작은 수에서 큰 수로 정렬했을 때 가운데에 위치하는 값입니다. \\(1\\),\\(2\\),\\(3\\),\\(4\\),\\(5\\)의 평균과 중앙값은 둘 다 \\(3\\)으로 평균과 중앙값의 차이가 느껴지지 않지만, \\(1\\),\\(2\\),\\(3\\),\\(4\\),\\(500\\)의 경우에는 평균은 \\(102\\)이고 중앙값은 여전히 \\(3\\)입니다. 평균과 중앙값의 차이가 크다는 것은 변량의 분포가 한 쪽에 치우쳐 있거나 다른 변량과 차이가 큰 변량이 존재한다는 것을 의미합니다. \\(1\\),\\(2\\),\\(3\\),\\(4\\)와 같이 변량의 개수가 짝수인 경우에는 가운데 두 값 (\\(2\\),\\(3\\))의 가운데 값인 \\(2.5\\)가 중앙값이 됩니다. 상자 그림은 상자 수염 그림 (box-and-whisker plot)이라고도 합니다. 박스의 내부에 있는 짙은 가로줄 (➖)은 각 시도의 중앙값 (중위수, \\(\\frac{1}{2}\\)분위수)을, 박스의 상단은 \\(\\frac{3}{4}\\)분위수, 박스의 하단은 \\(\\frac{1}{4}\\)분위수를 나타내며, 박스는 중앙값을 기준으로 \\(\\frac{1}{4}\\)분위수로 부터 \\(\\frac{3}{4}\\)분위수 까지의 데이터 범위를 보여줍니다. 박스 위와 아래에 있는 세로줄 (|)은 수염 (whisker) 부분으로 각각 최대값 (최대값 예상치)과 최소값 (최소값 예상치)까지의 범위를 나타냅니다. 상단 수염과 하단 수염의 바깥 부분에 존재 하는 원모양 (○)은 데이터의 예상 범위를 많이 벗어난 아주 작은 값이나 아주 큰 값을 나타낸 것으로 이상치(극단치, 이상점, outlier)라고 부릅니다. 대부분의 시도들에서 상자가 중앙값 윗부분이 아랫부분보다 더 길고, 상단 수염이 하단 수염보다 더 길게 뻗어있고 상단 수염 위에 이상치 (극단치)도 가지고 있을 뿐 아니라 실외 할동을 자제할 것을 권고하는 기준인 미세먼지 농도 \\(81 \\mu g/{m}^3\\)이상인 날들도 많았음을 알 수 있습니다 (그림 7.1). colnames(pm10_tbl) color &lt;- colorspace::rainbow_hcl(17) #색상 벡터 생성 ### 한글 폰트 로딩 시작 ####################################### #4.1절 순서쌍과 좌표를 참고하여 피보나치 사각형 그래프에서 사용한 한글 폰트를 확인하고 아래 myfont 부분을 환경에 맞게 변경 myfont &lt;- &quot;AppleMyungjo&quot; #여러분의 컴퓨터 환경에 맞도록 변경하세요! par(family=myfont) #한글 폰트 로딩 ### 한글 폰트 로딩 종료 ####################################### summary(pm10_tbl[,-c(1)]) #시도 별 평균, 최소값, 최대값, 중앙값 (중위수, 1/2분위수), 1/4분위수, 3/4분위수 확인 boxplot(pm10_tbl[,-c(1)],col=color) #날짜 컬럼을 제외한 모든 컬럼의 박스 플롯 그리기 그림 7.1: \\(18\\)개 시도 별 미세먼지 농도 (2019년 3월) 데이터의 박스 플롯 한국 기준에 따르면 미세먼지 \\(PM_{10}\\) 농도가 \\(81 \\mu g/{m}^3\\)이상이면 나쁨, \\(151 \\mu g/{m}^3\\)이상이면 매우 나쁨으로 구분되고, 세계보건기구 (World Health Organization, WHO)의 기준에 따르면 \\(51 \\mu g/{m}^3\\)이상이면 나쁨, \\(76 \\mu g/{m}^3\\)이상이면 상당히 나쁨, \\(101 \\mu g/{m}^3\\)이상이면 매우 나쁨, \\(151 \\mu g/{m}^3\\)이상이면 최악으로 구분됩니다. 이제 여러분이 살고 있는 시도의 데이터에 집중해 봅시다. 아래 코드의 colnames(pm10_df)를 이용하여 여러분이 살고 있는 시도의 컬럼이 몇 번째인지를 확인하고 해당 시도의 자료를 선택하고 박스 플롯을 그려보고 대표값들을 화면에 출력합니다. 아래의 소스코드에서는 경기도 컬럼을 선택하였습니다. pm10_df &lt;- data.frame(pm10_tbl) #티블을 데이터 프레임으로 변환 colnames(pm10_df) #컬럼 이름들을 확인한 후에 날짜 컬럼과 여러분이 살고 있는 시도 컬럼만 선택합니다. pm10_df2 &lt;- pm10_df[,c(1,9)] #날짜와 경기도 컬럼만 선택 colnames(pm10_df2) &lt;- c(&#39;date&#39;,&#39;pm10&#39;) str(pm10_df2) #날짜가 Factor로 되어있는 걸 확인 pm10_df2 &lt;- pm10_df2 %&gt;% mutate_if(is.factor, as.character) #Factor로 인코딩되어있는 컬럼을 문자형으로 변경 dim(pm10_df2) head(pm10_df2) pm10_df2$pm10 boxplot(pm10_df2$pm10,col=&#39;skyblue&#39;) summary(pm10_df2$pm10 ggplot()으로도 박스 플롯을 그려볼 수도 있습니다. 필요에 따라 박스 플롯과 각 변량을 동시에 그려볼 수 도 있습니다. library(ggplot2) ggplot(pm10_df2,aes(&quot;Gyeonggi&quot;,pm10)) + geom_boxplot(fill=&#39;skyblue&#39;) ggplot(pm10_df2,aes(&quot;Gyeonggi&quot;,pm10)) + geom_boxplot(fill=&#39;skyblue&#39;,outlier.size = 3) + #극단치는 검은색 큰 원 geom_jitter(width = 0.2, col=&#39;darkgray&#39;,alpha=0.8) #각 변량은 회색 원 대표값들 중 평균과 중앙값의 차이가 크다는 것은 크게 치우친 값이 포함되어 있다는 뜻이고, 값의 치우침은 박스 플롯으로도 확인할 수 있습니다. 경기도의 경우, \\(2019\\)년 \\(3\\)월의 미세먼지 \\(PM_{10}\\) 농도가 \\(150 \\mu g/{m}^3\\)을 훨씬 초과하는 변량도 \\(2\\)개나 포함되어 있습니다. \\(\\frac{3}{4}\\)분위수가 \\(87.5\\)이므로 전체 \\(31\\)개의 변량 중 \\(87.5\\)를 초과하는 변량의 개수도 전체 개수의 \\(\\frac{1}{4}\\)인 \\(8\\)개나 됩니다 (그림 7.2). Min. 1st Qu. Median Mean 3rd Qu. Max. 27.00 43.00 54.00 72.42 87.50 191.00 그림 7.2: 경기도 미세먼지 농도 (2019년 3월) 박스 플롯과 \\(31\\)개의 변량 7.2 줄기와 잎 그림과 도수분포표 head(pm10_df2) tail(pm10_df2) pm10_df3 &lt;- pm10_df2 %&gt;% arrange(pm10,date) %&gt;% #pm10 컬럼의 변량이 작은 값부터 큰 값 순서로 정렬 (sorting) # x %/% 10: 10으로 나눈 몫 = 십의 자리, x %% 10: 10으로 나눈 나머지 = 일의 자리 mutate(tens = pm10 %/% 10, ones = pm10 %% 10) #십의 자리 컬럼, 일의 자리 컬럼 생성 head(pm10_df3) saveRDS(pm10_df3, &#39;pm10_df3.rds&#39;) #pm10_df3 데이터 프레임을 rds로 저장 pm10_df3$pm10 변량을 십의 자리 (줄기)와 일의 자리 (잎)로 구분하여 변량의 분포 상태를 쉽게 파악할 수 있도록 그림으로 정리하는 나타낸 것을 줄기와 잎 그림이라고 합니다. 미세먼지 농도 데이터의 줄기와 잎 그림을 그리기 위하여 십의 자리 컬럼으로 그룹을 생성하고 그룹 별 일의 자리 컬럼을 가지는 데이터 프레임을 얻고 이를 이용하여 줄기 벡터와 잎 벡터를 생성할 수 있습니다. 그런 다음에, 두 벡터를 컬럼으로 하는 데이터 프레임을 얻을 수 있습니다. 아래의 소스코드로 생성된 두 데이터 프레임 stem_leaf_df와 stem_leaf_df2의 데이터를 콘솔창에서 확인하고 차이점을 생각해 보세요. library(tidyverse) pm10_df3 &lt;- readRDS(file = &quot;pm10_df3.rds&quot;) pm10_tens_list &lt;- pm10_df3 %&gt;% select(tens,ones) %&gt;% #십의 자리 컬럼과 일의 자리 컬럼만 선택 group_by(tens) %&gt;% #십의 자리 컬럼으로 그룹을 생성 group_map(~ .x) #그룹 별로 일의 자리 컬럼을 가지는 티블 (데이터 프레임) 생성 #head(pm10_tens_list) stem &lt;- unique(pm10_df3$tens) #줄기 벡터 생성 leaf &lt;- c() #잎 벡터 초기화 for (i in 1:length(stem)) { leaf &lt;- c(leaf, paste(pm10_tens_list[[i]]$ones,collapse=&quot; &quot;)) } #잎이 있는 줄기만 행으로 존재하는 데이터 프레임 생성 stem_leaf_df &lt;- data.frame(stem=stem,leaf=leaf) #잎의 유무와 관계없이 모든 줄기를 가지는 벡터를 컬럼으로 가지는 데이터 프레임 생성 stem_all_df &lt;- data.frame(stem=seq(min(stem),max(stem),by=1)) #stem_all_df 데이터 프레임을 기준으로 stem_leaf_df를 붙임 stem_leaf_df2 &lt;- stem_all_df %&gt;% left_join(stem_leaf_df,by=&quot;stem&quot;) #stem_leaf_df2 &lt;- left_join(stem_all_df, stem_leaf_df,by=&quot;stem&quot;) 위의 소스코드를 실행할 때 에러가 발생하면, 아래와 같이 select()함수 부분 코드를 확인해보세요. pm10_df3 %&gt;% select(tens,ones) 아래 소스코드는 dplyr패키지의 select()함수를 이용하여 데이터 프레임에서 특정 컬럼 만을 가지는 부분 집합을 추출하는 역활을 합니다. 이 부분이 정상적으로 실행되지 않는 이유는 select()함수가 plotly패키지에도 존재하기 때문에 어떤 패키지에서 select()함수를 가져다 써야 하는지 명확하지 않아서 입니다. 그런 상황이 발생하면, 아래와 같이 함수를 사용할 때 패키지명을 앞에 붙여 어떤 패키지의 함수를 쓰는지 명확하게 해주거나, 사용하지 않는 패키지를 언로딩한 후에 사용하면 됩니다. pm10_df3 %&gt;% dplyr::select(tens,ones) #dplyr 패키지의 select() 함수를 사용 detach(&quot;package:plotly&quot;, unload=TRUE) #plotly 패키지를 언로딩 (unloading)한 후에 select()함수 사용 pm10_df3 %&gt;% select(tens,ones) 다시 본론으로 돌아와서, 미세먼지 농도 \\(31\\)개의 변량들과 stem_leaf_df2로 생성한 줄기와 잎 그림 (표 7.1)을 비교해보세요. 줄기와 잎 그림으로 부터, 십의 자리가 \\(3\\), \\(4\\), \\(5\\)인 변량이 \\(16\\)개로 가장 많으며, 십의 자리가 \\(10\\), \\(12\\), \\(15\\), \\(16\\), \\(18\\)인 변량은 존재하지 않는다는 것을 알 수 있습니다. ## [1] 27 30 34 36 39 40 40 43 43 44 44 45 49 ## [14] 50 53 54 56 60 68 70 71 83 83 92 92 118 ## [27] 131 135 148 176 191 표 7.1: 줄기 (십의 자리)와 잎 (일의 자리) 그림 줄기 잎 줄기 잎 2 7 11 8 3 0 4 6 9 12 4 0 0 3 3 4 4 5 9 13 1 5 5 0 3 4 6 14 8 6 0 8 15 7 0 1 16 8 3 3 17 6 9 2 2 18 10 19 1 지금까지 미세먼지 농도 데이터를 충분히 소개한 것 같습니다. 이제 아이리스 (iris, 붓꽃) 데이터를 이용하여 통계의 다른 개념들을 익혀보도록 합시다. 아이리스 데이터는 로날드 피셔 (Ronald Fisher, 1890~1962)가 아이리스의 종별 분류 (classification) 연구를 위해 작성하여 소개한 이후로 지금까지 통계 분야와 데이터 과학 분야에서 널리 사용되고 있습니다. 로날드 피셔는 영국의 통계학자, 유전학자, 진화 생물학자로 현대 통계학의 기초를 확립한 인물입니다3. 아이리스 데이터는 아이리스의 \\(3\\)가지 종(setosa, versicolor, virginica)에 대해 꽃받침 (sepal)과 꽃잎 (petal)의 길이 (length)와 너비 (width)를 정리한 데이터로, R에도 기본으로 내장되어 있습니다 (그림 7.3, 그림 7.4). 그림 7.3: 아이리스 3종 (출처 https://thegoodpython.com/iris-dataset) 그림 7.4: 아이리스 꽃받침과 꽃잎의 길이와 너비 (출처 https://rebrand.ly/integratedots-iris) 아이리스 데이터는 다섯 개의 컬럼을 가지고 있고 \\(150\\)행으로 구성되어있기 때문에 이해하기가 쉽고 크기도 작아서 통계의 기본 개념을 설명할 때 널리 사용됩니다 (표 7.2). 표 7.2: iris 데이터의 컬럼 정보 컬럼명 의미 데이터 타입 Species 붓꽃의 종 Factor Sepal.Width 꽃받침의 너비 Number Sepal.Length 꽃받침의 길이 Number Petal.Width 꽃잎의 너비 Number Petal.Length 꽃잎의 길이 Number 아이리스 데이터의 종 (Species) 컬럼값은 setosa, versicolor, virginica 세 가지로 구분되고, 컬럼의 데이터 타입은 factor입니다. 팩터 (factor) 데이터 타입은 몇 개 안되는 문자, 문자열, 숫자 값이 여러 차례 반복되는 경우 저장 및 검색의 효율을 높이기 위하여 코드화된 형태로 변환 (인코딩)하여 처리하는 데이터 형태입니다. iris 데이터의 경우, 종 (Species) 컬럼 벡터의 각 값은 \\(3\\)개의 레벨 (\\(3\\) levels: “setosa”, “versicolor”, “virginica”)중 하나의 값을 가지므로 내부적으로 각각 \\(1\\), \\(2\\), \\(3\\)으로 저장되고 처리됩니다. 아래의 소스코드를 한 줄 씩 차례대로 실행하면서 종 컬럼 벡터가 저장되어 있는 factor데이터 타입을 익히도록 하세요. library(datasets) data(iris) #아이리스 데이터 로딩 length(iris$Species) #전체 150개의 데이터 summary(iris$Species) #setosa 50개, versicolor 50개, virginica 50개 str(iris$Species) #setosa, versicolor, virginica는 각각 1, 2, 3으로 코드화되어서 저장됨 iris$Species[1:10] #1번째 값 부터 10번째 값은 모두 setosa str(iris$Species[1:10]) #setosa는 내부적으로 1로 저장되거나 처리됨 iris$Species[51:60] #51번째 값 부터 60번째 값은 모두 versicolor str(iris$Species[51:60]) #versicolor는 내부적으로 2로 저장되거나 처리됨 iris$Species[101:110] #101번째 값 부터 110번째 값은 모두 virginica str(iris$Species[101:110]) #virginica는 내부적으로 3으로 저장되거나 처리됨 팩터 데이터 타입은 필요에 따라 as.character()함수를 이용하여 문자 (문자열) 데이터 타입으로 변환하여 처리할 수 있습니다. 아래의 소스코드를 이용하여 데이터 타입을 팩터에서 문자로 변경하고 변경 여부를 확인해 보세요. iris$Species[1:10] %&gt;% as.character() iris$Species[1:10] %&gt;% as.character() %&gt;% str() 위에서 \\(18\\)개 시도의 미세먼지 농도를 박스 플롯을 그려서 비교했던 것 처럼, 아이리스의 종별 꽃잎 길이 분포를 비교해 볼 수 있습니다. 아래의 소스코드로 생성된 그림 7.5로 부터, setosa의 꽃잎 길이는 약 \\(1cm\\) ~ \\(2cm\\)사이에, versicolor의 꽃잎 길이는 약 \\(3cm\\) ~ \\(5cm\\)사이에, virginica의 꽃잎 길이는 약 \\(4.5cm\\) ~ \\(7cm\\)사이에 분포해 있다는 것을 알 수 있습니다. ggplot(iris, aes(x = Species, y = Petal.Length)) + geom_boxplot(fill=&#39;skyblue&#39;,outlier.size=3,alpha=0.8) + geom_jitter(width = 0.2, col=&#39;darkgray&#39;,alpha=0.5) 그림 7.5: 아이리스 3종의 꽃잎 길이 박스 플롯 아이리스 꽃잎 길이 (Petal.Length) 컬럼의 변량은 종별로 큰 차이가 있었습니다. 이번에는 아이리스 꽃받침 너비 (Sepal.Width) 컬럼의 변량 분포를 살펴보겠습니다. 아래의 소스코드로 박스 플롯을 그려보면, 꽃받침 너비 변량은 꽃잎 길이 만큼 종별로 큰 차이는 보이지는 않습니다. ggplot(iris, aes(x = Species, y = Sepal.Width)) + geom_boxplot(fill=&#39;skyblue&#39;,outlier.size=3,alpha=0.8) + geom_jitter(width = 0.2, col=&#39;darkgray&#39;,alpha=0.5) 아이리스 꽃받침 너비 (Sepal.Width) 변량의 대푯값을 살펴보면, 최소값은 \\(2cm\\)이고 최대값은 \\(4.4cm\\)입니다. dim(iris) #아이리스 데이터의 행렬 크기 (행개수,컬럼개수) 확인 head(iris) #아이리스 데이터의 앞부분 행 확인 tail(iris) #아이리스 데이터의 뒷부분 행 확인 summary(iris) #아이리스 전체 컬럼 변량의 대푯값 확인 summary(iris$Sepal.Width) #꽃받침 너비 컬럼 변량의 대푯값 확인 꽃받침 너비 (Sepal.Width) 변량의 최대값과 최소값의 차이는 \\(2.4cm\\)입니다. 이 변량을 여러개의 구간으로 구분하여 정리하면 변량의 분포를 쉽게 파악할 수 있습니다. 꽃받침 너비 변량을 \\(0.2cm\\)간격으로 \\(12\\)개의 구간으로 구분하였을 때, 이 변량은 \\(12\\)개의 계급 (class)을 가지게 되며 계급의 크기 (class interval)은 \\(0.2\\)가 됩니다. 이때, 각 계급에 속하는 변량의 수를 도수 (frequency)라고 하고, 각 계급별 도수 분포를 표로 표현한 것을 도수분포표 (frequency distribution table)라고 합니다. 아래의 소스코드와 같이 cut()함수를 이용하면 꽃받침 너비 변량을 \\(12\\)계급으로 나누어 볼 수 있습니다. cut()함수의 right입력값이 FALSE인 경우 계급 범위의 오른쪽 값을 포함하지 않기 때문에, 첫번째 계급의 범위는 [2,2.2)로 표현되며 이는 \\(2\\) 이상 \\(2.2\\) 미만을 의미합니다. 반대로, cut()함수의 right입력값이 TRUE인 경우 계급 범위의 오른쪽 값을 포함하게 되므로, 첫번째 계급의 범위는 (2,2.2]로 표현되며 이는 \\(2\\) 초과 \\(2.2\\) 이하를 의미합니다. 아래의 소스코드에서는 right입력값은 FALSE로 설정하였습니다. sort(unique(cut(iris$Sepal.Width, breaks = 12,right=FALSE))) 위의 코드를 dplyr패키지의 파이프라인 (%&gt;%)로 나타내면 아래와 같습니다. iris$Sepal.Width %&gt;% #꽃받침 너비 컬럼 벡터를 cut(breaks = 12,right=FALSE) %&gt;% #12개의 계급으로 구분한 다음 unique() %&gt;% #중복된 값을 제거하고 유니크한 계급값을 sort() #작은값에서 큰값으로 정렬 각 계급 별 도수를 파악하기 위하여 group_by()함수를 이용하여 같은 계급의 변량을 그룹화한 후, count()함수를 이용하여 각 계급 그룹의 도수를 구할 수 있습니다. iris %&gt;% group_by(class = cut(Sepal.Width, breaks = 12,right=FALSE)) %&gt;% count() 아래와 같이 한글 계급명 컬럼을 추가로 생성하면, 계급의 구간을 한글로 표현할 수 있습니다 (표 7.3). library(tidyr) iris %&gt;% mutate(class = cut(Sepal.Width,breaks=12,right=FALSE)) %&gt;% #꽃받침 길이를 12개의 계급으로 구분한 컬럼 생성 mutate(classname = gsub(&quot;\\\\[|\\\\)&quot;, &quot;&quot;, class)) %&gt;% #class컬럼에서 &#39;[&#39;와 &#39;)&#39;를 제거한 컬럼 생성 separate(classname, into=c(&quot;from&quot;, &quot;to&quot;),sep =&#39;,&#39;) %&gt;% #계급 구간 시작값 컬럼과 마지막값 컬럼 생성 mutate(from = format(as.numeric(from), nsmall = 1)) %&gt;% #시작값을 소수점 첫 째 자리까지 가지는 문자로 변환 mutate(to = format(as.numeric(to), nsmall = 1)) %&gt;% #마지막값을 소수점 첫 째 짜리까지 가지는 문자로 변환 mutate(classname = paste0(from,&#39;이상 ~ &#39;,to,&#39;미만&#39;)) %&gt;% #계급 한글 이름 컬럼 생성 group_by(classname) %&gt;% #계급 한글 이름 컬럼으로 그룹화 count() #계급별 도수 표 7.3: 아이리스 꽃받침 너비 변량의 도수분포표 계급 도수 2.0이상 ~ 2.2미만 1 2.2이상 ~ 2.4미만 7 2.4이상 ~ 2.6미만 11 2.6이상 ~ 2.8미만 28 2.8이상 ~ 3.0미만 10 3.0이상 ~ 3.2미만 37 3.2이상 ~ 3.4미만 31 3.4이상 ~ 3.6미만 10 3.6이상 ~ 3.8미만 9 3.8이상 ~ 4.0미만 2 4.0이상 ~ 4.2미만 3 4.2이상 ~ 4.4미만 1 위의 도수분포표에서 알 수 있는 아이리스 꽃받침 너비 \\(150\\)개 변량의 분포 특징은 아래와 같습니다. \\(3.0cm\\)이상 ~ \\(3.2cm\\)미만 계급인 아이리스가 \\(37\\)개로 가장 많다. \\(2.0cm\\)이상 ~ \\(2.2cm\\)미만 계급과 \\(4.2cm\\)이상 ~ \\(4.4cm\\)미만 계급이 각각 \\(1\\)개로 가장 적다. \\(2.6cm\\)이상 ~ \\(3.4cm\\)미만에 걸친 \\(4\\)개의 계급에 전체 변량의 \\(\\frac{2}{3}\\)이상이 속해 있다. 7.3 히스토그램과 도수분포다각형 도수분포표의 계급의 구간값을 \\(x\\)값으로 도수를 \\(y\\)값으로 하여 계급 별 도수를 막대 (직사각형) 그래프로 나타낸 것을 히스토그램 (histogram)이라고 합니다. 히스토그램의 각 계급 별 막대 (직사각형)의 높이와 넓이는 계급의 도수에 비례하므로, 히스토그램을 이용하면 각 계급 별 도수를 한 눈에 파악할 수 있습니다. 막대 그래프 대신 계급의 중앙값을 \\(x\\)값으로 도수를 \\(y\\)값으로 하는 선 그래프로 나타낸 것을 도수분포다각형 (frequency polygon)이라고 합니다. 도수분포다각형을 이용하면 전체 데이터의 분포 뿐만 아니라 계급 별 도수의 증가/감소 패턴, 특정 계급에의 치우침 등도 쉽게 파악할 수 있습니다. 데이터 프레임 iris를 이용하여 히스토그램과 도수분포다각형을 그려볼 수 있습니다. 아래의 소스코드는 세 단계 (도수분포표 데이터 프레임 생성, 필요한 컬럼 추가, ggplot()을 이용한 히스토그램과 도수분포다각형 그리기)로 나누어져 있습니다. 데이터 프레임 iris로 부터 계급 (class) 컬럼과 도수 (frequency) 컬럼을 가지는 도수분포표 데이터 프레임 sepal_width_frequency_df를 생성합니다. sepal_width_frequency_df &lt;- iris %&gt;% group_by(class = cut(Sepal.Width, breaks = 12,right=FALSE)) %&gt;% #12개의 계급으로 그룹화 count() %&gt;% #계급의 도수 (변량의 개수) as.data.frame() %&gt;% #그룹핑 결과를 데이터 프레임으로 변환 mutate_if(is.factor, as.character) %&gt;% #Factor로 인코딩되어있는 컬럼을 문자형으로 변경 select(class,frequency=n) #class 컬럼과 frequency 컬럼만 가지도록 함 sepal_width_frequency_df 도수분포표 데이터 프레임 sepal_width_frequency_df에 계급 구간 시작값 컬럼 (from), 계급 구간 마지막값 컬럼 (to), 계급 한글이름 컬럼 (classname), 계급의 중앙값 컬럼 (class_mark)을 추가하고 다른 이름의 데이터 프레임 sepal_width_frequency_df2로 저장합니다. 계급의 중앙값 (class mark)은 계급 구간의 시작값과 마지막값의 중앙값을 의미합니다. sepal_width_frequency_df2 &lt;- sepal_width_frequency_df %&gt;% mutate(classname = gsub(&quot;\\\\[|\\\\)&quot;, &quot;&quot;, class)) %&gt;% #class컬럼에서 &#39;[&#39;와 &#39;)&#39;를 제거한 컬럼 생성 separate(classname, into=c(&quot;from&quot;, &quot;to&quot;),sep =&#39;,&#39;) %&gt;% #계급 구간 시작값 컬럼과 마지막값 컬럼 생성 mutate(from = format(as.numeric(from), nsmall = 1)) %&gt;% #시작값을 소수점 첫 째 자리까지 가지는 문자로 변환 mutate(to = format(as.numeric(to), nsmall = 1)) %&gt;% #마지막값을 소수점 첫 째 짜리까지 가지는 문자로 변환 mutate(classname = paste0(from,&#39;이상 ~ &#39;,to,&#39;미만&#39;)) %&gt;% #계급 한글 이름 컬럼 생성 mutate(class_mark = (as.numeric(from)+as.numeric(to))/2) #계급의 중앙값 컬럼 생성 sepal_width_frequency_df2 데이터 프레임 sepal_width_frequency_df2에서 계급중앙값 (class_mark) 컬럼과 도수 (frequency)컬럼만 가지는 새로운 데이터 프레임 mydf2을 생성한 후에, 도수분포다각형의 시작점과 끝점을 위한 행을 추가합니다. 그런 다음, ggplot()의 geom_bar()를 이용하여 히스토그램을, geom_point()을 이용하여 계급의 중앙값을, geom_line()을 이용하여 도수분포다각형을 그립니다 (그림 7.6). mydf2 &lt;- sepal_width_frequency_df2 %&gt;% select(class_mark,frequency) %&gt;% #그래프를 그리는데 필요한 계급의 중앙값과 도수 컬럼만 선택 rbind(c(1.9,0), c(4.5,0)) %&gt;% #도수분포다각형의 시작점과 끝점을 위한 행 추가 arrange(class_mark) #계급의 중앙값으로 정렬 ggplot(data=mydf2, aes(x=class_mark,y=frequency)) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;, orientation = &#39;x&#39;, fill=&#39;skyblue&#39;,col=&#39;black&#39;,alpha=0.4) + #히스토그램 scale_x_continuous(breaks=seq(2.0,4.4,length=13)) + #x축 눈금 간격 xlab(&#39;sepal width (cm)&#39;) + #x축 제목 geom_point(size=2) + #계급의 중앙값 geom_line(lty=1,lwd=1.5,col=&#39;darkgray&#39;,alpha=0.7) #도수분포다각형 그림 7.6: 아이리스 꽃받침 너비 히스토그램과 도수분포다각형 hist()함수나 ggplot()의 geom_histogram(), geom_freqpoly()를 이용하면 iris 데이터 프레임으로 부터 직접 도수분포표나 도수분포 다각형을 그려볼 수 있습니다. 아래의 소스코드를 참고하세요. hist()함수의 breaks 입력값이나 geom_histogram()함수나 geom_freqpoly()함수의 binwidth 입력값 또는 bins 입력값이 주어지지 않아도 해당 함수가 자동으로 계급 구간을 계산하여 그래프를 그려냅니다. #hist(iris$Sepal.Width, breaks=12, right=FALSE, col=scales::alpha(&#39;skyblue&#39;,0.4)) hist(iris$Sepal.Width, right=FALSE, col=scales::alpha(&#39;skyblue&#39;,0.4)) ggplot(data=iris, aes(x=Sepal.Width)) + geom_histogram(bins=15,closed=&#39;left&#39;,fill=&quot;skyblue&quot;,color=&quot;black&quot;,alpha=0.4) ggplot(data=iris, aes(x=Sepal.Width)) + geom_freqpoly(bins=15,closed=&#39;left&#39;,lty=1,lwd=1.5,col=&#39;darkgray&#39;,alpha=0.7) #ggplot(data=iris, aes(x=Sepal.Width)) + # geom_histogram(binwidth=0.2,closed=&#39;left&#39;, # fill=&quot;skyblue&quot;,color=&quot;black&quot;,alpha=0.4) + # geom_freqpoly(binwidth=0.2,closed=&#39;left&#39;, # lty=1,lwd=1.5,col=&#39;darkgray&#39;,alpha=0.7) ggplot(data=iris, aes(x=Sepal.Width)) + geom_histogram(bins=15,closed=&#39;left&#39;,fill=&quot;skyblue&quot;,color=&quot;black&quot;,alpha=0.4) + geom_freqpoly(bins=15,closed=&#39;left&#39;,lty=1,lwd=1.5,col=&#39;darkgray&#39;,alpha=0.7) 7.4 상대도수 도수분포표를 이용하면 각 계급의 도수를 한눈에 파악할 수 있지만, 각 계급의 도수가 전체에서 차지하는 비율을 알기는 쉽지 않습니다. 각 계급의 도수가 전체에서 차지하는 비율을 알기 위하여, 각 계급의 도수를 도수의 총합으로 나눈 값을 상대도수 (relative frequency)라고 하고 아래와 같은 식으로 표현할 수 있습니다. \\[( \\small 어떤 \\: 계급의 \\: 상대도수 \\normalsize ) = \\frac {( \\small 그 \\: 계급의 \\: 도수 \\normalsize )} {( \\small 도수의 \\: 총합 \\normalsize )}\\] 상대도수 구하는 식을 도수분포표 데이터 프레임 sepal_width_frequency_df2의 도수 (frequency) 컬럼에 적용하면 아래의 소스코드와 같이 상대도수 (relative_frequency) 컬럼을 생성할 수 있습니다. sepal_width_frequency_df3 &lt;- sepal_width_frequency_df2 %&gt;% mutate(relative_frequency = round(frequency / sum(frequency),2)) 구해진 상대도수 데이터 프레임 sepal_width_frequency_df3의 계급 한글이름 (classname) 컬럼과 상대도수 (relative_frequency) 컬럼을 이용하면 아래의 소스코드와 같이 상대도수의 분포표 뿐만 아니라 히스토그램와 도수분포다각형도 그려볼 수 있습니다 (표 7.4, 그림 7.7). library(dplyr) library(kableExtra) knitr::kable( sepal_width_frequency_df3 %&gt;% select(classname, relative_frequency), col.names = c(&#39;계급&#39;,&#39;상대도수&#39;), #표 컬럼 이름 설정 booktabs = TRUE, align = &quot;c&quot;, #표 위치 설정 caption = &#39;아이리스 꽃받침 너비 변량의 상대도수 분포표&#39;) %&gt;% #표 제목 설정 kable_styling(full_width=FALSE,font_size=15) %&gt;% #표 컬럼 간격 설정 column_spec(1, width=&quot;15em&quot;) %&gt;% #첫 번째 컬럼 넓이 설정 column_spec(2, width=&quot;8em&quot;) #두 번째 컬럼 넓이 설정 표 7.4: 아이리스 꽃받침 너비 변량의 상대도수 분포표 계급 상대도수 2.0이상 ~ 2.2미만 0.01 2.2이상 ~ 2.4미만 0.05 2.4이상 ~ 2.6미만 0.07 2.6이상 ~ 2.8미만 0.19 2.8이상 ~ 3.0미만 0.07 3.0이상 ~ 3.2미만 0.25 3.2이상 ~ 3.4미만 0.21 3.4이상 ~ 3.6미만 0.07 3.6이상 ~ 3.8미만 0.06 3.8이상 ~ 4.0미만 0.01 4.0이상 ~ 4.2미만 0.02 4.2이상 ~ 4.4미만 0.01 mydf3 &lt;- sepal_width_frequency_df3 %&gt;% select(class_mark,relative_frequency) %&gt;% #그래프를 그리는데 필요한 계급의 중앙값과 상대도수 컬럼만 선택 rbind(c(1.9,0), c(4.5,0)) %&gt;% #도수분포다각형의 시작점과 끝점을 위한 행 추가 arrange(class_mark) #계급의 중앙값으로 정렬 ggplot(data=mydf3, aes(x=class_mark,y=relative_frequency)) + #x: 계급중앙값, y: 상대도수 geom_bar(position=&quot;dodge&quot;, stat=&quot;identity&quot;, #막대 그래프, 히스토그램 fill=&#39;skyblue&#39;,col=&#39;black&#39;,alpha=0.4) + scale_x_continuous(breaks=seq(2.0,4.4,length=13)) + #x축 눈금값 xlab(&#39;sepal width (cm)&#39;) + #x축 제목 ylab(&#39;relative frequency&#39;) + #y축 제목 geom_point(size=2) + #점 그래프, 계급의 중앙값 geom_line(aes(group=1),lty=1,lwd=1.5,col=&#39;darkgray&#39;,alpha=0.7) #선 그래프, 도수분포다각형 그림 7.7: 아이리스 꽃받침 너비 상대도수 상대도수는 각 계급의 비율을 나타낸 것이기 때문에, 전체 데이터의 개수가 다른 두 개의 데이터를 비교할 때 특히 유용합니다. 데이터 프레임 iris의 versicolor 종 데이터 중에서 임의로 \\(40\\)개를 추출하고, virginica 종 데이터 중에서 임의로 \\(30\\)개를 추출하여 데이터의 개수가 다른 두 종 그룹의 데이터 프레임을 생성합니다. 꽃받침 너비의 최소값과 최대값은 각각 \\(2.0\\), \\(3.8\\)로 \\(0.2\\)의 구간을 가지는 \\(9\\)개의 계급으로 나누어 볼 수 있습니다. set.seed(1001) #샘플을 추출할 때 임의(랜덤)로 추출하게 되는데, 똑같은 상황을 재현하고 싶은 경우에는 set.seed() 이용 versicolor40 &lt;- sample_n(subset(iris, Species ==&#39;versicolor&#39;), 40) #versicolor 종 40개 행 데이터 추출 set.seed(1002) #샘플을 추출할 때 임의(랜덤)로 추출하게 되는데, 똑같은 상황을 재현하고 싶은 경우에는 set.seed() 이용 virginica30 &lt;- sample_n(subset(iris, Species ==&#39;virginica&#39;), 30) #virginica 종 30개 행 데이터 추출 iris70 &lt;- rbind(versicolor40,virginica30) #두 데이터 프레임을 합쳐서 총 70개 행 생성 summary(iris70) #iris70 데이터 프레임의 컬럼별 대푯값 확인 summary(iris70$Species) #factor 컬럼에 사용하지 않는 레벨이 있는 것을 확인 iris70$Species &lt;- droplevels(iris70)$Species #factor 컬럼에서 사용하지 않는 레벨 제거 summary(iris70$Species) #factor 컬럼에서 사용하지 않는 레벨이 제거되었는지 확인 summary(iris70$Sepal.Width) #꽃받침 너비의 최소값과 최대값 확인 위에서 데이터 프레임 iris를 이용하여 히스토그램과 도수분포다각형을 그려본 로직을 그대로 iris70에 적용하면, 상대도수의 분포표와 히스토그램, 도수분포다각형을 그려볼 수 있습니다. 아래의 소스코드는 \\(4\\)단계 (상대도수 데이터 프레임 생성, 필요한 컬럼 추가, 상대도수 분포표 그리기, ggplot()을 이용한 히스토그램과 도수분포다각형 그리기)로 나누어져 있습니다. 데이터 프레임 iris70로 부터 계급 (class) 컬럼과 상대도수 (relative_frequency) 컬럼을 가지는 상대도수 분포표 데이터 프레임 sepal_width_relative_frequency_df를 생성합니다. 도수가 없는 계급도 유지하기 위하여 group_by()함수에 .drop = FALSE입력값을 추가하였습니다. 그리고, 종별 각 계급의 상대도수 relative_frequency를 구하기 위하여 ave()함수를 이용하여 종별 도수 총합 species_sum를 구합니다. sepal_width_relative_frequency_df &lt;- iris70 %&gt;% group_by(Species, class = cut(Sepal.Width, breaks = 9,right=FALSE), .drop = FALSE) %&gt;% #종별로 9개의 계급으로 그룹화, 도수가 없는 계급도 유지 count() %&gt;% #계급의 도수 (변량의 개수) as.data.frame() %&gt;% #종별, 계급별 그룹핑 결과를 데이터 프레임으로 변환 mutate_if(is.factor, as.character) %&gt;% #Factor로 인코딩되어있는 컬럼을 문자형으로 변경 mutate(frequency=n, species_sum = ave(frequency, Species, FUN=sum)) %&gt;% #도수와 종별 도수 총합 컬럼 생성 mutate(relative_frequency = round(frequency / species_sum,2)) %&gt;% #상대도수 컬럼 생성 select(class, Species, class, relative_frequency) sepal_width_relative_frequency_df 상대도수의 분포표 데이터 프레임 sepal_width_relative_frequency_df에 계급 구간 시작값 컬럼 (from), 계급 구간 마지막값 컬럼 (to), 계급 한글이름 컬럼 (classname), 계급의 중앙값 컬럼 (class_mark)을 추가하고 다른 이름의 데이터 프레임 sepal_width_relative_frequency_df2으로 저장합니다. sepal_width_relative_frequency_df2 &lt;- sepal_width_relative_frequency_df %&gt;% mutate(classname = gsub(&quot;\\\\[|\\\\)&quot;, &quot;&quot;, class)) %&gt;% #class컬럼에서 &#39;[&#39;와 &#39;)&#39;를 제거한 컬럼 생성 separate(classname, into=c(&quot;from&quot;, &quot;to&quot;),sep =&#39;,&#39;) %&gt;% #계급 구간 시작값 컬럼과 마지막값 컬럼 생성 mutate(from = format(as.numeric(from), nsmall = 1)) %&gt;% #시작값을 소수점 첫 째 자리까지 가지는 문자로 변환 mutate(to = format(as.numeric(to), nsmall = 1)) %&gt;% #마지막값을 소수점 첫 째 짜리까지 가지는 문자로 변환 mutate(classname = paste0(from,&#39;이상 ~ &#39;,to,&#39;미만&#39;)) %&gt;% #계급 한글 이름 컬럼 생성 mutate(class_mark = (as.numeric(from)+as.numeric(to))/2) #계급의 중앙값 컬럼 생성 sepal_width_relative_frequency_df2 spread()함수를 이용하여 종별 상대도수 (versicolor 상대도수, virginica 상대도수)를 컬럼으로 가지는 새로운 데이터프레임 spread_df를 생성하고 테이블로 나타냅니다 (표 7.5). library(dplyr) library(tidyr) library(kableExtra) spread_df &lt;- sepal_width_relative_frequency_df2 %&gt;% select(classname, Species, relative_frequency) %&gt;% #계급, 종, 상대도수 컬럼만 남김 spread(Species, relative_frequency) #종 별 상대도수 (versicolor 상대도수, virginica 상대도수)를 컬럼으로 표현 knitr::kable( spread_df, col.names = c(&#39;계급&#39;,&#39;versicolor 상대도수&#39;, &#39;virginica 상대도수&#39;), #표 컬럼 이름 설정 booktabs = TRUE, align = &quot;c&quot;, #표 위치 설정 caption = &#39;Versicolor와 Virginica의 꽃받침 너비 상대도수 분포표&#39;) %&gt;% #표 제목 설정 kable_styling(full_width=FALSE,font_size=15) #표 컬럼 간격 설정 표 7.5: Versicolor와 Virginica의 꽃받침 너비 상대도수 분포표 계급 versicolor 상대도수 virginica 상대도수 2.0이상 ~ 2.2미만 0.02 0.00 2.2이상 ~ 2.4미만 0.08 0.03 2.4이상 ~ 2.6미만 0.15 0.13 2.6이상 ~ 2.8미만 0.18 0.13 2.8이상 ~ 3.0미만 0.25 0.20 3.0이상 ~ 3.2미만 0.22 0.37 3.2이상 ~ 3.4미만 0.08 0.07 3.4이상 ~ 3.6미만 0.02 0.00 3.6이상 ~ 3.8미만 0.00 0.07 데이터 프레임 sepal_width_relative_frequency_df2에서 종 (Species) 컬럼, 계급중앙값 (class_mark) 컬럼, 도수 (frequency)컬럼만 가지는 새로운 데이터 프레임 mydf2을 생성한 후에, 종별 도수분포다각형의 시작점과 끝점을 추가하기 위하여 총 4행을 데이터 프레임에 추가합니다. 그런 다음, ggplot()의 geom_point()을 이용하여 계급의 중앙값을, geom_line()을 이용하여 도수분포다각형을 그립니다 (그림 7.8). mydf2 &lt;- sepal_width_relative_frequency_df2 %&gt;% select(Species,class_mark,relative_frequency) %&gt;% #그래프를 그리는데 필요한 종, 계급 중앙값, 상대도수 컬럼만 선택 #도수분포다각형의 종별 시작점과 끝점 4개값을 컬럼 별 (종, 계급중앙값, 상대도수)로 추가 rbind(data.frame(Species=rep(c(&#39;versicolor&#39;,&#39;virginica&#39;),each=2), class_mark=rep(c(1.9,3.9),2), relative_frequency=rep(0,4))) %&gt;% arrange(Species,class_mark) #종과 계급의 중앙값으로 정렬 ggplot(data=mydf2, aes(x=class_mark,y=relative_frequency,group=Species,color=Species)) + #x:계급,y:상대도수,종 그룹을 색으로 표현 geom_point(size=1) + #계급의 중앙값 geom_line(lty=1,lwd=1.0,alpha=0.7) + #도수분포다각형 scale_x_continuous(breaks=seq(2.0,3.8,length=10)) + #x축 눈금 간격 xlab(&#39;sepal width (cm)&#39;) + #x축 제목 ylab(&#39;relative frequency&#39;) #y축 제목 그림 7.8: 아이리스 versicolor와 virginica의 꽃받침 너비 상대도수 도수분포다각형 위의 그림과 같이 상대도수를 이용한 도수분포다각형을 그리면 도수의 총합이 다른 두 개의 데이터 그룹 (versicolor \\(40\\)개, virginica \\(30\\)개)의 계급 별 비율을 쉽게 비교할 수 있습니다. 7.5 데이터 분석 심화 - 머신 러닝 인공 지능 (Artificial Intelligence, AI)의 한 분야인, 머신 러닝(machine learning, 기계 학습)은 컴퓨터에 데이터와 데이터의 특성을 파악할 수 있는 학습 알고리즘 또는 학습 모델을 미리 입력하고 컴퓨터 스스로 데이터의 특성을 파악하는 규칙을 찾아내도록 하는 방법으로, 주로 통계적인 접근 방법이 사용됩니다. 다른 말로 하면, 머신 러닝이란 컴퓨터에게 특정 입력값과 결과값을 포함하는 데이터를 주고 입력값으로 부터 결과값을 얻어내는 알고리즘이나 모델을 생성하도록 컴퓨터를 학습시키고 훈련시키는 방법입니다. 앞에서 이미 살펴본 것처럼, 함수는 입력값을 가지고 특정 공식 또는 계산을 수행한 후에 결과값을 반환합니다. 아래 소스코드의 add()함수는 입력값 a와 b를 더한 값을 반환합니다. 따라서, c의 결과값은 \\(3\\)이 됩니다. 알고리즘이나 모델도 함수와 비슷한 개념이라고 생각하면 됩니다. add &lt;- function (a, b) { result &lt;- a + b return (result) } c &lt;- add(1,2) 컴퓨터가 데이터를 분석하고 특성 규칙을 찾아낸 후, 새로운 데이터가 입력되었을 때 이미 알아낸 규칙에 따라 데이터를 특정 그룹으로 분류해 내거나 최적의 해법을 제시하는 일련의 과정은 인간의 추론 방식과 매우 유사합니다. 뿐만 아니라, 컴퓨터의 계산 능력은 인간보다 훨씬 빠르고 정확하므로 머신 러닝은 다양한 분야 (문자 인식, 얼굴 인식, 음성 인식, 정보 검색 및 검색 엔진, 유전자 분석, 질병 진단, 애니메이션, 가상 현실, 무인 자동차 경로 탐색 등)에 적용되고 있습니다. 머신 러닝을 이용한 데이터 분석 과정을 각 단계별 나누어 보면 아래와 같습니다. 데이터 전처리 (preprocessing) 훈련 데이터셋 (training dataset)과 테스트 데이터셋 (testing dataset) 생성 데이터 탐색 (탐색적 데이터 분석, exploratory data analysis) 데이터 시각화 (dataset visualization) 훈련 데이터셋을 이용한 알고리즘/모델 생성 및 성능 평가 (algorithm/model building and evaluation) 테스트 데이터셋을 이용한 알고리즘/모델 검증 (verification) 위의 \\(6\\)단계의 머신 러닝 과정을 거치면 우리 실생활에 도움이 되도록 컴퓨터를 훈련시킬 수 있습니다. 예를 들면, 여러분이 수신한 이메일이 스팸인지 아닌지 구분할 수 있도록 컴퓨터를 훈련시킬 수 있습니다. 위에서 살펴본 아이리스 데이터의 \\(4\\)개 컬럼 (꽃잎 길이, 꽃잎 너비, 꽃받침 길이, 꽃받침 너비) 속성을 입력값으로 컴퓨터를 훈련시켜 새롭게 관측된 아이리스의 \\(4\\)개 속성 (꽃잎 길이, 꽃잎 너비, 꽃받침 길이, 꽃받침 너비)이 입력되었을 때 어떤 종인지를 예측하는 알고리즘/모델을 만들수 도 있습니다. 위의 머신 러닝 \\(6\\)단계를 이용하여 아이리스 \\(4\\)개 컬럼 (꽃잎 길이, 꽃잎 너비, 꽃받침 길이, 꽃받침 너비) 속성을 입력값으로 하여 어떤 종인지를 예측하는 결과값을 제공하는 알고리즘/모델을 만들어 봅시다. 이를 위해서, 데이터의 처리와 시각화를 위한 tidyverse 패키지와 R의 중요 머신 러닝 패키지 중 하나인 caret패키지를 로딩합니다. caret패키지 (Classification And REgression Training)는 R의 중요 머신 러닝 패키지 중 하나로, 데이터 시각화, 데이터 샘플 추출, 학습 모델 검증, 학습 모델 비교 기능을 제공할 뿐 아니라 수백 개의 머신 러닝 알고리즘을 포함하고 있습니다. #install.packages(&quot;tidyverse&quot;) library(tidyverse) #install.packages(&quot;caret&quot;) library(caret) 이제 본격적으로 아이리스 데이터를 이용하여 아이리스 종별 예측 모델을 생성해 봅시다. 7.5.1 데이터 전처리 아이리스 데이터는 작은 데이터셋이기도 하고 이미 잘 정리되어있기 때문에 데이터 전처리 과정을 생략할 수 있지만, 대부분 실생활에서 접하게 되는 데이터들은 반드시 분석 전에 데이터를 살펴보고 데이터 자체의 오류나 문제를 미리 해결하는 전처리 과정을 거쳐야 합니다. 데이터 전처리 과정을 통하여 비어있는 불완전한 (incomplete) 속성, 잘못 입력된 에러 (error) 또는 잡음 (noisy) 또는 극단치 (outlier), 두 관련 변량들 간의 모순된 (inconsistent) 속성 등을 처리해 주어야 합니다. 모델링 결과의 질은 입력 데이터에의 질에 영향을 받기 때문에 입력 데이터의 질을 높이고 모델에 필요한 입력 데이터의 구조와 형식으로 변경하는 작업을 거쳐야 본격적인 데이터 분석 과정으로 넘어가게 됩니다. 7.5.2 훈련 데이터셋과 테스트 데이터셋 데이터의 각 컬럼 (column, 열)은 하나의 변량이고 컬럼 벡터는 그 변량값들을 담고 있습니다. 반면, 데이터의 각 로우 (row, 행)은 하나의 관측값 (측정값, observation)을 의미합니다. 아이리스 데이터의 \\(150\\)개 행은 \\(150\\)개의 아이리스를 각각 관측하고 기록한 결과입니다. 머신 러닝에서는, 컴퓨터에 데이터와 학습 알고리즘 또는 학습 모델을 입력하면 컴퓨터가 스스로 알고리즘 (또는 모델)을 훈련시키고 데이터의 특성을 파악하는 규칙을 찾아냅니다. 그 다음에, 새로운 데이터를 훈련된 알고리즘 (또는 모델)에 적용하여 알고리즘 (모델)이 얼마나 정확하게 작동하는지 평가하고 테스트하는 과정을 반드시 거쳐야 합니다. 훈련된 알고리즘이 훈련에 사용된 데이터에서 정확하게 작동한다고 해서 그 알고리즘이 다른 데이터에서도 반드시 정확하게 작동하는 것은 아닙니다. 훈련된 알고리즘을 새로운 데이터에 적용했을 때 정확하게 작동하지 않는다면 훈련된 알고리즘을 다른 데이터에 사용하는 것은 의미가 없습니다. 따라서, 훈련된 알고리즘이 새로운 데이터에서도 잘 작동하는지 확인하는 테스트 과정이 필요합니다. 테스트 과정에서는 훈련된 알고리즘이 다른 새로운 데이터 (일반 데이터, 훈련에 사용하지 않은 데이터, 외부 데이터)에 적용했을 때 얼마나 정확한 지, 얼마 만큼의 오차 (error, 에러)가 발생하는 지를 측정 (추정)하게 되며, 일반화 오차 (generalization error) 또는 외부 샘플 오차 (out-of-sample error)의 추정값 (estimation)이 테스트의 결과가 됩니다. 일반화 오차의 추정값이 적을 수록, 훈련된 알고리즘 (모델)이 이전에 본 적이 없는 새로운 샘플 데이터에서 잘 작동할 확률이 높습니다. 따라서, 처음부터 데이터를 훈련을 위한 데이터셋 (dataset)과 테스트를 위한 데이터셋으로 나눈 후에, 훈련 데이터셋은 알고리즘 (또는 모델)을 훈련시키는데 사용하고 테스트 데이터셋은 훈련된 알고리즘의 정확성을 평가하고 테스트하는데 사용하게 됩니다. 보통 전체 데이터의 \\(80 \\%\\)를 훈련용으로 사용하고 \\(20 \\%\\)를 테스트용으로 사용합니다. 위에서 언급한 것처럼 아이리스의 종별 분류를 위하여, 아이리스 \\(150\\)개의 관측값 (\\(150\\)개의 행)의 \\(80 \\%\\)를 훈련 데이터셋으로 나머지 \\(20 \\%\\)를 테스트 데이터셋으로 나눕니다. #아이리스 종 컬럼을 기준으로 전체 데이터의 80%를 임의로 추출하기 위하여 데이터 행 번호를 얻습니다. index &lt;- createDataPartition(iris$Species, p=0.80, list=FALSE) #전체 데이터 80%의 행 번호를 이용하여 훈련 데이터셋을 구합니다. trainset &lt;- iris[index,] #훈련 데이터셋에 사용된 행 번호를 제외한 나머지 행 번호로 테스트 데이터셋을 구합니다. testset &lt;- iris[-index,] 훈련 데이터셋은 모델을 생성하고 훈련시키는데 사용하는 데이터로 모델이 이미 알고 있는 데이터입니다. 아이리스 종 분류에 머신 러닝을 사용한다는 것은 분류 오차가 발생 비율이 작아지도록 모델을 훈련시킨다는 뜻입니다. 모델은 훈련 데이터셋을 통하여 데이터를 이해하고 적절한 모델을 선택하고 모델 파라메터를 결정합니다. 테스트 데이터셋은 모델의 훈련과 튜닝에 사용되지 않은 데이터이므로, 이를 이용하여 모델에 새로운 아이리스 데이터가 주어졌을 때 얼마나 종을 잘 분류해 내는지를 검증합니다. 모델의 훈련, 튜닝, 최적화에 사용하지 않은 데이터를 이용하여 모델의 성능을 검증하고 오류 발생 비율을 추정하는 과정을 거친 후에야, 훈련된 모델의 분류 정확도와 신뢰도에 대해서 말할 수 있습니다. 이제, 데이터 분석을 위한 데이터 준비가 끝났으니 탐색적 데이터 분석을 진행해 봅시다. 박스 플롯도 그려보고 대푯값이나 데이터 분포를 그려보는 이유는 데이터를 한 눈에 파악하고 좀 더 깊이 이해하기 위해서 입니다. 7.5.3 데이터 탐색 경험있는 데이터 과학자들은 데이터의 탐색 과정을 통하여 데이터를 이해하고, 데이터가 원하는 목적에 부합되는지, 원하는 결과를 얻기 위해서는 어떤 모델을 사용하여야 하는지 등에 대하여 생각하며 다음 데이터 분석 단계를 준비하게 됩니다. 데이터 탐색은 데이터의 구조를 파악하고 통계적 대푯값이나 그래프를 이용하여 데이터의 컬럼별 패턴이나 연관성을 이해하는 과정입니다. 가장 먼저 파악하여야 할 내용은 데이터의 구조, 양, 통계적 대푯값 등입니다. 아래의 소스코드로 데이터의 내용을 파악해 보세요. dim(trainset) #훈련 데이터셋의 차원 정보 (행의 개수, 열의 개수) ## [1] 120 5 str(trainset) #훈련 데이터셋의 각 컬럼의 명칭, 데이터 타입, 데이터 일부 확인 ## &#39;data.frame&#39;: 120 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 4.4 4.9 5.4 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 2.9 3.1 3.7 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.4 1.5 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.1 0.2 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... sapply(trainset,class) #훈련 데이터셋의 각 컬럼별 데이터 타입을 확인하는 또 다른 방법 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; ## Species ## &quot;factor&quot; levels(trainset$Species) #종 컬럼은 팩터형으로 데이터 타입이므로 몇 개의 레벨 그룹을 가지는지 확인 ## [1] &quot;setosa&quot; &quot;versicolor&quot; &quot;virginica&quot; head(trainset) #훈련 데이터셋의 첫 부분 데이터 확인 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 ## Species ## 1 setosa ## 2 setosa ## 3 setosa ## 4 setosa ## 5 setosa ## 6 setosa tail(trainset) #훈련 데이터셋의 끝 부분 데이터 확인 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 143 5.8 2.7 5.1 1.9 ## 145 6.7 3.3 5.7 2.5 ## 146 6.7 3.0 5.2 2.3 ## 147 6.3 2.5 5.0 1.9 ## 148 6.5 3.0 5.2 2.0 ## 149 6.2 3.4 5.4 2.3 ## Species ## 143 virginica ## 145 virginica ## 146 virginica ## 147 virginica ## 148 virginica ## 149 virginica summary(trainset) #훈련 데이터셋의 각 컬럼별 통계적 대푯값 확인 ## Sepal.Length Sepal.Width Petal.Length ## Min. :4.40 Min. :2.00 Min. :1.00 ## 1st Qu.:5.10 1st Qu.:2.80 1st Qu.:1.50 ## Median :5.80 Median :3.00 Median :4.40 ## Mean :5.87 Mean :3.05 Mean :3.77 ## 3rd Qu.:6.40 3rd Qu.:3.30 3rd Qu.:5.10 ## Max. :7.90 Max. :4.20 Max. :6.90 ## Petal.Width Species ## Min. :0.10 setosa :40 ## 1st Qu.:0.30 versicolor:40 ## Median :1.30 virginica :40 ## Mean :1.21 ## 3rd Qu.:1.82 ## Max. :2.50 데이터의 구조와 양, 통계적 대푯값 등을 확인해 본 후에, 훈련 데이터셋의 종별 도수분포, 상대도수분포, 백분율을 구해볼 수 있습니다. 아래 소스코드를 실행하여 각 종별 도수분포 (40), 상대도수분포 (0.33), 백분율 (33%)이 동일한 것을 확인해 볼 수 있습니다. relative_frequency &lt;-prop.table(table(trainset$Species)) cbind(freq = table(trainset$Species), relative_frequency = relative_frequency, percentage = relative_frequency * 100) ## freq relative_frequency percentage ## setosa 40 0.3333 33.33 ## versicolor 40 0.3333 33.33 ## virginica 40 0.3333 33.33 7.5.4 데이터 시각화 대략적인 데이터의 구조와 통계값을 확인한 후에, ggplot2패키지를 이용하여 다양한 그래프를 그려보면서 데이터의 종별, 컬럼별 특성을 파악합니다. 아래 소스코드의 i 값을 \\(1\\), \\(2\\), \\(3\\), \\(4\\)로 바꿔 가면서 각 컬럼의 박스 플롯을 그려본 후에, \\(4\\)개 컬럼의 박스 플롯을 한꺼번에 그려봅니다. i &lt;- 1 #1, 2, 3, or 4 ## i번째 컬럼을 이용한 박스 플롯 box &lt;- ggplot(data=trainset, aes_string(x=&#39;Species&#39;, y=names(trainset)[i])) + geom_boxplot(aes(fill=Species)) + ylab(names(trainset)[i]) + ggtitle(paste0(&quot;Boxplot of &quot;, names(trainset)[i])) + stat_summary(fun=mean, geom=&quot;point&quot;, shape=5, size=3) print(box) #install.packages(&quot;gridExtra&quot;) library(gridExtra) boxlist &lt;- list() #probability density list for(i in c(1:4)) { boxlist[[i]] &lt;- ggplot(data=trainset, aes_string(x=&#39;Species&#39;, y=names(trainset)[i])) + geom_boxplot(aes(fill=Species)) + ylab(names(trainset)[i]) + stat_summary(fun=mean, geom=&quot;point&quot;, shape=5, size=3) } grid.arrange(boxlist[[1]],boxlist[[2]],boxlist[[3]],boxlist[[4]], nrow = 2) 아래 소스코드의 i 값을 \\(1\\), \\(2\\), \\(3\\), \\(4\\)로 바꿔 가면서 각 컬럼별 히스토그램을 그려본 후에, \\(4\\)개 컬럼의 히스토그램을 한꺼번에 그려봅니다. #install.packages(&quot;ggthemes&quot;) library(ggthemes) i &lt;- 1 ##1, 2, 3, or 4 ## i번째 컬럼을 이용한 히스토그램 histogram &lt;- ggplot(data=trainset, aes_string(x=names(trainset)[i])) + geom_histogram(binwidth=0.2, color=&quot;black&quot;, aes(fill=Species)) + xlab(names(trainset)[i]) + ylab(&quot;Frequency&quot;) + ggtitle(paste0(&quot;Histogram of &quot;, names(trainset)[i])) # + theme_economist() print(histogram) histlist &lt;- list() #probability density list for(i in 1:4) { ## i번째 컬럼을 이용한 히스토그램 histlist[[i]] &lt;- ggplot(data=trainset, aes_string(x=names(trainset)[i])) + geom_histogram(binwidth=0.2, color=&quot;black&quot;, aes(fill=Species)) + xlab(names(trainset)[i]) + ylab(&quot;Frequency&quot;) #+ theme_economist() } grid.arrange(histlist[[1]],histlist[[2]],histlist[[3]],histlist[[4]], nrow = 2) 훈련 데이터셋의 종별 꽃받침 길이와 꽃잎 길이를 각 각 \\(x\\), \\(y\\)축으로 하여 상호 관계와 경향 (trend)을 직선으로 표현합니다. qplot(Sepal.Length, Petal.Length, data=trainset, color=Species, shape=Species) g &lt;- ggplot(data=trainset, aes(x = Sepal.Length, y = Petal.Length)) gpoint &lt;- g + geom_point(aes(color=Species, shape=Species)) gpoint g &lt;- ggplot(data=trainset, aes(x = Sepal.Length, y = Petal.Length)) gpoint &lt;- g + geom_point(aes(color=Species, shape=Species)) gpoint + geom_smooth(method=&quot;lm&quot;) ## Faceting: Producing multiple charts in one plot facet &lt;- ggplot(data=trainset, aes(x=Sepal.Length, y=Petal.Length, color=Species))+ geom_point(aes(shape=Species), size=1.5) + geom_smooth(method=&quot;lm&quot;) + xlab(&quot;Sepal Length&quot;) + ylab(&quot;Petal Length&quot;) + ggtitle(&quot;Faceting&quot;) #+ theme_economist() + facet_grid(. ~ Species) # Along rows print(facet) 아래 소스코드의 i 값을 \\(1\\), \\(2\\), \\(3\\), \\(4\\)로 바꿔 가면서 각 종별, 컬럼별 확률 밀도 곡선을 그려본 후에, \\(4\\)개 컬럼의 확률 밀도 곡선을 한꺼번에 그려봅니다.각 계급별 확률 밀도는 각 계급별 상대 도수를 계급 구간으로 나눈 값으로, 각 계급별 확률 밀도를 곡선으로 연결하면 확률 밀도 곡선이 됩니다. 각 계급별 상대 도수의 합이 \\(1\\)인 것처럼, 확률 밀도 곡선과 \\(x\\)축이 만드는 도형의 면적도 \\(1\\)이 됩니다. i &lt;- 1 ##1, 2, 3, or 4 ## i번째 컬럼을 이용한 히스토그램 ggplot(trainset, aes_string(x = names(trainset)[i], fill = &#39;Species&#39;)) + geom_density(alpha = 0.5) + xlab(names(trainset)[i]) pdlist &lt;- list() #probability density list for(i in 1:4) { pdlist[[i]] &lt;- ggplot(trainset, aes_string(x = names(trainset)[i], fill = &#39;Species&#39;)) + geom_density(alpha = 0.5) + xlab(names(trainset)[i]) } grid.arrange(pdlist[[1]],pdlist[[2]],pdlist[[3]],pdlist[[4]], nrow = 2) 종별 컬럼별 분포 특성을 파악하기 위하여 caret패키지가 제공하는 featurePlot()함수를 이용할 수도 있습니다. 훈련 데이터셋의 입력값 컬럼들 (꽃받침 길이, 꽃받침 너비, 꽃잎 길이, 꽃잎 너비)을 x, 출력값 컬럼 (종)을 y로 구분합니다. x &lt;- trainset[,1:4] #input y &lt;- trainset[ ,5] #output 종별 컬럼 값의 분포와 박스 플롯을 그립니다. featurePlot(x, y, &quot;strip&quot;, jitter = TRUE) 네 개의 컬럼을 두 컬럼 (변량) 조합 별로 구분한 후, 두 컬럼 (변량)을 각 각 \\(x\\), \\(y\\)축으로 하여 그래프를 그려 두 컬럼(변량) 간의 상호 관계 (interaction)를 파악합니다. 또 한, 타원 (ellipse)을 이용하여 종 별, 입력 변량 조합 별 상호 관계의 경향을 시각화 합니다. featurePlot(x, y, &quot;pairs&quot;, auto.key=list(columns = 3)) install.packages(&#39;ellipse&#39;) library(ellipse) featurePlot(x, y, &quot;ellipse&quot;, auto.key=list(columns = 3)) 종 별 확률 밀도 곡선을 그립니다. scales&lt;-list(x = list(relation = &quot;free&quot;), y = list(relation = &quot;free&quot;)) featurePlot(x = x, y = y, plot = &quot;density&quot;, scales = scales, auto.key=list(columns = 3)) 7.5.5 알고리즘/모델 생성 및 평가 이제 여러분은 데이터의 통계적 대푯값을 파악하고 다양한 그래프를 이용한 시각적 분석을 통하여 아이리스 훈련 데이터셋의 컬럼별 (변량별, 속성별) 관계를 어느 정도 파악했습니다. 파악된 정보를 바탕으로, 머신 러닝을 이용해서 풀어야 할 문제/질문 (problem/question)이 명확히 제시되어야 해결책/해답 (solution/answer)을 예측하는 모델을 생성할 수 있습니다. 해결해야 할 문제와 모델의 입력값/출력값을 다시 한번 정리하면 아래와 같습니다. 문제/질문: 주어진 데이터셋의 꽃받침 길이, 꽃받침 너비, 꽃잎 길이, 꽃잎 너비 속성을 이용하여 각 관측치가 setosa, versicolor, virginica 중에 어떤 종에 속하는지 알 수 있을까? 모델의 입력값: 훈련 데이터셋의 첫 번째 컬럼부터 네 번째 컬럼 까지의 속성들 (꽃받침 길이, 꽃받침 너비, 꽃잎 길이, 꽃잎 너비) 모델의 출력값: 훈련 데이터셋의 다섯 번째 컬럼 (종)의 \\(3\\)가지 레벨 (setosa, versicolor, virginica) 중 하나의 값을 반환 훈련 데이터셋을 이용하여 여러 개의 모델을 생성한 후에 각 모델의 출력값과 훈련 데이터셋의 종별 컬럼값을 비교해서 가장 좋은 예측 결과를 내는 모델을 선택합니다. 이를 위하여 아래의 \\(3\\)단계를 거칩니다. 훈련 데이터셋을 여러 모델에 사용하기 위한 준비 (서브셋 생성, 반복훈련 횟수 설정, 모델의 유효성 측정 수단 설정) 다섯 개의 모델을 생성하고 각 모델의 유효성을 검증 각 모델의 정확도를 비교하고 최적 모델을 선택 7.5.5.1 훈련 데이터셋을 여러 알고리즘/모델에 사용하기 위한 준비 머신 러닝 모델은 제공된 훈련 데이터셋을 이용하여 내부 설정 변수 (모형 매개변수, 모델 파라메터, model parameter)를 스스로 추정해 냅니다. 하지만 알고리즘/모델의 결과는 훈련 데이터셋에 영향을 받지 않는 외부 설정 변수 (모델을 튜닝하고 최적화하는 설정값, 모델 하이퍼 파라메터, model hyperparameter) 또는 선택된 모델의 특성에 따라 많은 영향을 받습니다. 모델의 외부 설정변수 (하이퍼파라메터)를 검증하거나 여러 모델들을 생성하고 각 모델의 유효성을 검증하기 위해 훈련 데이터셋의 일부를 검증 데이터셋 (validation dataset)으로 활용하기도 합니다. 훈련 데이터셋으로 부터 랜덤으로 \\(10\\)개의 부분 집합 (서브셋, subset)으로 구분하고 각 모델을 \\(9\\)개의 서브셋의 조합으로 훈련시키고 나머지 \\(1\\)개의 서브셋으로 검증하는 10개의 서브셋을 이용한 교차 유효성 확인 (10-fold cross-validation) 기법을 사용합니다. 각 모델 별로 좀 더 정확한 결과를 얻기 위하여 랜덤으로 \\(10\\)개의 서브셋 조합을 바꿔 가면서 훈련과 검증을 \\(10\\)번 반복하게 됩니다. 반복 훈련을 통하여 생성된 각 모델을 평가하기 위하여 아래와 같은 식으로 정확도 (accuracy)를 평가합니다. 예를 들어, \\(100\\)개의 데이터를 모델에 입력하여 \\(95\\)개의 데이터가 정확한 결과를 반환했을 때, 이 모델은 \\(95\\)%의 정확도를 가집니다. \\[\\small 정확도 \\normalsize = \\small \\frac{정확하게 \\: 예측된 \\: 결과의 \\: 개수}{전체 \\: 결과의 \\: 개수} \\normalsize \\times 100 \\%\\] 아래의 소스코드를 이용하여 각 모델 별로 훈련 데이터셋을 \\(10\\)개의 서브셋으로 나누고 \\(10\\)번 반복 훈련하도록 설정합니다. 그리고, 각 모델의 유효성을 평가하는데 각 모델의 정확도를 이용하도록 설정합니다. #10개의 서브셋으로 3번 반복 훈련, repeated 10-fold cross validation control &lt;- trainControl(method = &quot;cv&quot;, number = 10) metric &lt;- &quot;Accuracy&quot; 7.5.5.2 다섯 개의 알고리즘/모델을 생성하고 각 알고리즘/모델의 유효성을 검증 알고리즘/모델을 생성하고 유효성 검증을 거치기 전에는 어떤 알고리즘/모델이 주어진 문제/질문에 가장 적합한 해결책이 될 것인지 알 수가 없습니다. 하지만, 데이터 시각화에서 보았던 여러 그래프 중의 일부가 종별로 직선형 패턴을 보였던 것을 기억해 보면, 선형 패턴을 이용하는 알고리즘/모델이 좋은 결과를 보일 것으로 기대해 볼 수 있습니다. 아래와 같이 다섯 개의 알고리즘/모델이 생성되고 평가되었습니다. 단순 선형 알고리즘과 비선형 알고리즘이 생성되었고, 같은 서브셋을 사용하여 훈련시키고 결과를 비교하기 위하여 동일한 랜덤 시드 set.seed(7)가 사용되었습니다. 각 알고리즘/모델에 대한 설명이나 궁금한 점은 인터넷 검색을 통해 해결할 수 있습니다. 단순 선형 알고리즘: Linear Discriminant Analysis (LDA) 비선형 알고리즘: Classification and Regression Trees (CART) 비선형 알고리즘: k-Nearest Neighbors (kNN) 복잡 비선형 알고리즘: Support Vector Machines (SVM) with a linear kernel 복잡 비선형 알고리즘: Random Forest (RF) 아래의 소스코드를 이용하여 다섯 개의 알고리즘/모델을 생성합니다. # Linear Discriminant Analysis (LDA) set.seed(7) fit.lda &lt;- train(Species~., data=trainset, method=&quot;lda&quot;, metric=metric, trControl=control) # Classification and Regression Trees (CART) set.seed(7) fit.cart &lt;- train(Species~., data=trainset, method=&quot;rpart&quot;, metric=metric, trControl=control) # k-Nearest Neighbors (kNN) set.seed(7) fit.knn &lt;- train(Species~., data=trainset, method=&quot;knn&quot;, metric=metric, trControl=control) # Support Vector Machines (SVM) set.seed(7) fit.svm &lt;- train(Species~., data=trainset, method=&quot;svmRadial&quot;, metric=metric, trControl=control) # Random Forest (RF) set.seed(7) fit.rf &lt;- train(Species~., data=trainset, method=&quot;rf&quot;, metric=metric, trControl=control) 7.5.5.3 최적 알고리즘/모델 선택 다섯 개의 알고리즘/모델이 생성되었고, 각 알고리즘/모델 생성 시에 해당 알고리즘/모델의 정확도도 측정되었습니다. 아래의 소스코드와 같이, 다섯 알고리즘/모델의 결과를 리스트로 생성하고 resamples()함수에 입력값으로 이용하여 각 알고리즘/모델의 정확도를 비교해 볼 수 있습니다. # Summarize model accuracy for each model results &lt;- resamples(list(lda=fit.lda,cart=fit.cart, knn=fit.knn, svm=fit.svm, rf=fit.rf)) summary(results) resamples()함수를 이용하여 다섯 알고리즘/모델의 정확도 (accuracy)뿐만 아니라 카파 (Kappa) 통계량도 비교해 볼 수 있습니다. 각 알고리즘/모델은 \\(10\\)개의 서브셋으로 \\(10\\)번 교차 유효성 확인 절차를 거쳤기 때문에 \\(10\\)개의 정확도 값이 나오고 이를 이용한 정확도 통계량과 카파 (Kappa) 통계량을 구할 수 있습니다. 정확도 통계량은 검증 데이터셋 만을 이용하여 계산해 내는 반면, 카파 통계량은 모델의 훈련 데이터셋으로 구해낸 기대 정확도와 검증 데이터셋으로 구해낸 실제 정확도를 연산하여 구해냅니다. Kappa 통계량을 수식으로 나타내면 아래와 같습니다. \\[Kappa = \\frac{\\small 실제 \\: 정확도 \\normalsize = \\small 기대 \\: 정확도 \\normalsize}{1 - \\small 기대 \\: 정확도 \\normalsize}\\] 평균 정확도와 평균 Kappa 값이 \\(1\\)에 가깝고 최소값과 최대값의 차이가 작을수록 모델의 예측값이 정확하다는 것을 의미합니다. 아래의 소스코드와 같이 dotplot()함수를 이용하면, 각 알고리즘/모델 정확도의 평균, 최대값, 최소값을 그래프로 그려볼 수 있습니다. dotplot(results) summary(results)결과와 dotplot(results)그래프에서 확인할 수 있는 것 처럼, LDA 알고리즘의 정확도가 다섯 알고리즘 중 가장 높으므로 아이리스 종 분류를 위한 최적의 알고리즘으로 LDA 알고리즘을 선택할 수 있습니다. 아래의 소스코드로 LDA 알고리즘의 요약 정보를 확인하면, \\(120\\)의 행을 가지는 훈련 데이터셋을 입력값으로 하여 \\(10\\)개 서브셋을 이용한 교차 유효성 확인 기법 (\\(10\\)-fold cross validation)을 사용하여 이 알고리즘이 생성되었음을 알 수 있습니다. 뿐만 아니라, 알고리즘의 정확도가 \\(97.5\\)%라는 것도 알 수 있습니다. print(fit.lda) 7.5.6 알고리즘/모델 검증 아이리스 종 분류를 위한 최적의 알고리즘으로 선택된 LDA 알고리즘을 훈련시키는데 사용되지 않은 테스트 데이터셋을 알고리즘에 적용하여 정확도를 산출함으로써 알고리즘을 최종 검증합니다. 알고리즘 생성과 전혀 상관없는 데이터셋 (테스트 데이터셋)으로 알고리즘의 정확도을 계산하여, 새로운 데이터셋을 사용할 때 알고리즘이 얼마나 높은 정확도를 보이는지를 계산해 보는 것입니다. 선택된 LDA 알고리즘에 테스트 데이터셋을 입력값으로 사용하여 얻은 종 예측 결과 벡터와 테스트 데이터셋의 종 컬럼 벡터 비교하여 알고리즘의 예측 정확도를 측정할 수 있습니다. 아래의 소스코드를 이용하여 LDA 알고리즘에 테스트 데이터셋을 입력하여 정확도를 검증해 볼 수 있습니다. confusionMatrix()를 통하여 LDA 알고리즘이 \\(30\\)개의 테스트 데이터셋의 종 분류에 \\(100\\)%의 정확도를 보이는 것을 알 수 있습니다. 이는 알고리즘 유효성 검증 시의 정확도인 \\(97.5\\)% 보다 높은 정확도를 보이는 것으로, 생성된 알고리즘이 알고리즘 생성에 사용되지 않은 새로운 데이터를 입력값으로 사용할 때에도 잘 작동한다는 것을 보여줍니다. predictions &lt;- predict(fit.lda, testset) confusionMatrix(predictions, testset$Species) 이번 장에서는 통계적 대푯값과 박스 플롯, 도수분포표, 히스토그램, 도수분포다각형, 상대도수, 확률밀도곡선 등과 같은 통계의 기본 개념에 대해서 살펴보았습니다. 또한, 아이리스 데이터를 이용한 데이터 탐색, 데이터 시각화, 머신 러닝을 이용한 종 분류 예측도 다루어 보았습니다. https://en.wikipedia.org/wiki/Ronald_Fisher↩ "],
["eof.html", "8 끝 맺으며", " 8 끝 맺으며 지금까지 중학교 \\(1\\)학년 수학 교과 과정에 나오는 내용들을 R 사용자 관점에서 재구성해 보았습니다. 그때 그때 필요한 개념들을 다루었기 때문에 R의 개념들을 차근 차근 순서대로 다루는 데에는 한계가 있었습니다. 다만, 중학교 수학 교과 과정에서 다루는 개념과 내용들을 R과 같은 데이터 과학 도구를 이용하여 구현해 보았다는 데 의미를 두고 싶습니다. 이 책에 나온 내용을 여러분들이 전부 다 이해할 필요는 없습니다. 다만, 교과 과정 뿐만 아니라 교과 이외의 내용들에도 관심을 가지고 하나씩 알아나가고 또 조금씩 깊이를 더해 나가면 멀지 않은 미래에 여러분이 흥미를 느끼는 분야의 깊이 있는 지식을 가지게 될 것입니다. 이 책이 여러분들이 기본 수학 개념을 이해하는데 조금 도움이 되고 데이터 과학에 흥미를 느끼는 계기가 되면 좋겠습니다. "],
["references.html", "References", " References "]
]
